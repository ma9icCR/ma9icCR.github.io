<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Black Hat Python 2nd 6 | Ma9icCR</title><meta name="description" content="EXTENDING BURP PROXY–扩展Burp代理如果您曾经尝试过攻击web应用程序，您可能使用过Burp Suite执行信息爬取、代理浏览器流量，并执行其他攻击。Burp Suite还允许您创建自己的工具，称为 extensions (扩展)。使用Python、Ruby或纯Java，您可以在Burp GUI中添加面板，并将到Burp Suite中构建自动化技术。 我们将利用这个特性编写一"><meta name="keywords" content="Black_Hat_Python_2nd"><meta name="author" content="Ma9icCR"><meta name="copyright" content="Ma9icCR"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-6/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Black Hat Python 2nd 6"><meta property="og:url" content="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-6/"><meta property="og:site_name" content="Ma9icCR"><meta property="og:description" content="EXTENDING BURP PROXY–扩展Burp代理如果您曾经尝试过攻击web应用程序，您可能使用过Burp Suite执行信息爬取、代理浏览器流量，并执行其他攻击。Burp Suite还允许您创建自己的工具，称为 extensions (扩展)。使用Python、Ruby或纯Java，您可以在Burp GUI中添加面板，并将到Burp Suite中构建自动化技术。 我们将利用这个特性编写一"><meta property="og:image" content="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><meta property="article:published_time" content="2021-07-03T02:21:38.000Z"><meta property="article:modified_time" content="2022-03-28T07:20:31.431Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Black Hat Python 2nd 7" href="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-7/"><link rel="next" title="Black Hat Python 2nd 5" href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-5/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-03-28 15:20:31'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">35</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#EXTENDING-BURP-PROXY–扩展Burp代理"><span class="toc-number">1.</span> <span class="toc-text">EXTENDING BURP PROXY–扩展Burp代理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#安装配置"><span class="toc-number">1.1.</span> <span class="toc-text">安装配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Burp-模糊测试"><span class="toc-number">1.2.</span> <span class="toc-text">Burp 模糊测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires"><span class="toc-number">1.2.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Burp中利用Bing"><span class="toc-number">1.3.</span> <span class="toc-text">Burp中利用Bing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Turning-Website-Content-into-Password-Gold–将网站内容变成密码黄金"><span class="toc-number">1.4.</span> <span class="toc-text">Turning Website Content into Password Gold–将网站内容变成密码黄金</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Ma9icCR</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Black Hat Python 2nd 6</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-07-03 10:21:38"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-07-03</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-03-28 15:20:31"><i class="fas fa-history fa-fw"></i> 更新于 2022-03-28</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/books/">books</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="EXTENDING-BURP-PROXY–扩展Burp代理"><a href="#EXTENDING-BURP-PROXY–扩展Burp代理" class="headerlink" title="EXTENDING BURP PROXY–扩展Burp代理"></a>EXTENDING BURP PROXY–扩展Burp代理</h1><p>如果您曾经尝试过攻击web应用程序，您可能使用过Burp Suite执行信息爬取、代理浏览器流量，并执行其他攻击。Burp Suite还允许您创建自己的工具，称为 <em>extensions</em> (扩展)。使用Python、Ruby或纯Java，您可以在Burp GUI中添加面板，并将到Burp Suite中构建自动化技术。</p>
<p>我们将利用这个特性编写一些方便的工具来执行攻击和扩展侦察。第一个扩展将使用从 Burp Proxy 拦截的HTTP请求作为mutation fuzzer(变种模糊测试)的种子在Burp Intruder(入侵者)运行。第二个扩展将与微软必应API通信，以显示我们所有的虚拟主机用相同的IP地址作为目标网站，以及任何子域检测的目标域。最后，我们还将构建一个扩展，从一个目标网站创建一个单词列表，您可以在暴力破解密码攻击中使用到它。</p>
<p>本章假设你以前使用过Burp，知道如何用代理工具捕获请求，以及如何向Burp Intruder发送捕获请求。如果您需要关于如何完成这些任务的教程，请访问 PortSwigger Web Security (<a href="http://www.portswigger.net/" target="_blank" rel="noopener">http://www.portswigger.net/</a>)来入门。</p>
<p>我们必须承认，当我们第一次开始研究Burp Extender API时，我们花了一些时间来理解它是如何工作的。我们发现这有点令人感到困惑，因为我们是纯Python的用户，而且Java开发经验有限。但我们在Burp网站上发现了许多扩展，它们告诉我们其他人是如何开发扩展的。我们使用先前的技术来帮助我们理解如何开始实现我们自己的代码。本章将涵盖扩展功能的一些基础知识，但我们也将向您展示如何使用API文档作为指南。</p>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>Burp Suite是在Kali Linux上默认安装的。如果您使用的是其他机器，请从<a href="http://www.portswigger.net/" target="_blank" rel="noopener">http://www.portswigger.net/</a>下载Burp并配置。</p>
<p>遗憾的是，我们不得不承认，您将需要安装新版的Java。Kali Linux也默认安装了。如果您在不同的平台上，请使用系统的安装方法(如apt、yum或rpm)来获取。接下来，安装 <em>Jython</em> ，一个用Java编写的Python 2的实现。到目前为止，我们所有的代码都使用了Python 3的语法，但在本章中，我们将恢复到Python 2，因为这是Jython所要求的。您可以在官方网站上找到这个 JAR 文件，<a href="https://www.jython.org/download.html" target="_blank" rel="noopener">https://www.jython.org/download.html</a>。选择Jython 2.7独立安装程序。将JAR文件保存到一个容易记住的位置，比如您的Desktop(桌面)。</p>
<p>接下来，双击Kali机器上的Burp图标，或者从命令行运行Burp:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; java -XX:MaxPermSize=1G -jar burpsuite_pro_v1.6.jar</span><br></pre></td></tr></table></figure>

<p>这将启动Burp，您应该会看到它的图形用户界面(GUI)有很多优质的选项卡，如图6-1所示。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708173551350.png" alt="image-20210708173551350"></p>
<p>现在让我们将Burp指向Jython解释器。单击 <strong>Extender</strong> 选项，然后单击 <strong>Options</strong> 选。在Python Environment部分中，选择Jython JAR文件的位置，如图6-2所示。你可以先不去管其他的选项。我们准备开始编码我们的第一个扩展。让我们动起来!</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708173605364.png" alt="image-20210708173605364"></p>
<h2 id="Burp-模糊测试"><a href="#Burp-模糊测试" class="headerlink" title="Burp 模糊测试"></a>Burp 模糊测试</h2><p>在黑客工作的某个时刻，您可能会发现自己攻击的web应用程序或服务不允许您使用传统的web应用程序评估工具。例如，应用程序可能使用了太多的参数，或者它可能以某种方式被混淆，使得执行手动测试过于耗时。我们运行的标准工具不能处理陌生的协议，甚至在很多情况下无法处理JSON，这可能让我们感到难过。这时，您会发现将请求体传递给自定义的fuzzer时，建立一个可靠的HTTP流量基线(包括身份验证cookie)是很有用的。这个fuzzer可以用你选择的任何方式操纵有效载荷。我们将创建世界上最简单的web应用fuzzer作为我们运行的第一个Burp扩展，然后你可以在它里面扩展一些更智能的东西。</p>
<p>Burp有很多工具，你可以在执行web应用程序测试时使用。通常，您将使用代理捕获所有请求，当您看到感兴趣的请求时，将它发送给另一个Burp工具。一种常见的技术是将它们发送到 Repeater (中继器)工具，该工具可以让你重放网络流量，并手动修改任何有趣的地方。在查询参数来执行更多的自动攻击,你可以发送一个请求到 Intruder (入侵者)工具,它试图自动找出应该修改哪些区域的网络流量,然后你可以使用各种攻击,试图引起错误消息或梳理出漏洞。Burp扩展可以以多种方式与Burp工具套件进行交互。在我们的例子中，我们将把额外的功能直接绑定到 Intruder 工具上。</p>
<p>我们的第一想法应该是查看 Burp API 文档，以确定需要扩展哪些 Burp 类，以便编写自定义扩展。您可以通过单击 <strong>Extender</strong> 选项卡，然后单击 <strong>APIs</strong> 选项卡来访问此文档。API看起来有点吓人，因为它是特有的Java-y文档。但是请注意，Burp开发人员对每个类都进行了恰当的命名，从而很容易地确定我们想从哪里开始。特别是，因为我们试图在入侵攻击期间模糊测试web请求，我们可能希望关注 IIntruderPayloadGeneratorFactory 和 IIntruderPayloadGenerator 类。让我们看一下 IIntruderPayloadGeneratorFactory 类的文档:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extensions can implement this interface and then call</span></span><br><span class="line"><span class="comment"> [1] * IBurpExtenderCallbacks.registerIntruderPayloadGeneratorFactory()</span></span><br><span class="line"><span class="comment"> * to register a factory for custom Intruder payloads.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> interface IIntruderPayloadGeneratorFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is used by Burp to obtain the name of the payload</span></span><br><span class="line"><span class="comment">     * generator. This will be displayed as an option within the</span></span><br><span class="line"><span class="comment">     * Intruder UI when the user selects to use extension-generated</span></span><br><span class="line"><span class="comment">     * payloads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return The name of the payload generator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> [<span class="number">2</span>] <span class="function"><span class="keyword">String</span> <span class="title">getGeneratorName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is used by Burp when the user starts an Intruder</span></span><br><span class="line"><span class="comment">     * attack that uses this payload generator.</span></span><br><span class="line"><span class="comment">     * @param attack</span></span><br><span class="line"><span class="comment">     * An IIntruderAttack object that can be queried to obtain details</span></span><br><span class="line"><span class="comment">     * about the attack in which the payload generator will be used.</span></span><br><span class="line"><span class="comment">     * @return A new instance of</span></span><br><span class="line"><span class="comment">     * IIntruderPayloadGenerator that will be used to generate</span></span><br><span class="line"><span class="comment">     * payloads for the attack.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> [<span class="number">3</span>] <span class="function">IIntruderPayloadGenerator <span class="title">createNewInstance</span><span class="params">(IIntruderAttack attack)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明文档的第一部分[1]告诉我们如何正确地在 Burp 中注册我们的扩展。我们将扩展主要的 Burp 类以及 <em>IInteruderPayloadGeneratorFactory</em> 类。接下来，我们看到 Burp 期望在我们的主类中有两个类函数。Burp 将调用 <em>getGeneratorName</em> 类函数[2]来检索扩展的名称，并且希望返回一个字符串。<em>createNewInstance</em> 类函数[3]希望我们返回值为 <em>IInteruderPayloadGenerator</em> 的一个实例，这是我们必须创建的第二个类。</p>
<p>现在让我们完成实际的Python代码来满足这些需求。然后，我们将了解如何添加  <em>IIntruderPayloadGenerator</em> 类。打开一个新的Python文件并命名为 <em>bhp_fuzzer.py</em> ，输入以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="keyword">from</span> burp <span class="keyword">import</span> IBurpExtender</span><br><span class="line"><span class="keyword">from</span> burp <span class="keyword">import</span> IIntruderPayloadGeneratorFactory</span><br><span class="line"><span class="keyword">from</span> burp <span class="keyword">import</span> IIntruderPayloadGenerator</span><br><span class="line"><span class="keyword">from</span> java.util <span class="keyword">import</span> List, ArrayList</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">[<span class="number">2</span>] <span class="class"><span class="keyword">class</span> <span class="title">BurpExtender</span><span class="params">(IBurpExtender, IIntruderPayloadGeneratorFactory)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">registerExtenderCallbacks</span><span class="params">(self, callbacks)</span>:</span></span><br><span class="line">        self._callbacks = callbacks</span><br><span class="line">        self._helpers   = callbacks.getHelpers()</span><br><span class="line">    [<span class="number">3</span>] callbacks.registerIntruderPayloadGeneratorFactory(self)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">[<span class="number">4</span>] <span class="function"><span class="keyword">def</span> <span class="title">getGeneratorName</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BHP Payload Generator"</span></span><br><span class="line">[<span class="number">5</span>] <span class="function"><span class="keyword">def</span> <span class="title">createNewInstance</span><span class="params">(self, attack)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> BHPFuzzer(self, attack)</span><br></pre></td></tr></table></figure>

<p>这个简单的框架概述了我们需要什么来满足第一组需求。我们必须首先导入 <em>IBurpExtender</em> 类[1]，这是我们编写的每个扩展的要求。我们通过导入创建 Intruder payload 生成器所必需的类来遵循此要求。接下来，我们定义 <em>BurpExtender</em> 类[2]，它扩展了 <em>IBurpExtender</em> 和 <em>IIntruderPayloadGeneratorFactory</em> 类。然后我们使用 <em>registerIntruderPayloadGeneratorFactory</em> 类函数[3]注册我们的类，这样 Intruder 工具就知道我们可以生成payload。接下来，我们实现 <em>getGeneratorName</em> 类函数[4]来简单地返回我们的 payload 生成器的名称。最后，我们实现了 <em>createNewInstance</em> 类函数[5]，该函数接收攻击参数并返回一个 <em>IIntruderPayloadGenerator</em> 类的实例，我们称之为 <em>BHPFuzzer</em> 。</p>
<p>让我们看一下 <em>IIntruderPayloadGenerator</em> 类的文档，这样我们就知道要实现什么了:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This interface is used for custom Intruder payload generators.</span></span><br><span class="line"><span class="comment"> * Extensions</span></span><br><span class="line"><span class="comment"> * that have registered an</span></span><br><span class="line"><span class="comment"> * IIntruderPayloadGeneratorFactory must return a new instance of</span></span><br><span class="line"><span class="comment"> * this interface when required as part of a new Intruder attack.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> interface IIntruderPayloadGenerator</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method is used by Burp to determine whether the payload</span></span><br><span class="line"><span class="comment"> * generator is able to provide any further payloads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return Extensions should return</span></span><br><span class="line"><span class="comment"> * false when all the available payloads have been used up,</span></span><br><span class="line"><span class="comment"> * otherwise true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> [<span class="number">1</span>] <span class="function"><span class="keyword">boolean</span> <span class="title">hasMorePayloads</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method is used by Burp to obtain the value of the next payload.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param baseValue The base value of the current payload position.</span></span><br><span class="line"><span class="comment"> * This value may be null if the concept of a base value is not</span></span><br><span class="line"><span class="comment"> * applicable (e.g. in a battering ram attack).</span></span><br><span class="line"><span class="comment"> * @return The next payload to use in the attack.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> [<span class="number">2</span>] <span class="keyword">byte</span>[] getNextPayload(<span class="keyword">byte</span>[] baseValue);</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method is used by Burp to reset the state of the payload</span></span><br><span class="line"><span class="comment"> * generator so that the next call to</span></span><br><span class="line"><span class="comment"> * getNextPayload() returns the first payload again. This</span></span><br><span class="line"><span class="comment"> * method will be invoked when an attack uses the same payload</span></span><br><span class="line"><span class="comment"> * generator for more than one payload position, for example in a</span></span><br><span class="line"><span class="comment"> * sniper attack.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> [<span class="number">3</span>] <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很好，现在我们知道我们需要实现基类，它需要有三个类函数。第一个是hasMorePayloads [1]，它决定是否继续向Burp Intruder发送变异的请求。我们会用柜台来处理这件事。一旦计数器达到最大值，我们将返回 <em>False</em> 以停止生成模糊测试用例。<em>getNextPayload</em> 函数[2]将从您捕获的HTTP请求中接收原始有效载荷数据。或者，如果您在HTTP请求中选择了多个有效负载区域，您将只收到您计划进行模糊测试的字节部分(稍后将对此进行详细介绍)。这个函数允许我们产生原始的模糊测试用例，然后返回给Burp发送。最后一个类函数，<em>reset</em> [3]，如果我们生成一组已知的模糊测试请求，模糊测试器就可以针对 Intruder 标签中指定的每个有效载荷位置迭代这些值。我们的模糊测试功能没有那么繁琐；它将总是随机模糊测试每个HTTP请求。</p>
<p>现在让我们看看当我们在Python中实现它时会是什么样子。将以下代码添加到 <em>bhp_fuzzer.py</em> 的底部:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">BHPFuzzer</span><span class="params">(IIntruderPayloadGenerator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, extender, attack)</span>:</span></span><br><span class="line">        self._extender = extender</span><br><span class="line">        self._helpers  = extender._helpers</span><br><span class="line">        self._attack   = attack</span><br><span class="line">    [<span class="number">2</span>] self.max_payloads   = <span class="number">10</span></span><br><span class="line">        self.num_iterations = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">[<span class="number">3</span>] <span class="function"><span class="keyword">def</span> <span class="title">hasMorePayloads</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.num_iterations == self.max_payloads:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">[<span class="number">4</span>] <span class="function"><span class="keyword">def</span> <span class="title">getNextPayload</span><span class="params">(self,current_payload)</span>:</span></span><br><span class="line">        <span class="comment"># convert into a string</span></span><br><span class="line">    [<span class="number">5</span>] payload = <span class="string">""</span>.join(chr(x) <span class="keyword">for</span> x <span class="keyword">in</span> current_payload)</span><br><span class="line">        <span class="comment"># call our simple mutator to fuzz the POST</span></span><br><span class="line">    [<span class="number">6</span>] payload = self.mutate_payload(payload)</span><br><span class="line">        <span class="comment"># increase the number of fuzzing attempts</span></span><br><span class="line">    [<span class="number">7</span>] self.num_iterations += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> payload</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.num_iterations = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>我们首先定义一个 <em>BHPFuzzer</em> 类[1]，它扩展了 <em>IIntruderPayloadGenerator</em> 类。我们定义所需的类变量，然后添加 <em>max_payloads</em> [2]和 <em>num_iterations</em> 变量，用于让 Burp 知道我们何时完成模糊测试。当然，如果您愿意，您可以让扩展一直运行下去，但是出于测试目的，我们将设置时间限制。接下来，我们实现 <em>hasMorePayloads</em> 类函数[3]，它只是检查我们是否已经达到模糊测试迭代的最大次数。您可以通过始终返回 True 来使它可以持续运行扩展。getNextPayload 类函数[4]接收原始的HTTP有效载荷，我们将在这里进行模糊化测试。 <em>current_payload</em> 变量以字节数组的形式返回，因此我们将其转换为字符串[5]，然后将其传递给 <em>mutate_payload</em> 模糊测试函数[6]。然后，我们增加 <em>num_iterations</em> 变量[7]并返回变异后的有效载荷。我们的最后一个函数是 <em>reset</em> 函数，它什么也不做就返回。</p>
<p>现在让我们写一个世界上最简单的模糊测试函数，你可以根据自己的想法来修改。例如，这个函数知道当前有效数据载荷的值，所以如果您有一个棘手的协议需要一些特殊的东西，比如CRC校验和或长度字段，您可以在返回之前在这个函数中执行这些计算。将以下代码添加到 <em>bhp_fuzzer.py</em> 的 <em>BHPFuzzer</em> 类中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mutate_payload</span><span class="params">(self,original_payload)</span>:</span></span><br><span class="line">        <span class="comment"># pick a simple mutator or even call an external script</span></span><br><span class="line">        picker = random.randint(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">        <span class="comment"># select a random offset in the payload to mutate</span></span><br><span class="line">        offset  = random.randint(<span class="number">0</span>,len(original_payload)<span class="number">-1</span>)</span><br><span class="line">    [<span class="number">1</span>] front, back = original_payload[:offset], original_payload[offset:]</span><br><span class="line">        <span class="comment"># random offset insert a SQL injection attempt</span></span><br><span class="line">        <span class="keyword">if</span> picker == <span class="number">1</span>:</span><br><span class="line">        [<span class="number">2</span>] front += <span class="string">"'"</span></span><br><span class="line">            <span class="comment"># jam an XSS attempt in</span></span><br><span class="line">        <span class="keyword">elif</span> picker == <span class="number">2</span>:</span><br><span class="line">        [<span class="number">3</span>] front += <span class="string">"&lt;script&gt;alert('BHP!');&lt;/script&gt;"</span></span><br><span class="line">        <span class="comment"># repeat a random chunk of the original payload</span></span><br><span class="line">        <span class="keyword">elif</span> picker == <span class="number">3</span>:</span><br><span class="line">        [<span class="number">4</span>] chunk_length = random.randint(<span class="number">0</span>, len(back)<span class="number">-1</span>)</span><br><span class="line">            repeater = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(repeater):</span><br><span class="line">                front += original_payload[:offset + chunk_length]</span><br><span class="line">    [<span class="number">5</span>] <span class="keyword">return</span> front + back</span><br></pre></td></tr></table></figure>

<p>首先，我们获取有效载荷 <em>payload</em> ，并将其分成两个随机长度的块， <em>front</em> 和 <em>back</em> [1]。然后，我们从三个变异器中随机挑选:一个简单的SQL注入测试，它在 <em>front</em> 块[2]的末尾添加一个单引号；一个跨站点脚本(XSS)测试，它在 <em>front</em> 块[3]的末尾添加一个脚本标签；以及最后一个变异器，它从原始有效负载 <em>payload</em> 中选择一个随机块，随机重复多次，并将结果添加到 <em>front</em> 块[4]的末尾。然后，我们将 <em>back</em> 块添加到修改后的 <em>front</em> 块，以组成变异后的有效载荷[5]。我们现在有了我们可用的 Burp Intruder 扩展。让我们看看如何加载它。</p>
<h3 id="Kicking-the-Tires"><a href="#Kicking-the-Tires" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>首先，我们必须加载扩展并确保它不会包含错误。单击 <em>Burp</em> 中的 <strong>Extender</strong> 选项卡，然后单击 <strong>Add</strong> 按钮。应该会出现一个屏幕，让你把 <em>Burp</em> 指向 <em>fuzzer</em> 。请确保您设置了与图6-3所示相同的选项。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708173631074.png" alt="image-20210708173631074"></p>
<p>单击 <strong>Next</strong> ，这时Burp应该已经开始加载扩展了。如果有错误，请单击 <strong>Errors</strong> 选项卡，调试错误，然后单击 <strong>Close</strong> 。您的扩展器屏幕现在应该如图6-4所示。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708173647821.png" alt="image-20210708173647821"></p>
<p>如您所见，我们的扩展已经被加载，Burp已经识别了注册的 Intruder payload 生成器。我们现在准备在真正的攻击中利用扩展。确保您的网络浏览器设置为使用 <em>Burp Proxy</em> 作为端口8080上的本地主机代理。现在让我们开始攻击与第5章相同的 Acunetix web应用程序。只需访问至<a href="http://testphp.vulnweb.com/" target="_blank" rel="noopener">http://testphp.vulnweb.com/</a>。</p>
<p>例如，作者使用他们网站上的小搜索栏提交了对字符串“test”的搜索。图6-5显示了如何在 <em>Proxy</em> 菜单的HTTP历史标签中看到这个请求。右键单击请求，将其发送给 <em>Intruder</em> 。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708173725418.png" alt="image-20210708173725418"></p>
<p>现在切换到 <strong>Intruder</strong> 选项，并单击 <strong>Positions</strong> 选项。将出现一个屏幕，突出显示每个查询参数。这是 Burp 识别我们应该模糊测试的点的方法。如果您愿意，您可以尝试移动 payload 分隔符或者选择整个有效负载来进行模糊测试，但是现在，让Burp决定模糊测试什么部分。为了清楚起见，请参见图6-6，它显示了有效负载突出显示是如何起效的。</p>
<p>现在单击 <strong>Payloads</strong> 选项。在此屏幕中，单击 <strong>Payload type</strong> 下拉列表，然后选择 <strong>Extension-generated</strong> 。在 payload 选项部分，单击 <strong>Select generator</strong> 按钮，并从下拉列表中选择 <strong>BHP Payload</strong><br><strong>Generator</strong> 。您的 <em>Payload</em> 屏幕窗口现在应该如图6-7所示。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708173711240.png" alt="image-20210708173711240"></p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708173744146.png" alt="image-20210708173744146"></p>
<p>现在我们准备发送请求。在 Burp 菜单栏的顶部，单击 <strong>Intruder</strong> ，然后选择 <strong>Start Attack</strong> 。 Burp 应该会开始发送用于模糊测试的请求，很快你就能查看到结果。当作者运行fuzzer时，我们收到了如图6-8所示的输出。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708173809846.png" alt="image-20210708173809846"></p>
<p>从对请求7的响应中的粗体警告可以看出，我们发现了一个SQL注入漏洞。</p>
<p>即使我们构建这个fuzzer只是为了演示，你也会惊讶于它对于让web应用程序输出错误、公开应用程序路径或生成许多其他扫描器可能会错过的行为的有效性。最重要的是，我们设法让我们的定制扩展来协同  Burp 的 <em>Intruder</em> 攻击。现在让我们创建一个扩展，它将帮助我们对web服务器执行扩展侦察。</p>
<h2 id="Burp中利用Bing"><a href="#Burp中利用Bing" class="headerlink" title="Burp中利用Bing"></a>Burp中利用Bing</h2><p>一个web服务器服务多个web应用程序并不少见，其中一些您可能并不知道。如果您正在攻击服务器，您应该尽最大努力发现其他主机名，因为它们可能会让您更容易获得 shell 。在你的目标同一台机器上发现不安全的web应用程序，甚至开发资源，并不罕见。微软的 <strong>Bing</strong> (必应)搜索引擎具有搜索功能，允许您使用 “IP” 搜索修饰符查询必应在单个IP地址上找到的所有网站。如果您使用 “domain” 搜索修饰符，Bing还会告诉您给定域的所有子域。</p>
<p>现在，我们可以使用 scraper 将这些查询提交给必应，然后获得结果中的HTML，但这不是好的习惯方式(也违反了大多数搜索引擎的使用条款)。为了避免麻烦，我们将改为使用 Bing API (必应应用编程接口)以编程方式提交这些查询，并自己解析结果。(访问<a href="https://www.microsoft.com/en-us/bing/apis/bing-web-search-api/" target="_blank" rel="noopener">https://www.microsoft.com/en-us/bing/apis/bing-web-search-api/</a>使用您自己的免费必应应用编程接口密钥进行设置。)除了一个上下文菜单，我们不会用这个扩展实现任何花哨的 Burp 图形用户界面；我们只需在每次运行查询时将结果输出到 Burp 中，任何检测到的 Burp 目标范围的URL都会被自动添加。</p>
<p>(笔者注：<strong>Web Scraper</strong>，一个轻量的数据爬虫利器。)</p>
<p>因为我们已经向您介绍了如何阅读 Burp API 文档并将其翻译成 Python ，所以现在让我们直接进入代码。打开 <em>bhp_bing.py</em> 并输入以下内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> burp <span class="keyword">import</span> IBurpExtender</span><br><span class="line"><span class="keyword">from</span> burp <span class="keyword">import</span> IContextMenuFactory</span><br><span class="line"><span class="keyword">from</span> java.net <span class="keyword">import</span> URL</span><br><span class="line"><span class="keyword">from</span> java.util <span class="keyword">import</span> ArrayList</span><br><span class="line"><span class="keyword">from</span> javax.swing <span class="keyword">import</span> JMenuItem</span><br><span class="line"><span class="keyword">from</span> thread <span class="keyword">import</span> start_new_thread</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">[<span class="number">1</span>] API_KEY = <span class="string">"YOURKEY"</span></span><br><span class="line">API_HOST = <span class="string">'api.cognitive.microsoft.com'</span></span><br><span class="line">[<span class="number">2</span>] <span class="class"><span class="keyword">class</span> <span class="title">BurpExtender</span><span class="params">(IBurpExtender, IContextMenuFactory)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">registerExtenderCallbacks</span><span class="params">(self, callbacks)</span>:</span></span><br><span class="line">        self._callbacks = callbacks</span><br><span class="line">        self._helpers   = callbacks.getHelpers()</span><br><span class="line">        self.context    = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># we set up our extension</span></span><br><span class="line">        callbacks.setExtensionName(<span class="string">"BHP Bing"</span>)</span><br><span class="line">    [<span class="number">3</span>]  callbacks.registerContextMenuFactory(self)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createMenuItems</span><span class="params">(self, context_menu)</span>:</span></span><br><span class="line">        self.context = context_menu</span><br><span class="line">        menu_list = ArrayList()</span><br><span class="line">    [<span class="number">4</span>] menu_list.add(JMenuItem(</span><br><span class="line">          <span class="string">"Send to Bing"</span>, actionPerformed=self.bing_menu))</span><br><span class="line">        <span class="keyword">return</span> menu_list</span><br></pre></td></tr></table></figure>

<p>这是我们的Bing扩展的第一部分。请确保将您的必应应用编程接口密钥粘贴到位置[1]。你每月可以免费搜索1000次。我们首先定义一个 <em>BurpExtender</em> 类[2]，它实现了标准的 <em>IBurpExtender</em> 接口，以及 <em>IContextMenuFactory</em> ，它允许我们在用户右键单击Burp中的请求时提供一个上下文菜单。该菜单将显示 <em>“Send to Bing”</em> 选项。我们注册一个菜单处理器[3]，它将判定用户点击了哪个站点，使我们能够构建我们的必应查询。然后我们设置一个 <em>createMenuItem</em> 函数，它将接收一个 <em>IContextMenuInvocation</em> 对象，并使用它来确定用户选择了哪个HTTP请求。最后一步是渲染菜单项，并用 <em>bing_menu</em> 函数[4]处理点击事件。</p>
<p>现在，让我们执行Bing查询，输出结果，并将所有发现的虚拟主机添加到 Burp 的目标范围:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bing_menu</span><span class="params">(self,event)</span>:</span></span><br><span class="line">        <span class="comment"># grab the details of what the user clicked</span></span><br><span class="line">    [<span class="number">1</span>] http_traffic = self.context.getSelectedMessages()</span><br><span class="line">        print(<span class="string">"%d requests highlighted"</span> % len(http_traffic))</span><br><span class="line">        <span class="keyword">for</span> traffic <span class="keyword">in</span> http_traffic:</span><br><span class="line">            http_service = traffic.getHttpService()</span><br><span class="line">            host         = http_service.getHost()</span><br><span class="line">            print(<span class="string">"User selected host: %s"</span> % host)</span><br><span class="line">            self.bing_search(host)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bing_search</span><span class="params">(self,host)</span>:</span></span><br><span class="line">        <span class="comment"># check if we have an IP or hostname</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">        [<span class="number">2</span>] is_ip = bool(socket.inet_aton(host))</span><br><span class="line">        <span class="keyword">except</span> socket.error:</span><br><span class="line">            is_ip = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> is_ip:</span><br><span class="line">            ip_address = host</span><br><span class="line">            domain = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip_address = socket.gethostbyname(host)</span><br><span class="line">            domain = <span class="literal">True</span></span><br><span class="line">    [<span class="number">3</span>] start_new_thread(self.bing_query, (<span class="string">'ip:%s'</span> % ip_address,))</span><br><span class="line">        <span class="keyword">if</span> domain:</span><br><span class="line">        [<span class="number">4</span>] start_new_thread(self.bing_query, (<span class="string">'domain:%s'</span> % host,))</span><br></pre></td></tr></table></figure>

<p>当用户单击我们定义的上下文菜单项时， <em>bing_menu</em> 函数会被触发。我们检索突出显示的HTTP请求[1]。然后，我们检索每个请求的主机部分，并将其发送到 <em>bing_search</em> 函数进行进一步处理。<em>bing_search</em> 函数首先确定主机部分是IP地址还是主机名[2]。然后，我们向 Bing 查询与主机具有相同IP地址的所有虚拟主机[3]。如果我们的扩展也收到了一个域，那么我们会对 Bing 反馈的所有子域进行二次搜索[4]。</p>
<p>现在让我们安装所需的管道，以便将请求发送给 Bing ，并使用 Burp 的 HTTP API 解析结果。在 <em>BurpExtender</em> 类中添加以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bing_query</span><span class="params">(self,bing_query_string)</span>:</span></span><br><span class="line">    print(<span class="string">'Performing Bing search: %s'</span> % bing_query_string)</span><br><span class="line">    http_request = <span class="string">'GET https://%s/bing/v7.0/search?'</span> % API_HOST</span><br><span class="line">    <span class="comment"># encode our query</span></span><br><span class="line">    http_request += <span class="string">'q=%s HTTP/1.1\r\n'</span> % urllib.quote(bing_query_string)</span><br><span class="line">    http_request += <span class="string">'Host: %s\r\n'</span> % API_HOST</span><br><span class="line">    http_request += <span class="string">'Connection:close\r\n'</span></span><br><span class="line">[<span class="number">1</span>] http_request += <span class="string">'Ocp-Apim-Subscription-Key: %s\r\n'</span> % API_KEY</span><br><span class="line">    http_request += <span class="string">'User-Agent: Black Hat Python\r\n\r\n'</span></span><br><span class="line">[<span class="number">2</span>] json_body = self._callbacks.makeHttpRequest(</span><br><span class="line">          API_HOST, <span class="number">443</span>, <span class="literal">True</span>, http_request).tostring()</span><br><span class="line">[<span class="number">3</span>] json_body = json_body.split(<span class="string">'\r\n\r\n'</span>, <span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">    [<span class="number">4</span>] response = json.loads(json_body)</span><br><span class="line">    <span class="keyword">except</span> (TypeError, ValueError) <span class="keyword">as</span> err:</span><br><span class="line">        print(<span class="string">'No results from Bing: %s'</span> % err)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sites = list()</span><br><span class="line">        <span class="keyword">if</span> response.get(<span class="string">'webPages'</span>):</span><br><span class="line">            sites = response[<span class="string">'webPages'</span>][<span class="string">'value'</span>]</span><br><span class="line">        <span class="keyword">if</span> len(sites):</span><br><span class="line">            <span class="keyword">for</span> site <span class="keyword">in</span> sites:</span><br><span class="line">            [<span class="number">5</span>] print(<span class="string">'*'</span>*<span class="number">100</span>)</span><br><span class="line">                print(<span class="string">'Name: %s       '</span> % site[<span class="string">'name'</span>])</span><br><span class="line">                print(<span class="string">'URL: %s        '</span> % site[<span class="string">'url'</span>])</span><br><span class="line">                print(<span class="string">'Description: %r'</span> % site[<span class="string">'snippet'</span>])</span><br><span class="line">                print(<span class="string">'*'</span>*<span class="number">100</span>)</span><br><span class="line">                java_url = URL(site[<span class="string">'url'</span>])</span><br><span class="line">            [<span class="number">6</span>] <span class="keyword">if</span> <span class="keyword">not</span> self._callbacks.isInScope(java_url):</span><br><span class="line">                    print(<span class="string">'Adding %s to Burp scope'</span> % site[<span class="string">'url'</span>])</span><br><span class="line">                    self._callbacks.includeInScope(java_url)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">'Empty response from Bing.: %s'</span></span><br><span class="line">                            % bing_query_string)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>Burp 的 HTTP API 要求我们在发送之前将整个HTTP请求构建为一个字符串。我们还需要添加我们的 Bing API key (必应应用编程接口密钥)来进行 API 调用[1]。然后，我们向微软服务器发送HTTP请求[2]。当响应返回时，我们分离出报文头[3]，然后将其传递给我们的 JSON 解析器[4]。对于每组结果，我们输出一些关于我们发现的站点的信息。如果发现的站点不在 Burp 的目标范围内[6]，我们会自动把它添加进去。</p>
<p>在这样做的过程中，我们将 Jython API 和纯Python混合在一个 Burp 扩展中。这应该有助于我们在攻击特定目标时进行额外的侦察工作。我们来试一试吧。</p>
<h3 id="Kicking-the-Tires-1"><a href="#Kicking-the-Tires-1" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>为使 Bing 搜索扩展正常工作，请使用与我们在模糊测试扩展中相同的步骤。加载后，浏览URL：<a href="http://testphp.vulnweb.com/" target="_blank" rel="noopener">http://testphp.vulnweb.com/</a>。然后右键单击您刚刚发出的 GET 请求。如果扩展加载正确，您应该会看到显示菜单选项 <strong>Send to Bing</strong> ，如图6-9所示。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708173836276.png" alt="image-20210708173836276"></p>
<p>当你点击这个菜单选项时，你应该可以开始看到 Bing 的返回结果，如图6-10所示。您得到的结果取决于您在加载扩展时选择的输出。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708173852964.png" alt="image-20210708173852964"></p>
<p>如果您在Burp中单击 <strong>Target</strong> 选项并选择 <strong>Scope</strong> ，您应该会看到新的项目自动添加到目标范围中，如图6-11所示。目标范围会将攻击、爬取和扫描等活动限制于已定义的主机。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708173912748.png" alt="image-20210708173912748"></p>
<h2 id="Turning-Website-Content-into-Password-Gold–将网站内容变成密码黄金"><a href="#Turning-Website-Content-into-Password-Gold–将网站内容变成密码黄金" class="headerlink" title="Turning Website Content into Password Gold–将网站内容变成密码黄金"></a>Turning Website Content into Password Gold–将网站内容变成密码黄金</h2><p>很多时候，安全性归结为一点:用户密码。这是令人悲伤但十分真实的。更糟糕的是，当涉及到web应用程序，尤其是定制应用程序中，发现在一定次数的身份验证尝试失败后，他们没有将用户锁定在自己的帐户之外是非常常见的。在其他情况下，他们不会强制使用强密码。在这种情况下，像上一章那样的在线密码猜测的会话可能只是进入网站的入场券。</p>
<p>在线密码猜测的诀窍是获得正确的单词列表。如果你的时间很紧张，你总不能测试1000万个这样量级的密码，所以你需要能够创建一个针对有问题的网站的单词列表。当然，Kali Linux 中有一些脚本可以抓取网站，并根据网站内容生成单词列表。但是如果你已经用 Burp 扫描了网站，为什么仅仅为了生成一个单词列表就要发送更多的流量呢？另外，这些脚本通常需要记住大量的命令行参数。If you’re anything like us, you’ve already memorized enough command line arguments to impress your friends, so let’s make Burp do the heavy lifting.(笔者注：直译为：如果你和我们一样，你已经记住了足够多的命令行参数来打动你的朋友，所以让我们用 Burp 来完成这个重任。但是感觉有点不对，感觉这里朋友是不是指代可能实践中有同时合作的伙伴。结合上下文译为：如果你不能像我们一样记住这些命令行参数并说服伙伴一同使用，那我们还是让 Burp 来完成这项重任吧。)</p>
<p>打开 <em>bhp_wordlist.py</em> ，敲出下面的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> burp <span class="keyword">import</span> IBurpExtender</span><br><span class="line"><span class="keyword">from</span> burp <span class="keyword">import</span> IContextMenuFactory</span><br><span class="line"><span class="keyword">from</span> java.util <span class="keyword">import</span> ArrayList</span><br><span class="line"><span class="keyword">from</span> javax.swing <span class="keyword">import</span> JMenuItem</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> HTMLParser <span class="keyword">import</span> HTMLParser</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TagStripper</span><span class="params">(HTMLParser)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        HTMLParser.__init__(self)</span><br><span class="line">        self.page_text = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    [<span class="number">1</span>] self.page_text.append(data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_comment</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    [<span class="number">2</span>] self.page_text.append(data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strip</span><span class="params">(self, html)</span>:</span></span><br><span class="line">        self.feed(html)</span><br><span class="line">    [<span class="number">3</span>] <span class="keyword">return</span> <span class="string">" "</span>.join(self.page_text)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BurpExtender</span><span class="params">(IBurpExtender, IContextMenuFactory)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">registerExtenderCallbacks</span><span class="params">(self, callbacks)</span>:</span></span><br><span class="line">        self._callbacks = callbacks</span><br><span class="line">        self._helpers   = callbacks.getHelpers()</span><br><span class="line">        self.context    = <span class="literal">None</span></span><br><span class="line">        self.hosts      = set()</span><br><span class="line">        <span class="comment"># Start with something we know is common</span></span><br><span class="line">    [<span class="number">4</span>] self.wordlist   = set([<span class="string">"password"</span>])</span><br><span class="line">        <span class="comment"># we set up our extension</span></span><br><span class="line">        callbacks.setExtensionName(<span class="string">"BHP Wordlist"</span>)</span><br><span class="line">        callbacks.registerContextMenuFactory(self)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createMenuItems</span><span class="params">(self, context_menu)</span>:</span></span><br><span class="line">        self.context = context_menu</span><br><span class="line">        menu_list = ArrayList()</span><br><span class="line">        menu_list.add(JMenuItem(</span><br><span class="line">            <span class="string">"Create Wordlist"</span>, actionPerformed=self.wordlist_menu))</span><br><span class="line">        <span class="keyword">return</span> menu_list</span><br></pre></td></tr></table></figure>

<p>上面的代码您现在应该很熟悉了。我们开始先导入所需的模块。一个辅助的类 <em>TagStripper</em> 稍后将帮助我们从要处理的HTTP响应中剥离出HTML标签。它的 <em>handle_data</em> 函数将页面文本[1]存储在一个成员变量中。我们还定义了 <em>handle_comment</em> 函数，因为我们希望将存储在开发人员注释中的单词也添加到密码列表中。以同一种方式， <em>handle_comment</em> 只是换了 <em>handle_data</em> 函数名称[2] (以防我们想要改变以后处理页面文本的方式)。</p>
<p><em>strip</em> 函数将HTML代码发送给基类 <em>HTMLParser</em> ，并返回页面文本结果[3]，这将在以后派上用场。其余部分几乎与我们刚刚完成的 <em>bhp_bing.py</em> 脚本的开头完全相同。同样，目标是在 Burp UI (用户界面)中创建一个上下文菜单项。这里唯一的新东西是我们将单词列表存储在一个 set (集合)中，这确保了我们不会在运行过程中引入重复的单词。我们用每个人最喜欢的密码， <em>password</em> [4]来初始化这个集合，只是为了确保它最终出现在我们的最终列表中。</p>
<p>现在，让我们添加一些逻辑功能，以从 Burp 获取选定的HTTP流量，并将其转换为基本单词列表:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordlist_menu</span><span class="params">(self,event)</span>:</span></span><br><span class="line">    <span class="comment"># grab the details of what the user clicked</span></span><br><span class="line">    http_traffic = self.context.getSelectedMessages()</span><br><span class="line">    <span class="keyword">for</span> traffic <span class="keyword">in</span> http_traffic:</span><br><span class="line">        http_service  = traffic.getHttpService()</span><br><span class="line">        host          = http_service.getHost()</span><br><span class="line">    [<span class="number">1</span>] self.hosts.add(host)</span><br><span class="line">        http_response = traffic.getResponse()</span><br><span class="line">        <span class="keyword">if</span> http_response:</span><br><span class="line">        [<span class="number">2</span>] self.get_words(http_response)</span><br><span class="line">self.display_wordlist()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_words</span><span class="params">(self, http_response)</span>:</span></span><br><span class="line">    headers, body = http_response.tostring().split(<span class="string">'\r\n\r\n'</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># skip non-text responses</span></span><br><span class="line">[<span class="number">3</span>] <span class="keyword">if</span> headers.lower().find(<span class="string">"content-type: text"</span>) == <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    tag_stripper = TagStripper()</span><br><span class="line">[<span class="number">4</span>] page_text = tag_stripper.strip(body)</span><br><span class="line">[<span class="number">5</span>] words = re.findall(<span class="string">"[a-zA-Z]\w&#123;2,&#125;"</span>, page_text)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        <span class="comment"># filter out long strings</span></span><br><span class="line">        <span class="keyword">if</span> len(word) &lt;= <span class="number">12</span>:</span><br><span class="line">        [<span class="number">6</span>] self.wordlist.add(word.lower())</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>我们的第一项工作是定义 <em>wordlist_menu</em> 函数，让它负责处理菜单点击。它保存响应主机的名称[1]以备后用，然后检索 HTTP 响应并将其提供给 <em>get_words</em> 函数[2]。 <em>get_words</em> 检查响应报文头，以确保我们只处理基于文本的响应[3]。 <em>TagStripper</em> 类[4]从页面文本的其余部分剥离 HTML 代码。我们使用正则表达式来查找所有以字母字符开头并跟随如正则表达式 \w{2,} 所指定的两个或多个 “word” 的字符的单词[5]。我们以小写形式保存匹配该模式的单词到 <em>wordlist</em> [6]。</p>
<p>(笔者注：\w：匹配非特殊字符，即a-z、A-Z、0-9、_、汉字)</p>
<p>现在，让我们优化一下脚本，让它能够修改和显示捕获的单词列表:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mangle</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        year     = datetime.now().year</span><br><span class="line">        suffixes = [<span class="string">""</span>, <span class="string">"1"</span>, <span class="string">"!"</span>, year] [<span class="number">1</span>]</span><br><span class="line">        mangled  = []</span><br><span class="line">        <span class="keyword">for</span> password <span class="keyword">in</span> (word, word.capitalize()):</span><br><span class="line">            <span class="keyword">for</span> suffix <span class="keyword">in</span> suffixes:</span><br><span class="line">                mangled.append(<span class="string">"%s%s"</span> % (password, suffix)) [<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> mangled</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_wordlist</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"#!comment: BHP Wordlist for site(s) %s"</span> % <span class="string">", "</span>.join(self.hosts)) [<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> sorted(self.wordlist):</span><br><span class="line">            <span class="keyword">for</span> password <span class="keyword">in</span> self.mangle(word):</span><br><span class="line">                <span class="keyword">print</span> password</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>非常好！<em>mangle</em> 函数接受一个基础单词，并根据一些常见的密码创建策略将其转换为多个密码猜测。在这个简单的例子中，我们创建了一个后缀列表来附加在基础单词的末尾，包括当前年份[1]。接下来，我们循环遍历每个后缀，并将其添加到基础单词中[2]，以创建唯一的密码尝试。我们用大写的基础词做了另一个循环，以获得好的效果。在 <em>display_wordlist</em> 函数中，我们打印了一个 “John the Ripper” 样式的注释[3]来提醒我们使用了哪些站点来生成这个单词列表。然后我们修改每个基础词并打印修改结果。现在是时候上场试一下了。</p>
<h3 id="Kicking-the-Tires-2"><a href="#Kicking-the-Tires-2" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>单击 Burp 中的 <strong>Extender</strong> 选项，单击 <strong>Add</strong> 按钮，然后使用与我们之前的扩展相同的步骤来使 Wordlist 扩展工作。</p>
<p>在 <strong>Dashboard</strong> (仪表盘)选项中，选择 <strong>New live task</strong> (新建实时任务)，如图6-12所示。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708173940325.png" alt="image-20210708173940325"></p>
<p>当对话框出现时，选择 <strong>Add all links observed in traffic</strong> (添加流量中嗅探到的所有链接)，如图6-13所示，然后单击 <strong>OK</strong> 。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708174043211.png" alt="image-20210708174043211"></p>
<p>配置完扫描后，浏览器访问 <a href="http://testphp.vulnweb.com/" target="_blank" rel="noopener">http://testphp.vulnweb.com/</a> 并运行脚本。一旦 Burp 访问了目标站点上的所有链接，在 <strong>Target</strong> 选项的右上角窗格中选择所有请求，右键单击它们以调出上下文菜单，然后选择 <strong>Create Wordlist</strong> ，如图6-14所示。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708171829799.png" alt="image-20210708171829799"></p>
<p>现在检查扩展的 Output 标签。实际上，我们将它的输出保存到一个文件中，但是为了演示的目的，我们在 Burp 中显示单词列表，如图6-15所示。</p>
<p>现在，您可以将此列表反馈给 Burp Intruder ，以执行实际的密码猜测攻击。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708184112046.png" alt="image-20210708184112046"></p>
<p>我们现在已经通过生成我们自己的攻击 payload ，以及构建与 Burp UI 交互的扩展，演示了Burp API的一个小子集。在渗透测试过程中，您经常会遇到特定的问题或自动化的需求，而 Burp Extender API 提供了一个极好的接口来为您的代码提供方向，或者至少让您不需要不断地将捕获的数据从 Burp 复制并粘贴到另一个工具中。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ma9icCR</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-6/">https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ma9iccr.github.io" target="_blank">Ma9icCR</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Black-Hat-Python-2nd/">Black_Hat_Python_2nd</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021-07/Black-Hat-Python-2nd-7/"><img class="prev-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Black Hat Python 2nd 7</div></div></a></div><div class="next-post pull-right"><a href="/2021-06/Black-Hat-Python-2nd-5/"><img class="next-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Black Hat Python 2nd 5</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-11/" title="Black Hat Python 2nd 11"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-23</div><div class="relatedPosts_title">Black Hat Python 2nd 11</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-10/" title="Black Hat Python 2nd 10"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-20</div><div class="relatedPosts_title">Black Hat Python 2nd 10</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-9/" title="Black Hat Python 2nd 9"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-18</div><div class="relatedPosts_title">Black Hat Python 2nd 9</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-8/" title="Black Hat Python 2nd 8"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-13</div><div class="relatedPosts_title">Black Hat Python 2nd 8</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-7/" title="Black Hat Python 2nd 7"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="relatedPosts_title">Black Hat Python 2nd 7</div></div></a></div><div class="relatedPosts_item"><a href="/2021-06/Black-Hat-Python-2nd-5/" title="Black Hat Python 2nd 5"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-28</div><div class="relatedPosts_title">Black Hat Python 2nd 5</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Ma9icCR</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>