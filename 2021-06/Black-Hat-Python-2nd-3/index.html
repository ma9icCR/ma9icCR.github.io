<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Black Hat Python 2nd 3 | Ma9icCR</title><meta name="description" content="编写嗅探器网络嗅探器可以让您查看在目标计算机传入和发出的数据包。因此，它们在开发利用的前后都有许多实际用途。在某些情况下，您可以使用现有的嗅探工具，如 Wireshark (https:&#x2F;&#x2F;wireshark.org&#x2F;)或python解决方案，如Scapy(我们将在下一章探讨)。尽管如此，知道如何组装您自己的快速嗅探器来查看和解码网络流量也是很有好处的。 编写这样的工具还将使您对成熟的工具有一个深"><meta name="keywords" content="Black_Hat_Python_2nd"><meta name="author" content="Ma9icCR"><meta name="copyright" content="Ma9icCR"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-3/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Black Hat Python 2nd 3"><meta property="og:url" content="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-3/"><meta property="og:site_name" content="Ma9icCR"><meta property="og:description" content="编写嗅探器网络嗅探器可以让您查看在目标计算机传入和发出的数据包。因此，它们在开发利用的前后都有许多实际用途。在某些情况下，您可以使用现有的嗅探工具，如 Wireshark (https:&#x2F;&#x2F;wireshark.org&#x2F;)或python解决方案，如Scapy(我们将在下一章探讨)。尽管如此，知道如何组装您自己的快速嗅探器来查看和解码网络流量也是很有好处的。 编写这样的工具还将使您对成熟的工具有一个深"><meta property="og:image" content="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><meta property="article:published_time" content="2021-06-24T02:08:54.000Z"><meta property="article:modified_time" content="2022-03-28T07:20:14.863Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Black Hat Python 2nd 4" href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-4/"><link rel="next" title="Black Hat Python 2nd 2" href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-2/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-03-28 15:20:14'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">37</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#编写嗅探器"><span class="toc-number">1.</span> <span class="toc-text">编写嗅探器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#构建一个UDP主机探测工具"><span class="toc-number">1.1.</span> <span class="toc-text">构建一个UDP主机探测工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows和Linux的包嗅探"><span class="toc-number">1.2.</span> <span class="toc-text">Windows和Linux的包嗅探</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires"><span class="toc-number">1.2.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP层解码"><span class="toc-number">1.3.</span> <span class="toc-text">IP层解码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ctypes模块"><span class="toc-number">1.3.1.</span> <span class="toc-text">ctypes模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct模块"><span class="toc-number">1.3.2.</span> <span class="toc-text">struct模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编写IP解码器"><span class="toc-number">1.3.3.</span> <span class="toc-text">编写IP解码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires-1"><span class="toc-number">1.3.4.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解码ICMP"><span class="toc-number">1.4.</span> <span class="toc-text">解码ICMP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Ma9icCR</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Black Hat Python 2nd 3</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-06-24 10:08:54"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-06-24</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-03-28 15:20:14"><i class="fas fa-history fa-fw"></i> 更新于 2022-03-28</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/books/">books</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="编写嗅探器"><a href="#编写嗅探器" class="headerlink" title="编写嗅探器"></a>编写嗅探器</h1><p>网络嗅探器可以让您查看在目标计算机传入和发出的数据包。因此，它们在开发利用的前后都有许多实际用途。在某些情况下，您可以使用现有的嗅探工具，如 Wireshark (<a href="https://wireshark.org/" target="_blank" rel="noopener">https://wireshark.org/</a>)或python解决方案，如Scapy(我们将在下一章探讨)。尽管如此，知道如何组装您自己的快速嗅探器来查看和解码网络流量也是很有好处的。</p>
<p>编写这样的工具还将使您对成熟的工具有一个深刻的认识，因为这些工具可以轻松地处理更精细的问题，而您只需花费很少的精力。您还可能学到一些新的Python技术，并可能更好地理解底层网络位是如何工作的。</p>
<p>在前一章中，我们讨论了如何使用TCP和UDP发送和接收数据。这很可能是您与大多数网络服务交互的方式。但是在这些高级协议之下才是决定网络数据包如何发送和接收的构建块。您将使用原始套接字来访问较低层的网络信息，例如原始Internet协议(IP)和Internet控制消息协议(ICMP)头。在本章中，我们不会解码任何以太网信息，但是如果您打算执行任何底层网络攻击，例如ARP毒化(ARP欺骗)，或者正在开发无线评估工具，您应该非常熟悉以太网帧及其使用。</p>
<p>让我们先简要了解一下如何发现网段上的活动主机。</p>
<h2 id="构建一个UDP主机探测工具"><a href="#构建一个UDP主机探测工具" class="headerlink" title="构建一个UDP主机探测工具"></a>构建一个UDP主机探测工具</h2><p>我们的嗅探器的主要目标是发现目标网络上的主机。攻击者希望能够看到网络上的所有潜在目标，以便集中侦察和攻击利用。</p>
<p>我们将使用大多数操作系统的已知行为来确定指定IP地址上是否存在活动主机。当我们向主机上的一个关闭的端口发送UDP数据报时，该主机通常会返回一个ICMP消息，表明该端口不可达。这个ICMP消息告诉我们有一个存活的主机，因为如果没有主机，我们可能不会收到任何对UDP数据报的响应。因此，我们必须选择一个不太可能被使用的UDP端口。为了达到最大的覆盖范围，我们可以探测几个端口，以确保我们没有命中一个活动的UDP服务。</p>
<p>为什么使用用户数据报协议UDP呢?因为它可以在整个子网中洪泛消息并等待ICMP响应相应到达而没有开销。这是一个相当简单的扫描器，因为大部分工作都是解码和分析各种网络协议头。我们将在Windows和Linux上实现这个主机扫描程序，以最大限度地提高在企业环境中使用它的可行性。</p>
<p>我们还可以在扫描器中构建额外的规则我们发现的任何主机上启动完整的Nmap端口扫描。这样我们就能确定它们是否有可行的网络攻击面。这是留给读者的练习，我们作者期待听到一些创造性的方法，你可以扩展这个核心概念。让我们开始吧。</p>
<h2 id="Windows和Linux的包嗅探"><a href="#Windows和Linux的包嗅探" class="headerlink" title="Windows和Linux的包嗅探"></a>Windows和Linux的包嗅探</h2><p>在Windows中访问原始套接字的过程与Linux上略有不同，但我们希望能够灵活地将相同的嗅探器部署到多种平台上。为此，我们将创建一个套接字对象，然后确定我们在哪个平台上运行。Windows系统要求我们，通过套接字输入/输出控制(IOCTL)设置一些额外的标志，设置网络接口为混杂模式。 <em>input/output control</em>  (IOCTL)是用户空间程序与内核模式组件通信的一种手段。您在这里了解一下:<a href="http://en.wikipedia.org/wiki/Ioctl" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Ioctl</a></p>
<p>在第一个例子中，我们只需设置原始套接字嗅探器，读取单个数据包，然后退出:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># host to listen on</span></span><br><span class="line">HOST = <span class="string">'192.168.1.203'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># create raw socket, bin to public interface</span></span><br><span class="line">    <span class="keyword">if</span> os.name == <span class="string">'nt'</span>:</span><br><span class="line">        socket_protocol = socket.IPPROTO_IP</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        socket_protocol = socket.IPPROTO_ICMP</span><br><span class="line">[<span class="number">1</span>] sniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol)</span><br><span class="line">    sniffer.bind((HOST, <span class="number">0</span>))</span><br><span class="line">    <span class="comment"># include the IP header in the capture</span></span><br><span class="line">[<span class="number">2</span>] sniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, <span class="number">1</span>)</span><br><span class="line">[<span class="number">3</span>] <span class="keyword">if</span> os.name == <span class="string">'nt'</span>:</span><br><span class="line">        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)</span><br><span class="line">    <span class="comment"># read one packet</span></span><br><span class="line">[<span class="number">4</span>] print(sniffer.recvfrom(<span class="number">65565</span>))</span><br><span class="line">    <span class="comment">#  if we're on Windows, turn off promiscuous mode</span></span><br><span class="line">[<span class="number">5</span>] <span class="keyword">if</span> os.name == <span class="string">'nt'</span>:</span><br><span class="line">        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>我们首先将 <em>HOST</em> IP定义为我们自己的机器地址，并使用嗅探网络接口[1]上的数据包所需的参数构造套接字对象。Windows和Linux之间的区别是，Windows允许我们嗅探所有传入的数据包，而不用考虑协议，而Linux强制指定我们嗅探ICMP数据包。请注意，我们使用的是混杂模式，它需要Windows上的管理员权限或Linux上的root权限。混杂模式允许我们嗅探网卡经过的所有数据包，甚至那些目标不是我们特定主机的数据包。然后，我们设置一个套接字选项[2]，其中包括捕获的数据包中的IP头。下一步[3]是确定我们是否使用Windows，如果是，执行额外的步骤，发送IOCTL到网卡驱动程序，以启用混杂模式。如果你在虚拟机上运行Windows，你可能会收到一个通知，说客户操作系统启用了混杂模式;当然，你会允许的。现在，我们准备执行一些实际的嗅探任务，在本例中，我们只打印出整个没有进行解码的原始数据包[4]。这只是为了确保嗅探代码的核心能够正常工作。在嗅探到单个数据包之后，我们再次测试Windows，然后在退出脚本之前禁用混杂模式[5]。</p>
<h3 id="Kicking-the-Tires"><a href="#Kicking-the-Tires" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>在Windows下打开一个新的终端或 <em>cmd.exe</em> shell，运行以下命令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sniffer.py</span><br></pre></td></tr></table></figure>

<p>在另一个终端或shell窗口中，选择要ping的主机。在这里，我们ping nostarch.com:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping nostarch.com</span><br></pre></td></tr></table></figure>

<p>在你运行嗅探器的第一个窗口中，你应该会看到一些乱码输出，类似于以下内容:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(b<span class="string">'E\x00\x00T\xad\xcc\x00\x00\x80\x01\n\x17h\x14\xd1\x03\xac\x10\x9d\x9d\x00\</span></span><br><span class="line"><span class="string">x00g,\rv\x00\x01\xb6L\x1b^\x00\x00\x00\x00\xf1\xde\t\x00\x00\x00\x00\x00\x10\</span></span><br><span class="line"><span class="string">x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f</span></span><br><span class="line"><span class="string">!"#$%&amp;\'</span>()*+,-./01234567<span class="string">', ('</span>104.20.209.3<span class="string">', 0))</span></span><br></pre></td></tr></table></figure>

<p>您可以看到，我们已经捕获了发向nostarch.com的初始ICMP ping请求(根据输出末尾nostarch.com的IP可见，104.20.209.3)。如果您在Linux上运行这个示例，您将收到来自nostarch.com的响应。</p>
<p>嗅探一个包并不是特别有用，所以让我们添加一些功能来处理更多的包并解码它们的内容。</p>
<h2 id="IP层解码"><a href="#IP层解码" class="headerlink" title="IP层解码"></a>IP层解码</h2><p>在它当前的形式，我们的嗅探器接收所有的IP头，以及任何更高的协议，如TCP, UDP，或ICMP。正如前面所示，信息被打包成二进制形式，这很难理解。让我们对数据包的IP部分进行解码，以便从中提取有用的信息，例如协议类型(TCP、UDP或ICMP)以及源IP地址和目的IP地址。这将作为以后进一步协议解析的基础。</p>
<p>如果我们检查网络上的实际数据包是什么样子的，您应该了解我们需要如何解码传入的数据包。IP报头的组成请参见图3-1。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708200254367.png" alt="image-20210708200254367"></p>
<p>我们将解码整个IP报头(Options字段除外)，并提取协议类型、源IP地址和目的IP地址。这意味着我们将直接处理二进制文件，并且我们必须想出一种用Python分离IP头的每个部分的策略。</p>
<p>在Python中，有两种方法可以将外部二进制数据转换为一种数据结构。您可以使用 <em>ctypes</em> 模块或 <em>struct</em> 模块来定义数据结构。 <em>ctypes</em> 模块是Python的外部函数库。它为基于C的语言提供了一个桥梁，使您能够使用兼容C的数据类型和调用共享库中的函数。另一方面， <em>struct</em> 在Python值和表示为Python字节对象的C结构之间进行转换。换句话说， <em>ctypes</em> 模块除了提供许多其他功能外，还处理二进制数据类型，而 struct 模块主要处理二进制数据。</p>
<p>当你浏览web上的工具库时，你会看到这两种方法都被使用。本节将向您展示如何使用它们从网络中读取一个IPv4报头。这取决于您选择哪种方法；两种方法都可以。</p>
<h3 id="ctypes模块"><a href="#ctypes模块" class="headerlink" title="ctypes模块"></a>ctypes模块</h3><p>下面的代码片段定义了一个新类 <em>IP</em> ，它可以读取数据包并将报头解析为其单独的字段:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IP</span><span class="params">(Structure)</span>:</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">         (<span class="string">"ihl"</span>,           c_ubyte,   <span class="number">4</span>),       <span class="comment"># 4 bit unsigned char</span></span><br><span class="line">         (<span class="string">"version"</span>,       c_ubyte,   <span class="number">4</span>),       <span class="comment"># 4 bit unsigned char</span></span><br><span class="line">         (<span class="string">"tos"</span>,           c_ubyte,   <span class="number">8</span>),       <span class="comment"># 1 byte char</span></span><br><span class="line">         (<span class="string">"len"</span>,           c_ushort, <span class="number">16</span>),       <span class="comment"># 2 byte unsigned short</span></span><br><span class="line">         (<span class="string">"id"</span>,            c_ushort, <span class="number">16</span>),       <span class="comment"># 2 byte unsigned short</span></span><br><span class="line">         (<span class="string">"offset"</span>,        c_ushort, <span class="number">16</span>),       <span class="comment"># 2 byte unsigned short</span></span><br><span class="line">         (<span class="string">"ttl"</span>,           c_ubyte,   <span class="number">8</span>),       <span class="comment"># 1 byte char</span></span><br><span class="line">         (<span class="string">"protocol_num"</span>,  c_ubyte,   <span class="number">8</span>),       <span class="comment"># 1 byte char</span></span><br><span class="line">         (<span class="string">"sum"</span>,           c_ushort, <span class="number">16</span>),       <span class="comment"># 2 byte unsigned short</span></span><br><span class="line">         (<span class="string">"src"</span>,           c_uint32, <span class="number">32</span>),       <span class="comment"># 4 byte unsigned int</span></span><br><span class="line">         (<span class="string">"dst"</span>,           c_uint32, <span class="number">32</span>)        <span class="comment"># 4 byte unsigned int</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, socket_buffer=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.from_buffer_copy(socket_buffer)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, socket_buffer=None)</span>:</span></span><br><span class="line">        <span class="comment"># human readable IP addresses</span></span><br><span class="line">        self.src_address = socket.inet_ntoa(struct.pack(<span class="string">"&lt;L"</span>,self.src))</span><br><span class="line">        self.dst_address = socket.inet_ntoa(struct.pack(<span class="string">"&lt;L"</span>,self.dst))</span><br></pre></td></tr></table></figure>

<p>这个类创建一个 <em>_fields_</em> 结构来定义IP头的每个部分。该结构使用在 <em>ctypes</em> 模块中定义的C类型。例如， <em>c_ubyte</em> 类型是unsigned char类型， <em>c_ushort</em> 类型是unsigned short类型，等等。可以看到每个字段都与图3-1中的IP报头相匹配。每个字段描述都有三个参数:字段的名称(如 <em>ihl</em> 或 <em>offset</em> )，它所接受的值的类型(如 <em>c_ubyte</em> 或 <em>c_ushort</em> )，以及该字段的以位为单位的宽度(如 <em>ihl</em> 和 <em>version</em> 为4)。能够指定位宽是很方便的，因为它提供了指定我们需要的任何长度的自由，不仅是在字节级别(在字节级别的规范将强制我们定义的字段总是8位的倍数)。</p>
<p><em>IP</em> 类继承自 <em>ctypes</em> 模块的 <em>Structure</em> 类，该类指定在创建任何对象之前必须有一个已定义的 _<em>fields<em>_ 结构。为了填充_</em>fields*_结构， *Structure</em> 类使用 __<em>new</em>__ 方法，该方法将类引用作为第一个参数。它创建并返回类的一个对象，该对象传递给 __<em>init</em>__ 类函数。当我们创建IP对象时，我们将按照通常的方式进行，但在下面，Python调用 __<em>new</em>__ ，它在对象创建之前(当 __<em>init</em>__类函数被调用时)填充_fields_数据结构。只要你预先定义了这个结构，你就可以将外部网络数据包数据传递给 __new__ 函数，然后这些字段就会神奇地出现在你的对象属性中。</p>
<p>现在您已经了解了如何将C数据类型映射到IP头的值。在转换到Python对象时使用C代码作为参考可能会很有用，因为到纯Python的转换是无缝的。有关使用该模块的详细信息，请参阅 <em>ctypes</em> 文档。</p>
<h3 id="struct模块"><a href="#struct模块" class="headerlink" title="struct模块"></a>struct模块</h3><p><em>struct</em> 模块提供了可以用来指定二进制数据结构的格式字符。在下面的例子中，我们将再次定义一个 <em>IP</em> 类来保存头信息。但这一次，我们将使用格式字符来表示报头的各个部分:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ipaddress</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IP</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, buff=None)</span>:</span></span><br><span class="line">        header = struct.unpack(<span class="string">'&lt;BBHHHBBH4s4s'</span>, buff)</span><br><span class="line">    [<span class="number">1</span>] self.ver = header[<span class="number">0</span>] &gt;&gt; <span class="number">4</span></span><br><span class="line">    [<span class="number">2</span>] self.ihl = header[<span class="number">0</span>] &amp; <span class="number">0xF</span></span><br><span class="line">        self.tos = header[<span class="number">1</span>]</span><br><span class="line">        self.len = header[<span class="number">2</span>]</span><br><span class="line">        self.id = header[<span class="number">3</span>]</span><br><span class="line">        self.offset = header[<span class="number">4</span>]</span><br><span class="line">        self.ttl = header[<span class="number">5</span>]</span><br><span class="line">        self.protocol_num = header[<span class="number">6</span>]</span><br><span class="line">        self.sum = header[<span class="number">7</span>]</span><br><span class="line">        self.src = header[<span class="number">8</span>]</span><br><span class="line">        self.dst = header[<span class="number">9</span>]</span><br><span class="line">        <span class="comment"># human readable IP addresses</span></span><br><span class="line">        self.src_address = ipaddress.ip_address(self.src)</span><br><span class="line">        self.dst_address = ipaddress.ip_address(self.dst)</span><br><span class="line">        <span class="comment"># map protocol constants to their names</span></span><br><span class="line">        self.protocol_map = &#123;<span class="number">1</span>: <span class="string">"ICMP"</span>, <span class="number">6</span>: <span class="string">"TCP"</span>, <span class="number">17</span>: <span class="string">"UDP"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>第一个格式字符(在本例中是&lt;)总是指定数据的字节顺序，或者二进制数中的字节顺序。C类型以机器的本机格式和字节顺序表示。在本例中，我们在Kali (x64)上，这是小端序。在小端序存储的机器中，最低位字节存储在较低地址中，最高位字节存储在最高地址中。</p>
<p>下一个格式字符表示头的各个部分。<em>struct</em> 模块提供了几个格式字符。对于IP报头，我们只需要格式字符 <em>B</em> (1-byte unsigned char，1字节无符号字符)、 <em>H</em> (2-byte unsigned short，2字节无符号短字符)和s(a byte array that requires a byte-width specification; 4s means a 4-byte string，需要1字节宽度规范的字节数组;4s表示4字节字符串)。注意格式字符串是如何与图3-1中的IP报头图结构相匹配的。</p>
<p>记住，使用 <em>ctypes</em> ，我们可以指定单个头文件部分的位宽。使用 <em>struct</em> 模块时,  <em>nybble</em> (4位数据单位，也就是半字节，也称为<em>nibble</em>)没有格式字符，因此我们必须做一些操作，从头文件的第一部分获取 <em>ver</em> 和 <em>hdrlen</em> 变量。</p>
<p>对于我们接收到的头数据的第一个字节，我们给 ver 变量赋值仅 <em>high-order</em> 半字节(字节中的第一个nybble)。获得一个字节的高位半字节的典型方式是将字节 <em>right-shift</em> (右移)4位，这相当于在字节的前面加上4个0，导致最后4位减少[1]。这只给我们留下了原始字节的第一个字节。Python代码本质上是这样做的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>   <span class="number">1</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">0</span>   &gt;&gt; <span class="number">4</span></span><br><span class="line">-----------------------------</span><br><span class="line"><span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">0</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>我们想给 <em>hdrlen</em> 变量赋值低位nybble，即字节的最后4位。获取字节的第二个半字节的典型方法是对0xF(00001111) [2]使用布尔 <em>AND</em> (与)运算。这将应用布尔运算，使0和1“与”运算产生0(因为0等价于FALSE，而1等价于TRUE)。要使表达式为真，第一部分和最后一部分都必须为真。因此，这个操作删除了前4位，因为任何和0进行与运算的值都将是0。它保持最后4位不变，因为任何和1进行与运算的值都将返回原始值。本质上，Python代码对字节的操作如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">       <span class="number">0</span>   <span class="number">1</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">0</span></span><br><span class="line">AND    <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span>  </span><br><span class="line">-----------------------------</span><br><span class="line">       <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>您不需要非常了解二进制操作来解码IP头，但您将看到某些模式，如您在探索其他黑客的代码时发现会喜欢反复使用移位和AND，因此了解这些技术是值得的。</p>
<p>在这种需要一些位移位的情况下，解码二进制数据需要一些努力。但在许多情况下(如阅读ICMP消息),设置会很简单的:ICMP消息的每个部分都是8位的倍数,和 <em>struct</em> 模块提供的格式字符是8位的倍数,所以没有必要把一个字节成nybbles半字节分开。在如图3-2所示的Echo Reply ICMP报文中，可以看到ICMP报头的每个参数都可以用现有格式字母(BBHHH)中的一个来定义。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708200325445.png" alt="image-20210708200325445"></p>
<p>解析此消息的一种快速方法是简单地为前两个属性分配1字节，为后三个属性分配2字节:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ICMP</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, buff)</span>:</span></span><br><span class="line">        header = struct.unpack(<span class="string">'&lt;BBHHH'</span>, buff)</span><br><span class="line">        self.type = header[<span class="number">0</span>]</span><br><span class="line">        self.code = header[<span class="number">1</span>]</span><br><span class="line">        self.sum = header[<span class="number">2</span>]</span><br><span class="line">        self.id = header[<span class="number">3</span>]</span><br><span class="line">        self.seq = header[<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>阅读 <em>struct</em> 文档(<a href="https://docs.python.org/3/library/struct.html" target="_blank" rel="noopener">https://docs.python.org/3/library/struct.html</a>)了解使用这个模块的详细信息。</p>
<p>你可以使用 <em>ctypes</em> 模块或 <em>struct</em> 模块来读取和解析二进制数据。不管你采用哪种方法，你都会像这样实例化这个类:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mypacket = IP(buff)</span><br><span class="line">print(<span class="string">f'<span class="subst">&#123;mypacket.src_address&#125;</span> -&gt; <span class="subst">&#123;mypacket.dst_address&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，您用变量 <em>buff</em> 中的包数据实例化IP类。</p>
<h3 id="编写IP解码器"><a href="#编写IP解码器" class="headerlink" title="编写IP解码器"></a>编写IP解码器</h3><p>让我们实现刚才创建到 <em>sniffer_ip_header_decode.py</em> 文件中的IP解码程序，如下所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ipaddress</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">[<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">IP</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, buff=None)</span>:</span></span><br><span class="line">        header = struct.unpack(<span class="string">'&lt;BBHHHBBH4s4s'</span>, buff)</span><br><span class="line">        self.ver = header[<span class="number">0</span>] &gt;&gt; <span class="number">4</span></span><br><span class="line">        self.ihl = header[<span class="number">0</span>] &amp; <span class="number">0xF</span></span><br><span class="line">        self.tos = header[<span class="number">1</span>]</span><br><span class="line">        self.len = header[<span class="number">2</span>]</span><br><span class="line">        self.id = header[<span class="number">3</span>]</span><br><span class="line">        self.offset = header[<span class="number">4</span>]</span><br><span class="line">        self.ttl = header[<span class="number">5</span>]</span><br><span class="line">        self.protocol_num = header[<span class="number">6</span>]</span><br><span class="line">        self.sum = header[<span class="number">7</span>]</span><br><span class="line">        self.src = header[<span class="number">8</span>]</span><br><span class="line">        self.dst = header[<span class="number">9</span>]</span><br><span class="line">        [<span class="number">2</span>] <span class="comment"># human readable IP addresses</span></span><br><span class="line">        self.src_address = ipaddress.ip_address(self.src)</span><br><span class="line">        self.dst_address = ipaddress.ip_address(self.dst)</span><br><span class="line">        <span class="comment"># map protocol constants to their names</span></span><br><span class="line">        self.protocol_map = &#123;<span class="number">1</span>: <span class="string">"ICMP"</span>, <span class="number">6</span>: <span class="string">"TCP"</span>, <span class="number">17</span>: <span class="string">"UDP"</span>&#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.protocol = self.protocol_map[self.protocol_num]</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">'%s No protocol for %s'</span> % (e, self.protocol_num))</span><br><span class="line">            self.protocol = str(self.protocol_num)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sniff</span><span class="params">(host)</span>:</span></span><br><span class="line">        <span class="comment"># should look familiar from previous example</span></span><br><span class="line">        <span class="keyword">if</span> os.name == <span class="string">'nt'</span>:</span><br><span class="line">            socket_protocol = socket.IPPROTO_IP</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            socket_protocol = socket.IPPROTO_ICMP</span><br><span class="line">        sniffer = socket.socket(socket.AF_INET,</span><br><span class="line">                                socket.SOCK_RAW, socket_protocol)</span><br><span class="line">        sniffer.bind((host, <span class="number">0</span>))</span><br><span class="line">        sniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> os.name == <span class="string">'nt'</span>:</span><br><span class="line">            sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># read a packet</span></span><br><span class="line">            [<span class="number">3</span>] raw_buffer = sniffer.recvfrom(<span class="number">65535</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="comment"># create an IP header from the first 20 bytes</span></span><br><span class="line">            [<span class="number">4</span>] ip_header = IP(raw_buffer[<span class="number">0</span>:<span class="number">20</span>])</span><br><span class="line">                <span class="comment"># print the detected protocol and hosts</span></span><br><span class="line">            [<span class="number">5</span>] print(<span class="string">'Protocol: %s %s -&gt; %s'</span> % (ip_header.protocol,</span><br><span class="line">                                                    ip_header.src_address,</span><br><span class="line">                                                    ip_header.dst_address))</span><br><span class="line">        <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">            <span class="comment"># if we're on Windows, turn off promiscuous mode</span></span><br><span class="line">            <span class="keyword">if</span> os.name == <span class="string">'nt'</span>:</span><br><span class="line">                sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)</span><br><span class="line">            sys.exit()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">2</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        host = <span class="string">'192.168.1.203'</span></span><br><span class="line">    sniff(host)</span><br></pre></td></tr></table></figure>

<p>首先，我们引入了IP类定义[1]，它定义了一个Python结构，它将接收到的缓冲区的前20个字节映射到一个支持的IP头。正如您所看到的，我们标识的所有字段与头结构很好地匹配。我们做了一些处理，以产生一些我们可读的输出，这些输出表明正在使用的协议和连接中涉及的IP地址[2]。使用我们新创建的IP结构，我们现在编写规则断地读取包并解析它们的信息。我们读取包[3]，然后传递前20个字节[4]来初始化我们的IP结构。接下来，我们只需打印捕获的信息[5]。来试试吧。</p>
<h3 id="Kicking-the-Tires-1"><a href="#Kicking-the-Tires-1" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>让我们测试一下前面的代码，看看我们从发送的原始数据包中提取的是哪种信息。我们强烈建议您在您的Windows机器上进行此测试，因为您可以进行一些非常方便的测试(例如，打开一个浏览器)，然后将能够看到TCP、UDP和ICMP。如果您仅限于Linux，那么可以执行前面的ping测试来查看它的运行情况。</p>
<p>打开一个终端，输入以下内容:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sniffer_ip_header_decode.py</span><br></pre></td></tr></table></figure>

<p>现在，因为Windows是非常chatty，您可能会立即看到输出。作者通过打开Internet Explorer并访问<a href="http://www.google.com来测试这个脚本，下面是我们的脚本的输出" target="_blank" rel="noopener">www.google.com来测试这个脚本，下面是我们的脚本的输出</a>:</p>
<p>(笔者注：chatty我实在想不懂作者表达什么意思了。还有，竟然还有人用IE……国内用户换个网站吧，大家一定要遵守国家法律)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Protocol: UDP 192.168.0.190 -&gt; 192.168.0.1</span><br><span class="line">Protocol: UDP 192.168.0.1 -&gt; 192.168.0.190</span><br><span class="line">Protocol: UDP 192.168.0.190 -&gt; 192.168.0.187</span><br><span class="line">Protocol: TCP 192.168.0.187 -&gt; 74.125.225.183</span><br><span class="line">Protocol: TCP 192.168.0.187 -&gt; 74.125.225.183</span><br><span class="line">Protocol: TCP 74.125.225.183 -&gt; 192.168.0.187</span><br><span class="line">Protocol: TCP 192.168.0.187 -&gt; 74.125.225.183</span><br></pre></td></tr></table></figure>

<p>因为我们没有对这些数据包做任何深入的检查，所以我们只能猜测这个流表示什么。我们的猜测是，前两个UDP数据包是域名系统(DNS)查询，以确定google.com的网络位置，而随后的TCP会话才是我们的机器实际上连接和从他们的web服务器下载内容。</p>
<p>要在Linux上执行相同的测试，我们可以ping google.com，结果如下所示:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Protocol: ICMP 74.125.226.78 -&gt; 192.168.0.190</span><br><span class="line">Protocol: ICMP 74.125.226.78 -&gt; 192.168.0.190</span><br><span class="line">Protocol: ICMP 74.125.226.78 -&gt; 192.168.0.190</span><br></pre></td></tr></table></figure>

<p>您已经看到了限制:我们只看到响应，而且只有ICMP协议的数据包。但是因为我们是有意构建一个主机探测扫描器，所以这个结果是完全可以接受的。现在，我们将使用与解码IP报头相同的技术来解码ICMP消息。</p>
<h2 id="解码ICMP"><a href="#解码ICMP" class="headerlink" title="解码ICMP"></a>解码ICMP</h2><p>现在我们可以完全解码任何嗅探数据包的IP层，我们必须能够解码我们的扫描器捕获的发送UDP数据报到关闭的端口所引起的ICMP响应的包。ICMP消息的内容可能相差很大，但每条消息都包含保持一致的三个元素:类型、代码和校验和字段。类型和代码字段通知接收主机到达的ICMP消息的类型，然后指示如何正确解码。</p>
<p>为了扫描器的目标，我们要寻找类型值3和代码值3。3对应ICMP报文的 <em>Destination Unreachable</em> (目标不可达)类型，代码值为3表示已经导致了 <em>Port Unreachable</em> (端口不可达)错误。目标不可达ICMP报文示意图如图3-3所示。</p>
<p><img src= "/img/loading.gif" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/image-20210708200349839.png" alt="image-20210708200349839"></p>
<p>如您所见，前8位是类型，后8位包含我们的ICMP代码。需要注意的一件有趣的事情是，当主机发送其中一个ICMP消息时，它实际上包含生成响应的原始消息的IP头。我们还可以看到，我们将对发送的原始数据报的8个字节进行双重检查，以确保扫描器引发ICMP响应。为此，我们只需切掉所接收缓冲区的最后8个字节，以取出扫描器发送的magic字符串。</p>
<p>让我们在前面的扫描器中添加更多代码，以包括解码ICMP包的能力。让我们将前面的文件保存为 <em>sniffer_with_icmp.py</em> ，并添加以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ipaddress</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IP</span>:</span></span><br><span class="line">--snip--</span><br><span class="line">[<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">ICMP</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, buff)</span>:</span></span><br><span class="line">        header = struct.unpack(<span class="string">'&lt;BBHHH'</span>, buff)</span><br><span class="line">        self.type = header[<span class="number">0</span>]</span><br><span class="line">        self.code = header[<span class="number">1</span>]</span><br><span class="line">        self.sum = header[<span class="number">2</span>]</span><br><span class="line">        self.id = header[<span class="number">3</span>]</span><br><span class="line">        self.seq = header[<span class="number">4</span>]</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sniff</span><span class="params">(host)</span>:</span></span><br><span class="line">--snip--</span><br><span class="line">            ip_header = IP(raw_buffer[<span class="number">0</span>:<span class="number">20</span>])</span><br><span class="line">            <span class="comment"># if it's ICMP, we want it</span></span><br><span class="line">         [<span class="number">2</span>] <span class="keyword">if</span> ip_header.protocol == <span class="string">"ICMP"</span>:</span><br><span class="line">                print(<span class="string">'Protocol: %s %s -&gt; %s'</span> % (ip_header.protocol,</span><br><span class="line">                        ip_header.src_address, ip_header.dst_address))</span><br><span class="line">                print(<span class="string">f'Version: <span class="subst">&#123;ip_header.ver&#125;</span>'</span>)</span><br><span class="line">                print(<span class="string">f'Header Length: <span class="subst">&#123;ip_header.ihl&#125;</span> TTL: <span class="subst">&#123;ip_header.ttl&#125;</span>'</span>)</span><br><span class="line">                <span class="comment"># calculate where our ICMP packet starts</span></span><br><span class="line">            [<span class="number">3</span>] offset = ip_header.ihl * <span class="number">4</span></span><br><span class="line">                buf = raw_buffer[offset:offset + <span class="number">8</span>]</span><br><span class="line">                <span class="comment"># create our ICMP structure</span></span><br><span class="line">            [<span class="number">4</span>] icmp_header = ICMP(buf)</span><br><span class="line">                print(<span class="string">'ICMP -&gt; Type: %s Code: %s\n'</span> %</span><br><span class="line">                     (icmp_header.type, icmp_header.code))</span><br><span class="line">        <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">            <span class="keyword">if</span> os.name == <span class="string">'nt'</span>:</span><br><span class="line">                sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)</span><br><span class="line">            sys.exit()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">2</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        host = <span class="string">'192.168.1.203'</span></span><br><span class="line">    sniff(host)</span><br></pre></td></tr></table></figure>

<p>这段简单的代码在现有<em>IP</em>结构下创建了一个<em>ICMP</em>结构[1]。当数据包接收的主循环确定我们已经收到了ICMP包时[2]，我们计算原始包中的ICMP数据段[3]的偏移量，然后创建缓冲区[4]并打印<em>type</em>和<em>code</em>字段。长度计算是基于IP报头<em>ihl</em>字段，该字段表示IP报头中包含的32位字(4字节块)的数量。因此，通过将这个字段乘以4，我们就知道了IP报头的大小，从而知道下一个网络层(在本例中是ICMP)的开始位置。</p>
<p>如果我们用标准的ping测试运行这段代码，我们的输出现在应该略有不同:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Protocol: ICMP 74.125.226.78 -&gt; 192.168.0.190</span><br><span class="line">ICMP -&gt; Type: 0 Code: 0</span><br></pre></td></tr></table></figure>

<p>这表明ping (ICMP Echo)响应被正确接收和解码。现在我们已经准备好实现发送UDP数据报并解释其结果的最后一点功能。</p>
<p>现在让我们添加 <em>ipaddress</em> 模块的使用，这样我们就可以使用主机探测扫描覆盖整个子网。将 <em>sniffer_with_icmp.py</em> 脚本保存为 <em>scanner.py</em> ，并添加以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ipaddress</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># subnet to target</span></span><br><span class="line">SUBNET = <span class="string">'192.168.1.0/24'</span></span><br><span class="line"><span class="comment"># magic string we'll check ICMP responses for</span></span><br><span class="line">MESSAGE = <span class="string">'PYTHONRULES!'</span> [<span class="number">1</span>]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IP</span>:</span></span><br><span class="line">--snip--</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ICMP</span>:</span></span><br><span class="line">--snip--</span><br><span class="line"><span class="comment"># this sprays out UDP datagrams with our magic message</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">udp_sender</span><span class="params">()</span>:</span> [<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_DGRAM) <span class="keyword">as</span> sender:</span><br><span class="line">        <span class="keyword">for</span> ip <span class="keyword">in</span> ipaddress.ip_network(SUBNET).hosts():</span><br><span class="line">            sender.sendto(bytes(MESSAGE, <span class="string">'utf8'</span>), (str(ip), <span class="number">65212</span>))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>:</span> [<span class="number">3</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host)</span>:</span></span><br><span class="line">        self.host = host</span><br><span class="line">        <span class="keyword">if</span> os.name == <span class="string">'nt'</span>:</span><br><span class="line">            socket_protocol = socket.IPPROTO_IP</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            socket_protocol = socket.IPPROTO_ICMP</span><br><span class="line">        self.socket = socket.socket(socket.AF_INET,</span><br><span class="line">                                        socket.SOCK_RAW, socket_protocol)</span><br><span class="line">        self.socket.bind((host, <span class="number">0</span>))</span><br><span class="line">        self.socket.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> os.name == <span class="string">'nt'</span>:</span><br><span class="line">            self.socket.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sniff</span><span class="params">(self)</span>:</span> [<span class="number">4</span>]</span><br><span class="line">        hosts_up = set([<span class="string">f'<span class="subst">&#123;str(self.host)&#125;</span> *'</span>])</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># read a packet</span></span><br><span class="line">                raw_buffer = self.socket.recvfrom(<span class="number">65535</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="comment"># create an IP header from the first 20 bytes</span></span><br><span class="line">                ip_header = IP(raw_buffer[<span class="number">0</span>:<span class="number">20</span>])</span><br><span class="line">                <span class="comment"># if it's ICMP, we want it</span></span><br><span class="line">                <span class="keyword">if</span> ip_header.protocol == <span class="string">"ICMP"</span>:</span><br><span class="line">                    offset = ip_header.ihl * <span class="number">4</span></span><br><span class="line">                    buf = raw_buffer[offset:offset + <span class="number">8</span>]</span><br><span class="line">                    icmp_header = ICMP(buf)</span><br><span class="line">                    <span class="comment"># check for TYPE 3 and CODE</span></span><br><span class="line">                    <span class="keyword">if</span> icmp_header.code == <span class="number">3</span> <span class="keyword">and</span> icmp_header.type == <span class="number">3</span>:</span><br><span class="line">                        <span class="keyword">if</span> ipaddress.ip_address(ip_header.src_address) <span class="keyword">in</span> </span><br><span class="line">                                          ipaddress.IPv4Network(SUBNET): [<span class="number">5</span>]</span><br><span class="line">                            <span class="comment"># make sure it has our magic message</span></span><br><span class="line">                            <span class="keyword">if</span> raw_buffer[len(raw_buffer) - len(MESSAGE):] == </span><br><span class="line">                                          bytes(MESSAGE, <span class="string">'utf8'</span>): [<span class="number">6</span>]</span><br><span class="line">                                tgt = str(ip_header.src_address)</span><br><span class="line">                                <span class="keyword">if</span> tgt != self.host <span class="keyword">and</span> tgt <span class="keyword">not</span> <span class="keyword">in</span> hosts_up:</span><br><span class="line">                                    hosts_up.add(str(ip_header.src_address))</span><br><span class="line">                                    print(<span class="string">f'Host Up: <span class="subst">&#123;tgt&#125;</span>'</span>) [<span class="number">7</span>]</span><br><span class="line">        <span class="comment"># handle CTRL-C</span></span><br><span class="line">        <span class="keyword">except</span> KeyboardInterrupt: [<span class="number">8</span>]</span><br><span class="line">            <span class="keyword">if</span> os.name == <span class="string">'nt'</span>:</span><br><span class="line">                self.socket.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)</span><br><span class="line">            print(<span class="string">'\nUser interrupted.'</span>)</span><br><span class="line">            <span class="keyword">if</span> hosts_up:</span><br><span class="line">                print(<span class="string">f'\n\nSummary: Hosts up on <span class="subst">&#123;SUBNET&#125;</span>'</span>)</span><br><span class="line">            <span class="keyword">for</span> host <span class="keyword">in</span> sorted(hosts_up):</span><br><span class="line">                print(<span class="string">f'<span class="subst">&#123;host&#125;</span>'</span>)</span><br><span class="line">            print(<span class="string">''</span>)</span><br><span class="line">            sys.exit()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">2</span>:</span><br><span class="line">        host = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        host = <span class="string">'192.168.1.203'</span></span><br><span class="line">    s = Scanner(host)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    t = threading.Thread(target=udp_sender) [<span class="number">9</span>]</span><br><span class="line">    t.start()</span><br><span class="line">    s.sniff()</span><br></pre></td></tr></table></figure>

<p>最后这段代码应该相当容易理解。我们定义了一个简单的字符串签名[1]，以便我们可以测试响应是否来自我们最初发送的UDP包。我们的 <em>udp_sender</em> 函数[2]只接受我们在脚本顶部指定的子网，遍历该子网中的所有IP地址，并向它们发送UDP数据报。</p>
<p>然后定义一个 <em>Scanner</em> 类[3]。我们将一个host作为传递的参数来初始化它。当它初始化时，我们创建一个套接字，如果运行Windows则打开混杂模式，并使套接字成为 <em>Scanner</em> 类的一个属性。</p>
<p><em>sniff</em> 类函数[4]扫描网络，其步骤与前面的示例相同，只是这一次它保留了一个关于哪些主机是启动活跃的记录。如果我们检测到预期的ICMP消息，我们首先检查以确保ICMP响应来自我们的目标子网[5]。然后执行最后的检查，确保ICMP响应中有我们的magic字符串[6]。如果所有这些检查都通过了，我们将打印发出ICMP消息的主机的IP地址[7]。当我们使用CTRL-C结束扫描进程时，我们处理了键盘中断[8]。也就是说，如果在Windows上，我们会关闭混杂模式，并打印出活跃主机的排序列表。</p>
<p>__main__块执行设置的工作是:它创建 <em>Scanner</em> 对象，休眠几秒钟，然后，在调用 <em>sniff</em> 类函数之前，在一个单独的线程中生成 <em>udp_sender</em> [9]，以确保没有干扰到我们嗅探响应的能力。我们来试试吧。</p>
<h3 id="Kicking-the-Tires-2"><a href="#Kicking-the-Tires-2" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>现在让我们在本地网络上运行扫描器。您可以使用Linux或Windows，因为结果是相同的。在作者的例子中，我们所在的本地机器的IP地址是192.168.0.187，因此我们将扫描网段设置为192.168.0.0/24。如果在运行扫描程序时输出噪声太大，只需注释掉所有的print语句，除了最后一个告诉您哪些主机正在响应的语句。</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python.exe scanner.py</span><br><span class="line">Host Up: <span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">1</span></span><br><span class="line">Host Up: <span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">190</span></span><br><span class="line">Host Up: <span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">192</span></span><br><span class="line">Host Up: <span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">195</span></span><br></pre></td></tr></table></figure>

<p>IPADDRESS模块</p>
<p>我们的扫描器将使用一个名为 <em>ipaddress</em> 的库，它将允许我们提供一个子网掩码，例如192.168.0.0/24，并让扫描器以适合的方法处理它。</p>
<p><em>ipaddress</em> 模块使得使用子网和寻址非常容易。例如，您可以使用 <em>Ipv4Network</em> 对象运行如下简单测试:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip_address = <span class="string">"192.168.112.3"</span></span><br><span class="line"><span class="keyword">if</span> ip_address <span class="keyword">in</span> Ipv4Network(<span class="string">"192.168.112.0/24"</span>):</span><br><span class="line">    <span class="keyword">print</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>或者，如果你想把数据包发送到整个网络，你也可以创建简单的迭代器:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> Ipv4Network(<span class="string">"192.168.112.1/24"</span>):</span><br><span class="line">    s = socket.socket()</span><br><span class="line">    s.connect((ip, <span class="number">25</span>))</span><br><span class="line">    <span class="comment"># send mail packets</span></span><br></pre></td></tr></table></figure>

<p>当一次处理整个网络时，这将极大地简化您的编程工作，并且非常适合我们的主机发现工具。</p>
<p>对于像我们这样的快速扫描，只需要几秒钟就能得到结果。通过将这些IP地址与家用路由器中的DHCP表进行相互参照，我们能够验证结果是准确的。您可以很容易地扩展本章中所学的内容，以解码TCP和UDP包，并围绕扫描仪构建其他工具。这个扫描器对于我们将在第7章开始构建的木马框架也很有用。这将让部署的木马可以扫描本地网络以寻找其他目标。</p>
<p>现在，您已经了解了网络在高层和低层如何工作的基础知识，下面让我们探索一个非常成熟的Python库Scapy。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ma9icCR</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-3/">https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ma9iccr.github.io" target="_blank">Ma9icCR</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Black-Hat-Python-2nd/">Black_Hat_Python_2nd</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021-06/Black-Hat-Python-2nd-4/"><img class="prev-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Black Hat Python 2nd 4</div></div></a></div><div class="next-post pull-right"><a href="/2021-06/Black-Hat-Python-2nd-2/"><img class="next-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Black Hat Python 2nd 2</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-11/" title="Black Hat Python 2nd 11"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-23</div><div class="relatedPosts_title">Black Hat Python 2nd 11</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-10/" title="Black Hat Python 2nd 10"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-20</div><div class="relatedPosts_title">Black Hat Python 2nd 10</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-9/" title="Black Hat Python 2nd 9"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-18</div><div class="relatedPosts_title">Black Hat Python 2nd 9</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-8/" title="Black Hat Python 2nd 8"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-13</div><div class="relatedPosts_title">Black Hat Python 2nd 8</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-7/" title="Black Hat Python 2nd 7"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="relatedPosts_title">Black Hat Python 2nd 7</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-6/" title="Black Hat Python 2nd 6"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-03</div><div class="relatedPosts_title">Black Hat Python 2nd 6</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Ma9icCR</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>